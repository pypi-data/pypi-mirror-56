Metadata-Version: 2.1
Name: ecalic
Version: 0.0.3
Summary: A package to handle CMS Ecal InterCalibration constants and Ecal geometry
Home-page: https://gitlab.cern.ch/cms-ecal-dpg/ecalic
Author: Fabrice Couderc
Author-email: fabrice.couderc@cern.ch
License: UNKNOWN
Description: # ecalic package
        
        This package handles CMS Ecal Intercalibration Constant (IC) and IC-like operation and visualisation.
        This applies to several type of Ecal conditions which can have a value per crystal, for example:
        - EcalIntercalibConstantsRcd
        - EcalLaserAPDPNRatiosRcd
        - EcalChannelStatusRcd
        - EcalPedestalsRcd (pedestal or rms)
        
        The package contains two modules:
        - `ecalic.iov` decodes ecal conditions (xml format)
        - `ecalic.ic` the main module
        
        To install the package (and its dependence) and run the example (using ipython for instance):
        ```
        pip install --user ecalic
        pip install --user ipython
        pip install --user matplotlib
        pip install --user lxml
        pip install --user pandas
        pip install --user numpy
        
        ```
        
        ## ecalic.iov
        
        Use this module to decode an xml file downloaded from the database.
        The example (the commands can be run in `ipython`) below will transform a pedestal xml file
        in a txt file format (`ix iy iz ic`) where `ic` is the pedestal RMS in gain 6
        
        ```
        import os
        import ecalic.iov as iov
        
        pedestal_file = os.path.dirname( iov.__file__) + '/test/pedestals_hlt_run324773.xml'
        i = iov.xml( pedestal_file, type = 'noise6' )
        i.dump_txt('noise_gain6.txt')
        ```
        The available table can be found in the help
        ```
        ? iov.xml
        
        ```
        
        ## ecalic.ic
        
        This is the heart of the package. It contains:
        - the class `icCMS` which is represent the ic
        - the `geom` variable which handles all the different crystal property (pandas DataFrame)
        - the function `icCovCor` to get the correlation and covariance between different IC sets.
        
        A first simple example to see and plot crystal properties
        ```
        import pandas as pd, numpy as np
        import matplotlib.pyplot as plt
        import ecalic.ic as ic, ecalic.iov as iov
        import ecalic.cmsStyle as cms
        
        ### activate pyplot visualisation
        plt.ion()
        plt.show()
        
        ### dump the properties of 2 first crytals
        ic.geom.head(2)
        
        ### define an empty icCMS instance
        i = ic.icCMS()
        
        ### plot the FED in 2D
        i.plot(var= 'FED', title = 'FED number')
        
        ### plot the crytal type (BTCP or SIC)
        i.plot(var='fabric', title = 'producer')
        ```
        Note that the `cmsStyle` package is provided for plot polishing and is not mandatory.
        
        The different methods from the `icCMS` class can be found:
        ```
        dir(ic.icCMS)
        ```
        
        ### use-case example
        
        In this example we will:
        - get the noise (in gain 12) from two different runs (xml included in the package)
        - get the corresponding channel status
        - mask the bad channel in the noise ics
        - plot the noise in 2D
        - profile these noise along `ieta`
        - get the correlation between the 2 ics
        
        ```
        import os
        import pandas as pd, numpy as np
        import matplotlib.pyplot as plt
        import ecalic.ic as ic, ecalic.iov as iov
        import ecalic.cmsStyle as cms
        
        ### activate pyplot visualisation
        plt.ion()
        plt.show()
        
        ### get the inputs
        pedestal1 = os.path.dirname( iov.__file__) + '/test/pedestals_hlt_run324773.xml'
        status    = os.path.dirname( iov.__file__) + '/test/status_run324773.xml'
        pedestal2 = os.path.dirname( iov.__file__) + '/test/pedestals_hlt_run315840.xml'
        
        noise1 = ic.icCMS( iov.xml( pedestal1, type = 'noise12' ), 'noise (x12) run 324773' )
        noise2 = ic.icCMS( iov.xml( pedestal2, type = 'noise12' ), 'noise (x12) run 315840' )
        status = ic.icCMS( iov.xml( status   , type = 'status'  ), 'status run 324773' )
        
        ### mask bad channels (i.e. status != 0)
        noise1['ic'].mask( status['ic'] != 0 , inplace=True )
        noise2['ic'].mask( status['ic'] != 0 , inplace=True )
        
        ### plot the 2D noise map
        noise1.plot( zRange_eb = [1,3], zRange_ee = [1,3] )
        noise2.plot( zRange_eb = [1,3], zRange_ee = [1,3] )
        
        ### profile along eta
        plt.figure( 'Noise profile', figsize = [8,4] )
        axis = plt.gca()
        noise1.profile1D( axis = axis, legend = 'noise 1' )
        noise2.profile1D( axis = axis, legend = 'noise 2' )
        
        ### poslihing plot (not mandatory)
        cms.polishPlot(axis, xTitle = 'Crystal $i\eta$', yTitle = 'Pedestal RMS (ADC)', \
                        xRange = [-130,130], yRange = [0,3], \
                        year = 2018, legTitle = 'ECAL Noise', legLoc = 8)
        cms.ecalModuleBoundaries(axis)
        
        ### noises ratio, correlation ...
        plt.figure( 'Noise ratio', figsize = [8,4] )
        ratio = noise1 / noise2
        
        ### get the correlation in a group of crystal defined by grby
        ### (example: grby ieta band of 5 crystals)
        grby = np.sign(ic.geom['ieta']) * ((np.abs(ic.geom['ieta'])-1)//5)
        ratio['cov'],ratio['cor'] = ic.icCovCor(noise1,noise2,groupby=grby)
        
        ### plot the projection of the correlation along ieta
        ratio.profile1D(yvar = 'cor',axis = plt.gca(), title = 'correlation')
        
        ### plot polishing
        cms.polishPlot(plt.gca(), xTitle = 'Crystal $i\eta$', yTitle = 'Noise correlation',
                        xRange = [-130,130], yRange = [0,1], year = 2018 )
        cms.ecalModuleBoundaries(plt.gca())
        plt.gca().grid( axis = 'y', linestyle='--', linewidth=0.9, which = 'both')
        
        ```
        
Platform: UNKNOWN
Classifier: Programming Language :: Python
Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
Classifier: Operating System :: OS Independent
Requires-Python: >=2.7
Description-Content-Type: text/markdown
