import socket
import pickle
import ssl


def hostname():
    """Return ip address of this computer on the network"""
    try:
        return socket.gethostbyname_ex(socket.gethostname())[2][0]
    except socket.gaierror:
        return socket.gethostbyname_ex('localhost')[2][0]


def decode(data, encoding='utf-8'):
    """Decode a byte string to a string with a given ncoding"""
    return data.decode(encoding)


def encode(data, encoding='utf-8'):
    """Encode a string to bytes"""
    return data.encode(encoding)


def dumps(obj):
    """Pickle an python object with highest protocol"""
    return pickle.dumps(obj, protocol=-1)


def loads(obj):
    """Unpickle an object"""
    return pickle.loads(obj)


class ServerSocket:
    """Add an ssl wrapper around your regular python sockets
    Designed to be used to wrap clients, obtained from sock.accept
    Usage:

    # Create you client as usual
    client, addr = sock.accept()

    # Wrap your client with SSL/TLS
    client = ServerSocket(client)

    Constructor:
    @param: sock: A regular pyhon socket
    @param:context: An ssl context.
    You should first execute context.load_cert_chain(...)
    before passing the context to the constructor.
    @param: header_length: Max message size length used during sock.recv()
    @param: If use_ssl=True(Default), we use ssl otherwise the socket is not wrapped
    """

    def __init__(self, sock, context=None, header_length=10):
        if isinstance(context, ssl.SSLContext):
            self.sock = context.wrap_socket(sock, server_side=True)
        else:
            self.sock = sock

        self.header_length = header_length

    def __enter__(self):
        return self.sock

    def __exit__(self, exec_type, exc_value, tb):
        self.close()

    def compose_message(self, message: object):
        """Compose a message from python object.
        Pickles the message and the prepends the message header
        The message header contains metadata like length of the essage
        """
        pickled_message = dumps(message)
        message_header = encode(f"{len(pickled_message):<{self.header_length}}")
        return message_header + pickled_message

    def send(self, message):
        """Calls send_all internally"""
        return self.send_all(message)

    def send_all(self, message):
        """Send data to a remote peer
        Sends the pickled data generated by compose_message.
        Calls: sock.sendall()
        """
        pickled_message = self.compose_message(message)
        return self.sock.sendall(pickled_message)

    def receive_message(self):
        """Receive a message using header metadata
        Returns a dictionary containing two items:
        {
            "header": message_header,
            "data": message_bytes(unpickled)
        }

        If any exception occurs, an empty dictionary is returned
        """
        try:
            message_header = self.sock.recv(self.header_length)
            if not len(message_header):
                return False

            message_length = int(decode(message_header).strip())

            data = bytearray()
            while len(data) < message_length:
                packet = self.sock.recv(message_length - len(data))
                if not packet:
                    break
                data.extend(packet)

            return {
                "header": message_header,
                "data": loads(data)
            }
        except:
            return {}

    def recv(self):
        """"""
        message = self.receive_message()
        if message:
            return message['data']

    def close(self):
        try:
            self.sock.shutdown(socket.SHUT_RDWR)
            return self.sock.close()
        except OSError:
            pass

    def connect(self, address):
        """Do not call connect from server-side socket"""
        raise TypeError("Invalid call on server-side socket !")

    def __getattr__(self, name):
        return getattr(self.sock, name)


class ClientSocket(ServerSocket):
    """
    Inherits from ServerSocket.
    Re-implements __init__ and adds connect method.
    If no context is specified, you geta default context with
    purpose ssl/Purpose.CLIENT_AUTH
    At client side by defaut cert_required=False.

    """

    def __init__(self, context=None, header_length=10, use_ssl=True):
        if use_ssl is True:
            if context is None:
                ssl_context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
            else:
                ssl_context = context
            self.sock = ssl_context.wrap_socket(socket.socket())
        else:
            self.sock = socket.socket()

        self.header_length = header_length

    def connect(self, address):
        """Connect to an ssl socket at a given address"""
        return self.sock.connect(address)

    def accept(self):
        raise TypeError("Invalid call on client-side socket !")


class UPiClientSocket(ClientSocket):
    """SSL socket for sending unpickled data
    Behaves much like a normal socket.
    Pass bytes to send and sendall.
    """

    def compose_message(self, message: bytes):
        """Compose a message from python object"""
        message_header = encode(f"{len(message):<{self.header_length}}")
        return message_header + message

    def send(self, message: bytes):
        return self.send_all(message)

    def send_all(self, message: bytes):
        """Send data to a remote peer"""
        msg = self.compose_message(message)
        return self.sock.sendall(msg)

    def receive_message(self):
        """Receive the message as a dict of
        """
        try:
            message_header = self.sock.recv(self.header_length)
            message_length = int(decode(message_header).strip())

            data = bytearray()
            while len(data) < message_length:
                packet = self.sock.recv(message_length - len(data))
                if not packet:
                    break
                data.extend(packet)

            return {
                "header": message_header,
                "data": data
            }
        except:
            return {}

    def recv(self):
        """Receive message in a buffer"""
        message_header = self.sock.recv(self.header_length)
        message_length = int(decode(message_header).strip())
        return self.sock.recv(message_length)


class UPiServerSocket(ServerSocket):
    """
    SSL socket for sending unpickled data
    Re-implemts send and sendall, revc
    """

    def send(self, message: bytes):
        """Send message bytes to a remote peer"""
        return self.send_all(message)

    def send_all(self, message: bytes):
        """Send message bytes to a remote peer"""
        message_header = encode(f"{len(message):<{self.header_length}}")
        return self.sock.sendall(message_header + message)

    def recv(self):
        """
        Returns mesage bytes
        """
        message_header = self.sock.recv(self.header_length)
        message_length = int(decode(message_header).strip())

        data = bytearray()
        while len(data) < message_length:
            packet = self.sock.recv(message_length - len(data))
            if not packet:
                break
            data.extend(packet)
        return data
