{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The overall goals of the experimaestro manager are to: Decompose experiments into a set of parameterizable configurations and tasks Schedule tasks and handle dependencies between tasks Avoids to re-run the same task two times by computing unique task IDs dependending on the parameters","title":"Basics"},{"location":"developing/","text":"Tests To avoid SSH tests that require docker to be installed, use 1 ./test/experimaestro-tests --gtest_filter = \"-SshTest.*\"","title":"Developing"},{"location":"developing/#tests","text":"To avoid SSH tests that require docker to be installed, use 1 ./test/experimaestro-tests --gtest_filter = \"-SshTest.*\"","title":"Tests"},{"location":"main concepts/","text":"Main concepts The main concepts of experimaestro are Experimental pararameters are structured values, and can thus be nested. This is described in this document . Types and tasks are the unit on which experiments are built: Type = configuration Task = a process to be executed Tasks are composed by passing them as parameters to other tasks. Tasks are described further this document Computational resources are defined by connectors and launchers , define a set of computers - how can a file be stored, how can a command line be executed. More information can be found in this document .","title":"Main concepts"},{"location":"manager/definitions/","text":"Definitions Definitions files are in YAML or JSON, and describe the schema of types and tasks. In this document, the examples are in YAML, since the syntax is lighter. A definition file is divided in two sections, types and tasks , which are two dictionaries mapping a type or a task id to its definition. The definition is described in 1 2 3 4 5 6 7 8 9 10 11 types : type1 : - a : b type2 : ... tasks : task1 : ... task2 : ... Types A type is defined by a dictionary, whose keys can be: arguments The arguments that define the type type The type (by defaut, any ) help A markdown formatted help message for this argument default or generator provides a default value: default is an object corresponding to the default value Generators At the moment, only one generator is defined. 1 2 3 generator : type : path name : basename for the generated path Tasks","title":"Definitions"},{"location":"manager/definitions/#definitions","text":"Definitions files are in YAML or JSON, and describe the schema of types and tasks. In this document, the examples are in YAML, since the syntax is lighter. A definition file is divided in two sections, types and tasks , which are two dictionaries mapping a type or a task id to its definition. The definition is described in 1 2 3 4 5 6 7 8 9 10 11 types : type1 : - a : b type2 : ... tasks : task1 : ... task2 : ...","title":"Definitions"},{"location":"manager/definitions/#types","text":"A type is defined by a dictionary, whose keys can be: arguments The arguments that define the type type The type (by defaut, any ) help A markdown formatted help message for this argument default or generator provides a default value: default is an object corresponding to the default value","title":"Types"},{"location":"manager/definitions/#generators","text":"At the moment, only one generator is defined. 1 2 3 generator : type : path name : basename for the generated path","title":"Generators"},{"location":"manager/definitions/#tasks","text":"","title":"Tasks"},{"location":"manager/intro/","text":"Manager The manager is based on the definition of types and tasks . Tasks are types that are associated with a way to execute a process. Types and tasks can be defined in a YAML file, or, when bindings exist, directly in the host language. Available bindings are: Python Types A type is defined by: A qualified name A parent A list of arguments Example The following YAML code defines two types, one 1 2 3 4 5 6 7 8 9 10 11 12 13 14 my.model.abstract : {} my.model : parent : \"my.model.abstract\" arguments : parameters count : default : 10 help : Number of nuggets to include type : integer $seed : defaut : 0 type : int help : Seed for the model parameters Basic types These types are predefined int real string Complex types array map Tasks A task extends a type by associating it with command to run. 1 2 3 4 5 6 7 8 9 tasks : indri.index : type : indri.index command : - pathref : indri.PYTHON_PATH - pathref : indri.MAIN_PY - run - indri.index - type : parameters","title":"Intro"},{"location":"manager/intro/#manager","text":"The manager is based on the definition of types and tasks . Tasks are types that are associated with a way to execute a process. Types and tasks can be defined in a YAML file, or, when bindings exist, directly in the host language. Available bindings are: Python","title":"Manager"},{"location":"manager/intro/#types","text":"A type is defined by: A qualified name A parent A list of arguments Example The following YAML code defines two types, one 1 2 3 4 5 6 7 8 9 10 11 12 13 14 my.model.abstract : {} my.model : parent : \"my.model.abstract\" arguments : parameters count : default : 10 help : Number of nuggets to include type : integer $seed : defaut : 0 type : int help : Seed for the model parameters","title":"Types"},{"location":"manager/intro/#basic-types","text":"These types are predefined int real string","title":"Basic types"},{"location":"manager/intro/#complex-types","text":"array map","title":"Complex types"},{"location":"manager/intro/#tasks","text":"A task extends a type by associating it with command to run. 1 2 3 4 5 6 7 8 9 tasks : indri.index : type : indri.index command : - pathref : indri.PYTHON_PATH - pathref : indri.MAIN_PY - run - indri.index - type : parameters","title":"Tasks"},{"location":"manager/json/","text":"Introduction JSON is used to describe resources. Special names are reserved by experimaestro to automate some processes. Signature A key point of JSON objects are that a signature can be computed. This signature allows to identify completely one experimental results by tracing back all its parameters. Signature computation is explained in this section . We will make use of an example of a message 1 2 3 4 { \"alpha\" : 3 , \"$type\" : \"integer\" , } This document describes the JSON format used by tasks to communicate. Here are the key facts: Any Json type is a valid message Predefined datatypes are defined in Experimaestro (integers, strings, etc.). Types are given by the $type tag, or by the type of the value when using JSON primitives. Messages can be compared. This is useful when comparing two resources Special tags and/or attributes allows to Define resources Define the parameters and their values that were used to generate an output Reserved JSON keys Some keys have a special meaning in experimaestro: $value correspond to the simple value of the JSON $type correspond to the type of the JSON $tag correspond to a tag - those can be used to mark special values (e.g. parameters under study) $resource corresponds to an experimaestro resource $default default value $path the path $ignore list of keys to ignore (besides those prefixed by $ ) Predefined types string for strings integer for boolean integer for integers real for reals path for anything corresponding to a file or a directory (even on the network) Signature Each JSON can be reduced to a signature that corresponds to the JSON describing the factor of variation of the outcome of an experiment. Replacing simple values by their value Stripping paths Stripping all keys beginning by $ except $type 1 2 3 4 5 6 7 8 { \"x\" : { \"$type\" : \"integer\" , \"$value\" : 13 }, \"y\" : { \"k\" : 1 } \"path\" : { \"$type\" : \"path\" , \"$value\" : \"/path/to/a/file\" }, \"$resource\" : \"/uri/of/resource\" , } The signature will be 1 2 3 4 { \"x\" : 13 , \"y\" : { \"k\" : 1 } } Tags Tags are used to mark parameters that are under study, i.e. parameters that the current experiment are interested in looking at. When a parameter is tagged, the JSON representation adds a $tag entry that gives the name of the parameter 1 { \"$type\" : \"integer\" , \"$value\" : 13 , \"$tag\" : \"x\" } , This can be achieved by calling the function tag from xpm: 1 2 from xpm import tag tag ( \"x\" , 1 ) Tags can be retrieved using the retrieve_tags function. This can be achieved by calling the function tag from xpm: 1 2 from xpm import retrieve_tags retrieve_tags ( json ) If json is 1 2 3 4 json = { \"x\" : { \"$type\" : \"integer\" , \"$value\" : 13 , \"$tag\" : \"x\" }, \"y\" : { \"$type\" : \"real\" , \"$value\" : 1.2 , \"$tag\" : \"y\" }, } then the output will be 1 2 3 4 5 { \"x\" : { \"$type\" : \"integer\" , \"$value\" : 13 , \"$tag\" : \"x\" }, \"y\" : { \"$type\" : \"real\" , \"$value\" : 1.2 , \"$tag\" : \"y\" }, \"tags\" : { \"x\" : 1 , \"y\" : 1.2 } } This allows further tasks to use the tags values for building e.g. tables of results.","title":"Output"},{"location":"manager/json/#introduction","text":"JSON is used to describe resources. Special names are reserved by experimaestro to automate some processes. Signature A key point of JSON objects are that a signature can be computed. This signature allows to identify completely one experimental results by tracing back all its parameters. Signature computation is explained in this section . We will make use of an example of a message 1 2 3 4 { \"alpha\" : 3 , \"$type\" : \"integer\" , } This document describes the JSON format used by tasks to communicate. Here are the key facts: Any Json type is a valid message Predefined datatypes are defined in Experimaestro (integers, strings, etc.). Types are given by the $type tag, or by the type of the value when using JSON primitives. Messages can be compared. This is useful when comparing two resources Special tags and/or attributes allows to Define resources Define the parameters and their values that were used to generate an output","title":"Introduction"},{"location":"manager/json/#reserved-json-keys","text":"Some keys have a special meaning in experimaestro: $value correspond to the simple value of the JSON $type correspond to the type of the JSON $tag correspond to a tag - those can be used to mark special values (e.g. parameters under study) $resource corresponds to an experimaestro resource $default default value $path the path $ignore list of keys to ignore (besides those prefixed by $ )","title":"Reserved JSON keys"},{"location":"manager/json/#predefined-types","text":"string for strings integer for boolean integer for integers real for reals path for anything corresponding to a file or a directory (even on the network)","title":"Predefined types"},{"location":"manager/json/#signature","text":"Each JSON can be reduced to a signature that corresponds to the JSON describing the factor of variation of the outcome of an experiment. Replacing simple values by their value Stripping paths Stripping all keys beginning by $ except $type 1 2 3 4 5 6 7 8 { \"x\" : { \"$type\" : \"integer\" , \"$value\" : 13 }, \"y\" : { \"k\" : 1 } \"path\" : { \"$type\" : \"path\" , \"$value\" : \"/path/to/a/file\" }, \"$resource\" : \"/uri/of/resource\" , } The signature will be 1 2 3 4 { \"x\" : 13 , \"y\" : { \"k\" : 1 } }","title":"Signature"},{"location":"manager/json/#tags","text":"Tags are used to mark parameters that are under study, i.e. parameters that the current experiment are interested in looking at. When a parameter is tagged, the JSON representation adds a $tag entry that gives the name of the parameter 1 { \"$type\" : \"integer\" , \"$value\" : 13 , \"$tag\" : \"x\" } , This can be achieved by calling the function tag from xpm: 1 2 from xpm import tag tag ( \"x\" , 1 ) Tags can be retrieved using the retrieve_tags function. This can be achieved by calling the function tag from xpm: 1 2 from xpm import retrieve_tags retrieve_tags ( json ) If json is 1 2 3 4 json = { \"x\" : { \"$type\" : \"integer\" , \"$value\" : 13 , \"$tag\" : \"x\" }, \"y\" : { \"$type\" : \"real\" , \"$value\" : 1.2 , \"$tag\" : \"y\" }, } then the output will be 1 2 3 4 5 { \"x\" : { \"$type\" : \"integer\" , \"$value\" : 13 , \"$tag\" : \"x\" }, \"y\" : { \"$type\" : \"real\" , \"$value\" : 1.2 , \"$tag\" : \"y\" }, \"tags\" : { \"x\" : 1 , \"y\" : 1.2 } } This allows further tasks to use the tags values for building e.g. tables of results.","title":"Tags"},{"location":"scheduler/","text":"Main concepts The job scheduler goal is to run interdependent jobs (i.e. one job might need one or several outputs from other jobs) Resources : Any object is a resource, whether it is data, a job, or a server. Resources are located on different hosts that can be specified by a URI. For example, file:///a/b/c denotes a local folder or file, while xpm:token:user@hostname.org corresponds to a token used to limit the number of launched processes on a given computer. Connectors : Connectors specify how a resource can be accessed and how processes can be launched. Single connectors (i.e., localhost and ssh) are built-in. Composite connectors (i.e., describing a cluster of computers) can be built from single connectors. Resource state : A resource can be in the state WAITING (waiting for dependencies to be met), HOLD (waiting a user action) consequently to a dependency being in the ERROR or HOLD state. DONE when completed, ERROR . For tasks that can be run, two other states are possible: READY (waiting to be run), RUNNING , Groups : One should allow to set a group for a set of experiments. For example: I run several series of experiment and call them \"trec.test1\", \"trec.test2\". I can then operate on all the resources of a specific group, like e.g. \"trec\" or \"trec.test1\". General architecture Resources We have the following types of resources: Data: the output of one job (one job can have several outputs). Some data can also be already generated by an external process (e.g. a data collection) and be declared to experimaestro as read. Data can be in three states: WAITING , HOLD or DONE . Task: Job: a task to be run, that produces a given set of resources. Server: a task that need to be run; however, we don't wait for the server run to complete. * Status Every resource (see below) has a unique ID which is a path to a directory containing information about the resource on the host. Based on the file ${FILE} , several paths are defined (note that not all files might be present) ${FILE}.lock locks the write access to the status (can also be used as an exclusive lock to the resource) This file is used whenever an exclusive access is needed. ${FILE}.status contains the PID of the running process (two columns PID MODE separated by space) where MODE is r, w. This file is used when the resource can be accessed by a single writer and multiple readers ${FILE}.run corresponds to the script that are needed to execute the job ${FILE}.code corresponds to the error code at the end of the execution of the job ${FILE}.done created when the job was successfully executed or the data successfully generated ${FILE}.err contains the error log output (jobs only) ${FILE}.out contains the standard log output (jobs only) ${FILE}.input contains the standard input (jobs only) Using experimaestro XML-RPC The Experimaestro server can be reached through XML-RPC calls .","title":"Home"},{"location":"scheduler/#main-concepts","text":"The job scheduler goal is to run interdependent jobs (i.e. one job might need one or several outputs from other jobs) Resources : Any object is a resource, whether it is data, a job, or a server. Resources are located on different hosts that can be specified by a URI. For example, file:///a/b/c denotes a local folder or file, while xpm:token:user@hostname.org corresponds to a token used to limit the number of launched processes on a given computer. Connectors : Connectors specify how a resource can be accessed and how processes can be launched. Single connectors (i.e., localhost and ssh) are built-in. Composite connectors (i.e., describing a cluster of computers) can be built from single connectors. Resource state : A resource can be in the state WAITING (waiting for dependencies to be met), HOLD (waiting a user action) consequently to a dependency being in the ERROR or HOLD state. DONE when completed, ERROR . For tasks that can be run, two other states are possible: READY (waiting to be run), RUNNING , Groups : One should allow to set a group for a set of experiments. For example: I run several series of experiment and call them \"trec.test1\", \"trec.test2\". I can then operate on all the resources of a specific group, like e.g. \"trec\" or \"trec.test1\".","title":"Main concepts"},{"location":"scheduler/#general-architecture","text":"","title":"General architecture"},{"location":"scheduler/#resources","text":"We have the following types of resources: Data: the output of one job (one job can have several outputs). Some data can also be already generated by an external process (e.g. a data collection) and be declared to experimaestro as read. Data can be in three states: WAITING , HOLD or DONE . Task: Job: a task to be run, that produces a given set of resources. Server: a task that need to be run; however, we don't wait for the server run to complete. *","title":"Resources"},{"location":"scheduler/#status","text":"Every resource (see below) has a unique ID which is a path to a directory containing information about the resource on the host. Based on the file ${FILE} , several paths are defined (note that not all files might be present) ${FILE}.lock locks the write access to the status (can also be used as an exclusive lock to the resource) This file is used whenever an exclusive access is needed. ${FILE}.status contains the PID of the running process (two columns PID MODE separated by space) where MODE is r, w. This file is used when the resource can be accessed by a single writer and multiple readers ${FILE}.run corresponds to the script that are needed to execute the job ${FILE}.code corresponds to the error code at the end of the execution of the job ${FILE}.done created when the job was successfully executed or the data successfully generated ${FILE}.err contains the error log output (jobs only) ${FILE}.out contains the standard log output (jobs only) ${FILE}.input contains the standard input (jobs only)","title":"Status"},{"location":"scheduler/#using-experimaestro","text":"","title":"Using experimaestro"},{"location":"scheduler/#xml-rpc","text":"The Experimaestro server can be reached through XML-RPC calls .","title":"XML-RPC"},{"location":"scheduler/connectors/","text":"Connectors describe a computational resource, as for example a single computer ( single host connector ) or a set of computers. It provides information on how to access the file system and execute commands. At the moment, the following connectors are defined: Localhost SSH Launchers are used to launch commands: Direct launcher: standard command launching OAR: uses OAR to launch jobs on a cluster Connectors A connector defines: The main connector used to manage the state of a resource associated with this connector; A way to select a single host connector given some computational requirements (e.g. 1G memory); Localhost SSH Launchers Connectors are used to connect to a specific computer in order to execute a command or access a file system. Here is the list of available connectors: Direct launcher DirectLauncher : Executes a command via a shell script OAR OARLauncher : Launches a job through OAR Finding and describing resources In order to allow full flexibility, resources are described by a URI, which in most cases is a URL (e.g. file://path/to/my/file ). In order to map back a URI to a connector, Experimaestro has a set of handlers associated with protocols (in order to deal with an URL), and custom handlers can be added. The same resource can be at different paths depending on the host (i.e. via mounts). In order to deal with that, Available connectors Group Defines a set of connectors Localhost SSH Launcher Launchers are used to define how a command is executed. Here is the list of available launchers: ShLauncher: runs commands using the sh shell OARLauncher: runs commands using OAR","title":"Connectors & Launchers"},{"location":"scheduler/connectors/#connectors","text":"A connector defines: The main connector used to manage the state of a resource associated with this connector; A way to select a single host connector given some computational requirements (e.g. 1G memory);","title":"Connectors"},{"location":"scheduler/connectors/#localhost","text":"","title":"Localhost"},{"location":"scheduler/connectors/#ssh","text":"","title":"SSH"},{"location":"scheduler/connectors/#launchers","text":"Connectors are used to connect to a specific computer in order to execute a command or access a file system. Here is the list of available connectors:","title":"Launchers"},{"location":"scheduler/connectors/#direct-launcher","text":"DirectLauncher : Executes a command via a shell script","title":"Direct launcher"},{"location":"scheduler/connectors/#oar","text":"OARLauncher : Launches a job through OAR","title":"OAR"},{"location":"scheduler/connectors/#finding-and-describing-resources","text":"In order to allow full flexibility, resources are described by a URI, which in most cases is a URL (e.g. file://path/to/my/file ). In order to map back a URI to a connector, Experimaestro has a set of handlers associated with protocols (in order to deal with an URL), and custom handlers can be added. The same resource can be at different paths depending on the host (i.e. via mounts). In order to deal with that,","title":"Finding and describing resources"},{"location":"scheduler/connectors/#available-connectors","text":"","title":"Available connectors"},{"location":"scheduler/connectors/#group","text":"Defines a set of connectors","title":"Group"},{"location":"scheduler/connectors/#localhost_1","text":"","title":"Localhost"},{"location":"scheduler/connectors/#ssh_1","text":"","title":"SSH"},{"location":"scheduler/connectors/#launcher","text":"Launchers are used to define how a command is executed. Here is the list of available launchers: ShLauncher: runs commands using the sh shell OARLauncher: runs commands using OAR","title":"Launcher"},{"location":"scheduler/notification/","text":"It is possible to notify Experimaestro of the progress of a job. If notification is possible, the environment variable XPM_NOTIFICATION_URL is set by the launcher. It gives the URL that has to be used to notify that something has happened (for the moment, only a progress value between 0 and 1 is allowed) Bash With wget 1 test \"$XPM_NOTIFICATION_URL\" && wget --quiet -O /dev/null \"$XPM_NOTIFICATION_URL/progress/$progress\" Python In Python, the simplest is to use the experimaestro library 1 2 3 4 from experimaestro import progress # Report progress of 10% progress ( . 1 )","title":"Notification"},{"location":"scheduler/notification/#bash","text":"With wget 1 test \"$XPM_NOTIFICATION_URL\" && wget --quiet -O /dev/null \"$XPM_NOTIFICATION_URL/progress/$progress\"","title":"Bash"},{"location":"scheduler/notification/#python","text":"In Python, the simplest is to use the experimaestro library 1 2 3 4 from experimaestro import progress # Report progress of 10% progress ( . 1 )","title":"Python"}]}