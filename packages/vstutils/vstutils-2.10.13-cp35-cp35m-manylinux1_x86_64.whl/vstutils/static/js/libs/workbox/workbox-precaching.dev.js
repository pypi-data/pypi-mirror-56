this.workbox=this.workbox||{};this.workbox.precaching=(function(exports,assert_mjs,cacheNames_mjs,getFriendlyURL_mjs,logger_mjs,cacheWrapper_mjs,fetchWrapper_mjs,WorkboxError_mjs){'use strict';try{self['workbox:precaching:4.3.1']&&_();}catch(e){}
const plugins=[];const precachePlugins={get(){return plugins;},add(newPlugins){plugins.push(...newPlugins);}};const addPlugins=newPlugins=>{precachePlugins.add(newPlugins);};async function cleanRedirect(response){const clonedResponse=response.clone();const bodyPromise='body'in clonedResponse?Promise.resolve(clonedResponse.body):clonedResponse.blob();const body=await bodyPromise;return new Response(body,{headers:clonedResponse.headers,status:clonedResponse.status,statusText:clonedResponse.statusText});}
const REVISION_SEARCH_PARAM='__WB_REVISION__';function createCacheKey(entry){if(!entry){throw new WorkboxError_mjs.WorkboxError('add-to-cache-list-unexpected-type',{entry});}
if(typeof entry==='string'){const urlObject=new URL(entry,location);return{cacheKey:urlObject.href,url:urlObject.href};}
const{revision,url}=entry;if(!url){throw new WorkboxError_mjs.WorkboxError('add-to-cache-list-unexpected-type',{entry});}
if(!revision){const urlObject=new URL(url,location);return{cacheKey:urlObject.href,url:urlObject.href};}
const originalURL=new URL(url,location);const cacheKeyURL=new URL(url,location);cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM,revision);return{cacheKey:cacheKeyURL.href,url:originalURL.href};}
const logGroup=(groupTitle,deletedURLs)=>{logger_mjs.logger.groupCollapsed(groupTitle);for(const url of deletedURLs){logger_mjs.logger.log(url);}
logger_mjs.logger.groupEnd();};function printCleanupDetails(deletedURLs){const deletionCount=deletedURLs.length;if(deletionCount>0){logger_mjs.logger.groupCollapsed(`During precaching cleanup, `+`${deletionCount} cached `+`request${deletionCount === 1 ? ' was' : 's were'} deleted.`);logGroup('Deleted Cache Requests',deletedURLs);logger_mjs.logger.groupEnd();}}
function _nestedGroup(groupTitle,urls){if(urls.length===0){return;}
logger_mjs.logger.groupCollapsed(groupTitle);for(const url of urls){logger_mjs.logger.log(url);}
logger_mjs.logger.groupEnd();}
function printInstallDetails(urlsToPrecache,urlsAlreadyPrecached){const precachedCount=urlsToPrecache.length;const alreadyPrecachedCount=urlsAlreadyPrecached.length;if(precachedCount||alreadyPrecachedCount){let message=`Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;if(alreadyPrecachedCount>0){message+=` ${alreadyPrecachedCount} `+`file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;}
logger_mjs.logger.groupCollapsed(message);_nestedGroup(`View newly precached URLs.`,urlsToPrecache);_nestedGroup(`View previously precached URLs.`,urlsAlreadyPrecached);logger_mjs.logger.groupEnd();}}
class PrecacheController{constructor(cacheName){this._cacheName=cacheNames_mjs.cacheNames.getPrecacheName(cacheName);this._urlsToCacheKeys=new Map();}
addToCacheList(entries){{assert_mjs.assert.isArray(entries,{moduleName:'workbox-precaching',className:'PrecacheController',funcName:'addToCacheList',paramName:'entries'});}
for(const entry of entries){const{cacheKey,url}=createCacheKey(entry);if(this._urlsToCacheKeys.has(url)&&this._urlsToCacheKeys.get(url)!==cacheKey){throw new WorkboxError_mjs.WorkboxError('add-to-cache-list-conflicting-entries',{firstEntry:this._urlsToCacheKeys.get(url),secondEntry:cacheKey});}
this._urlsToCacheKeys.set(url,cacheKey);}}
async install({event,plugins}={}){{if(plugins){assert_mjs.assert.isArray(plugins,{moduleName:'workbox-precaching',className:'PrecacheController',funcName:'install',paramName:'plugins'});}}
const urlsToPrecache=[];const urlsAlreadyPrecached=[];const cache=await caches.open(this._cacheName);const alreadyCachedRequests=await cache.keys();const alreadyCachedURLs=new Set(alreadyCachedRequests.map(request=>request.url));for(const cacheKey of this._urlsToCacheKeys.values()){if(alreadyCachedURLs.has(cacheKey)){urlsAlreadyPrecached.push(cacheKey);}else{urlsToPrecache.push(cacheKey);}}
const precacheRequests=urlsToPrecache.map(url=>{return this._addURLToCache({event,plugins,url});});await Promise.all(precacheRequests);{printInstallDetails(urlsToPrecache,urlsAlreadyPrecached);}
return{updatedURLs:urlsToPrecache,notUpdatedURLs:urlsAlreadyPrecached};}
async activate(){const cache=await caches.open(this._cacheName);const currentlyCachedRequests=await cache.keys();const expectedCacheKeys=new Set(this._urlsToCacheKeys.values());const deletedURLs=[];for(const request of currentlyCachedRequests){if(!expectedCacheKeys.has(request.url)){await cache.delete(request);deletedURLs.push(request.url);}}
{printCleanupDetails(deletedURLs);}
return{deletedURLs};}
async _addURLToCache({url,event,plugins}){const request=new Request(url,{credentials:'same-origin'});let response=await fetchWrapper_mjs.fetchWrapper.fetch({event,plugins,request});let cacheWillUpdateCallback;for(const plugin of plugins||[]){if('cacheWillUpdate'in plugin){cacheWillUpdateCallback=plugin.cacheWillUpdate.bind(plugin);}}
const isValidResponse=cacheWillUpdateCallback?cacheWillUpdateCallback({event,request,response}):response.status<400;if(!isValidResponse){throw new WorkboxError_mjs.WorkboxError('bad-precaching-response',{url,status:response.status});}
if(response.redirected){response=await cleanRedirect(response);}
await cacheWrapper_mjs.cacheWrapper.put({event,plugins,request,response,cacheName:this._cacheName,matchOptions:{ignoreSearch:true}});}
getURLsToCacheKeys(){return this._urlsToCacheKeys;}
getCachedURLs(){return[...this._urlsToCacheKeys.keys()];}
getCacheKeyForURL(url){const urlObject=new URL(url,location);return this._urlsToCacheKeys.get(urlObject.href);}}
let precacheController;const getOrCreatePrecacheController=()=>{if(!precacheController){precacheController=new PrecacheController();}
return precacheController;};function removeIgnoredSearchParams(urlObject,ignoreURLParametersMatching){for(const paramName of[...urlObject.searchParams.keys()]){if(ignoreURLParametersMatching.some(regExp=>regExp.test(paramName))){urlObject.searchParams.delete(paramName);}}
return urlObject;}
function*generateURLVariations(url,{ignoreURLParametersMatching,directoryIndex,cleanURLs,urlManipulation}={}){const urlObject=new URL(url,location);urlObject.hash='';yield urlObject.href;const urlWithoutIgnoredParams=removeIgnoredSearchParams(urlObject,ignoreURLParametersMatching);yield urlWithoutIgnoredParams.href;if(directoryIndex&&urlWithoutIgnoredParams.pathname.endsWith('/')){const directoryURL=new URL(urlWithoutIgnoredParams);directoryURL.pathname+=directoryIndex;yield directoryURL.href;}
if(cleanURLs){const cleanURL=new URL(urlWithoutIgnoredParams);cleanURL.pathname+='.html';yield cleanURL.href;}
if(urlManipulation){const additionalURLs=urlManipulation({url:urlObject});for(const urlToAttempt of additionalURLs){yield urlToAttempt.href;}}}
const getCacheKeyForURL=(url,options)=>{const precacheController=getOrCreatePrecacheController();const urlsToCacheKeys=precacheController.getURLsToCacheKeys();for(const possibleURL of generateURLVariations(url,options)){const possibleCacheKey=urlsToCacheKeys.get(possibleURL);if(possibleCacheKey){return possibleCacheKey;}}};const addFetchListener=({ignoreURLParametersMatching=[/^utm_/],directoryIndex='index.html',cleanURLs=true,urlManipulation=null}={})=>{const cacheName=cacheNames_mjs.cacheNames.getPrecacheName();addEventListener('fetch',event=>{const precachedURL=getCacheKeyForURL(event.request.url,{cleanURLs,directoryIndex,ignoreURLParametersMatching,urlManipulation});if(!precachedURL){{logger_mjs.logger.debug(`Precaching did not find a match for `+getFriendlyURL_mjs.getFriendlyURL(event.request.url));}
return;}
let responsePromise=caches.open(cacheName).then(cache=>{return cache.match(precachedURL);}).then(cachedResponse=>{if(cachedResponse){return cachedResponse;}
{logger_mjs.logger.warn(`The precached response for `+`${getFriendlyURL_mjs.getFriendlyURL(precachedURL)} in ${cacheName} was not found. `+`Falling back to the network instead.`);}
return fetch(precachedURL);});{responsePromise=responsePromise.then(response=>{logger_mjs.logger.groupCollapsed(`Precaching is responding to: `+getFriendlyURL_mjs.getFriendlyURL(event.request.url));logger_mjs.logger.log(`Serving the precached url: ${precachedURL}`);logger_mjs.logger.groupCollapsed(`View request details here.`);logger_mjs.logger.log(event.request);logger_mjs.logger.groupEnd();logger_mjs.logger.groupCollapsed(`View response details here.`);logger_mjs.logger.log(response);logger_mjs.logger.groupEnd();logger_mjs.logger.groupEnd();return response;});}
event.respondWith(responsePromise);});};let listenerAdded=false;const addRoute=options=>{if(!listenerAdded){addFetchListener(options);listenerAdded=true;}};const SUBSTRING_TO_FIND='-precache-';const deleteOutdatedCaches=async(currentPrecacheName,substringToFind=SUBSTRING_TO_FIND)=>{const cacheNames=await caches.keys();const cacheNamesToDelete=cacheNames.filter(cacheName=>{return cacheName.includes(substringToFind)&&cacheName.includes(self.registration.scope)&&cacheName!==currentPrecacheName;});await Promise.all(cacheNamesToDelete.map(cacheName=>caches.delete(cacheName)));return cacheNamesToDelete;};const cleanupOutdatedCaches=()=>{addEventListener('activate',event=>{const cacheName=cacheNames_mjs.cacheNames.getPrecacheName();event.waitUntil(deleteOutdatedCaches(cacheName).then(cachesDeleted=>{{if(cachesDeleted.length>0){logger_mjs.logger.log(`The following out-of-date precaches were cleaned up `+`automatically:`,cachesDeleted);}}}));});};const getCacheKeyForURL$1=url=>{const precacheController=getOrCreatePrecacheController();return precacheController.getCacheKeyForURL(url);};const installListener=event=>{const precacheController=getOrCreatePrecacheController();const plugins=precachePlugins.get();event.waitUntil(precacheController.install({event,plugins}).catch(error=>{{logger_mjs.logger.error(`Service worker installation failed. It will `+`be retried automatically during the next navigation.`);}
throw error;}));};const activateListener=event=>{const precacheController=getOrCreatePrecacheController();const plugins=precachePlugins.get();event.waitUntil(precacheController.activate({event,plugins}));};const precache=entries=>{const precacheController=getOrCreatePrecacheController();precacheController.addToCacheList(entries);if(entries.length>0){addEventListener('install',installListener);addEventListener('activate',activateListener);}};const precacheAndRoute=(entries,options)=>{precache(entries);addRoute(options);};{assert_mjs.assert.isSWEnv('workbox-precaching');}
exports.addPlugins=addPlugins;exports.addRoute=addRoute;exports.cleanupOutdatedCaches=cleanupOutdatedCaches;exports.getCacheKeyForURL=getCacheKeyForURL$1;exports.precache=precache;exports.precacheAndRoute=precacheAndRoute;exports.PrecacheController=PrecacheController;return exports;}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private));