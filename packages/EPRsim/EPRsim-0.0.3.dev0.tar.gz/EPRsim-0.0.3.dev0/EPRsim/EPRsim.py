#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Module for the simulating EPR simulations in dynamical regimes.
EPR spectra can be simulated in the isotropic limit, fast-motion regime, and
slow-motion regime.

Copyright, Stephan Rein, 2019
"""

# Load all external libraries
import numpy as np
import time as time
from copy import copy
import EPRsim.Validate_input_parameter as Val
import EPRsim.Nucdic as Nucdic
import EPRsim.Tools as tool
import EPRsim.FastMotion as FM
import EPRsim.SolidState as SO
# Load physical constans
con = tool.physical_constants()

# *****************************************************************************
# Function for the calcualtion of spectra in the isotropic/fast motion regime
# *****************************************************************************


def simulate(Parameters):
    """
    EPRsim.EPRsim.simulate()
    ========================

    Simulation function for cw-EPR simulations.


    Parameters
    ----------
    Parameters : :class:`object`
                Object with all simulation parameters.



    Returns
    -------
    field : :class:`numpy.ndarray`
            Magnetic field vector.

    spectrum : :class:`numpy.ndarray`
              Intesity vector of the cw-EPR signal.

    flag : :class:`list`
           Flags with warning codes (description pleas find below)


    See Also
    --------
    Parameters : Class of Parameters (with a full list of parameters)

    Notes
    -------
    Main function for the simulation of cw-EPR in different motional regimes
    (isotropic, fast-motion and solid state)
    All spectra are simulated as field sweep spectra.

    Isotropic/fast-motion
    For the fast-motion regime/isotropic limit, the program solves
    the implicit Breit-Rabi formula [1] in a fixed-point iteration.
    Anisotropic line-broadening effects in the fast-motion regime
    are calculated via the Kivelson formula [2].
    Currently, Euler angles between tensors are ignored by the algorithm!
    All tensors (only relevant for fast-motion) need to be in its principal
    axis system and colinear to each other.

    Solid-state
    In the solid-state regime, the program uses a full matrix diagonalization
    algorithm. Therefore, only spin systems with a Hilbert space
    dimension of dim(H) < 512 can be calculated.
    The powder average is partially generated by interpolation
    of eigenvalues and transition probabilitites (similar to [1]).
    The interpolation level is automatically set by the program.
    The solid state algorithm treats arbitrary spin systems as long
    as the Hilbert space dimension is within the threshold.
    Spin-polarization can be defined (withing the electronic sublevels)
    as zero-field populations. Per default, the program calculates
    with thermal equilibrium. Nuclear quadrupolar couplings (for I > 0.5)
    are currently not implemented,

    The warning codes are:

        0: Everything is alright

        1: Solid-state is not possible due to too large matrix dimension.

        2: Fast-motion/iso is not possible due to :math:`S > 1/2`.


    Optional Parameters (with their defaults):

        mwFreq:
        Range:
        g:
        gFrame:
        A:
        AFrame:
        D:
        DFrame:
        n:
        motion:        'solid'
        Temperature:
        Interpolative_Refinement:
        Population:



    References
    ----------
    [1] : S. Stoll, A. Schweiger, J. Magn. Reson., 2006, 178, 42-55

    [2] : N. M. Atherton, Principles of Electron Spin Resonance, 1993

    Examples
    --------

    Simple example for the simulation of an isotropic nitroxide spectrum.

    >>> import EPRsim.EPRsim as sim
    >>> P = sim.Parameters()
    >>> P.Range = [335 ,350]
    >>> P.mwFreq = 9.6
    >>> P.g = 2.002
    >>> P.A = 45.5
    >>> P.Nucs = 'N'
    >>> P.lw = [0.2, 0.2]
    >>> P.motion = 'fast'
    >>> B0, spc, flag = sim.simulate(P)


    Simple example for the simulation of an anisotropic nitroxide spectrum
    (only 14N) in the fast-motion regime. The program makes a reasonable
    decision on its own if no motional regime is defined.

    >>> import EPRsim.EPRsim as sim
    >>> Ra = [335 ,350]
    >>> freq = 9.6
    >>> g = [2.0083, 2.0061, 2.0022]
    >>> A = [12, 13, 110]
    >>> Nucs = '14N'
    >>> lw = [0.2, 0.2]
    >>> tcorr = 1e-10
    >>> motion = 'fast'
    >>> Param = sim.Parameters(Range=Ra, g=g, A=A, Nucs=Nucs, mwFreq=freq,
                               lw=lw, tcorr=corr, motion=motion)
    >>> B0, spc, flag = sim.simulate(Param)


    Simple example for the simulation of an anisotropic nitroxide spectrum
    (only 14N) in the slow-motion regime. The plot is shown as well using
    the plot function of the cwEPRsim.Tools submodule.

    >>> import EPRsim.EPRsim as sim
    >>> import EPRsim.Tools as tool
    >>> P = sim.Parameters()
    >>> P.Range = [335 ,350]
    >>> P.mwfreq = 9.6
    >>> P.g = [2.0083, 2.0061, 2.0022]
    >>> P.A = [12, 13, 110]
    >>> P.Nucs = '14N'
    >>> P.lw = [0.2, 0.2]
    >>> P.tcorr = 3e-9
    >>> P.motion = 'fast'
    >>> B0, spc, flag = sim.simulate(P)
    >>> tool.plot(B0, spc)
    """
    st = time.time()
    Params = []
    Par = copy(Parameters)
    Par = check_if_instance(Par)
    warning = 0
    spectrum = 0
    if not isinstance(Par, (list, tuple)):
        Par = [Par]
    systems = len(Par)
    for i in range(0, systems):
        Par[i] = check_if_instance(Par[i])
    for i in range(0, systems):
        Par[i] = check_if_instance(Par[i])
        Val = Validate_Parameters(Par[i])
        Params.append(Val)

    for i in range(0, systems):
        spectrum_tmp = 0
        Param = Params[i]
        for k in range(0, len(Param.Sim_objects)):
            SimPar = Param.Sim_objects[k]
            if SimPar.motion == 'fast':
                Bfield, Int, warning = FM.fast_motion_kernel(Par[i], SimPar)
            else:
                Bfield, Int, warning = SO.solid_state_kernel(Par[i], SimPar)
            if warning == 1:
                spectrum = Int
                break
            if warning == 2:
                print("\nWARNING: Electron spin was reduced to S = 1/2!")
            spectrum_tmp += SimPar._w[k]*Int
        weight = get_weighting_factor(Par[i])
        spectrum_tmp = tool.normalize2area(spectrum_tmp, Par[i].Harmonic)
        spectrum += weight*spectrum_tmp
        spectrum = tool.modulation_amplitude(Par[i].ModAmp, Bfield, spectrum)
        if Par[i].SNR is not None:
            spectrum = tool.add_noise(spectrum, Par[i].SNR)
        if Par[i].mwPhase != 0:
            spectrum = tool.phase_offset(Par[i].mwPhase, spectrum)
    if Par[0].verbosity:
        eltime = time.time()-st
        print("\nTotal time: "+str(round(eltime, 6))+" s\n")

    return Bfield, spectrum, warning


# *****************************************************************************
# Definition of the hyperfine couplings due to different isotopes
# *****************************************************************************


def redefine_nuclear_coupling(Param):
    """redefine_nuclear_coupling(Sys)

    in:  Sys             (one class with definitions of spin system parameters)

    Very important function! Redefines the spin system for the hyperfine
    coupling according to the superimposed requirements. The definitions are
    necessarily different for the fast-motion and isotropic regime if a number
    of equivalent nuclei is passed. Additionally pure isotopes can be evaluated
    directly, while isotope mixtures requires an expansion also in the
    isotropic regime. This function depends on multiple subfunctions. The
    general workflow is:

        1. Get the hyperfines and Nucs definition from the Sys class
        2. Check if equivalent nuclei are defined in the fast motion regime
        3. If 2 is true: Get an expansion with all combination of isotopes
        4. Check if equivalent nuclei are defined with nonpure isotopes
        5. If 4 is True: Do the same as in 2 and 3 for fast motion.
        6. Remove all isotopes mixture below a given probability threshold
        7. Remove uncessary permutation of isotopes within a equivalent group

    Caution: Works directly on the Sys class member variables due to call by
    reference!
    All mentioned steps are only relevant if a number of equivalent coupling
    nuclei is given!
    """
    if Param.Nucs is None:
        return
    Force_expansion = False
    check_eq_in_fast_motion(Param)
    get_isotope_combinations(Param)
    if len(Param._Nucsvec) > 1 and Param.n is not None:
        Force_expansion = True
        check_eq_in_fast_motion(Param, Force_expansion)
        get_isotope_combinations(Param)
    remove_sub_threshold(Param, Param._Nucsvec, Param._w)
    remove_permutations(Param, Param._Nucsvec, Param._w, Force_expansion)
    return


def get_isotope_combinations(Param):
    """get_abundance_combinations(Sys)

    in:  Sys             (one class with definitions of spin system parameters)

    out: nuc_vec         (vector with nuclear strings of all isotopes comb.)
         weight          (vector with corresponding weighting factors)

    Takes the information of the user-defined spin system (Sys) and
    returns a vector of strings with all permuation and combination of
    isotopes (nuclei_string) and the weighting factor for the probability
    of the isotopes combinations (weight).
    """
    if Param.Nucs is None:
        return
    Nucs = Param.Nucs
    Nuc = Param.Nucs.split(',')
    try:
        hyperfine_dim = len(Nuc)
    except:
        hyperfine_dim = 1
        Nuc = [Nucs]
    Indexvectors, NucIsotopes = get_indexvector_isotopes(Nuc, hyperfine_dim)
    Indexvecfull = coupled_isotopes_indexvector(Indexvectors)
    nuc_vec, weight = create_nucvec(Indexvecfull, NucIsotopes)
    Param._Nucsvec = nuc_vec
    Param._w = weight
    return


def check_eq_in_fast_motion(Param, Force=False):
    """check_equiv_and_fast_motion(Sys)

    in: Sys              (one class with definitions of spin system parameters)
        Force=False      (Force the vector expansion without further cond.)

    Caution: Works directly on the passed variables due to call by reference.
    Equivalent nuclei has to treated separetely in the fast motion regime.
    Therefore if an input is given as Sys.n = [2,2], Sys.Nucs = "N,H" and
    Sys.A = [[10,20,30],[2,5,8]] this function transforms the input into:

       Sys.Nucs = "N,N,H,H"
       Sys.A = [[10,20,30],[10,20,30],[2,5,8],[2,5,8]]
       Sys.n = None

    This is the general input for the fully system without treating nuclear
    spins as equivalent. The function is not used in the isotropic limit.
    If Force is set to True the expansion is carried out independent of the
    requirement of a fast motion calculation.
    """
    if Param.Nucs is None:
        return
    if Param.n is None:
        return
    if (Param.tcorr is not None or Param.logtcorr is not None or Force or
       Param.motion == 'solid'):
        Nucs = Param.Nucs
        Nuc = Nucs.split(',')
        if isinstance(Param.n, int):
            if Param.n == 1:
                Param.n = None
                return
            neqvec = 1
            eqiuvec = [Param.n]
            Param.A = [Param.A]
        else:
            neqvec = len(Param.n)
            eqiuvec = Param.n
            if len(Param.n) == 1:
                if Param.n[0] == 1:
                    delattr(Param, "n")
                Param.A = [Param.A]
        new_A_tensors, expanded_Nucsvec = new_Nucsvec_and_tensors(eqiuvec, Nuc,
                                                                  Param.A,
                                                                  neqvec)

        Param._m = Param.n
        Param.n = 1
        Param.A = new_A_tensors
        Param._equiv = np.ones(new_A_tensors.shape[0])
        Param.Nucs = expanded_Nucsvec
    return


def new_Nucsvec_and_tensors(eqiuvec, Nuc, A, neqvec):
    """new_Nucsvec_and_tensors(eqiuvec,Nuc,A,neqvec)

    in:  eqiuvec:                       (n-vector [n1, n2, ...])
         Nuc:                           (string with couling nuclei)
         A:                             (hyperfine-tensors)
         neqvec:                        (lenght of the n-vector)

    out: new_A_tensors                  (new composed hyperfine tensors)
         expanded_Nucsvec               (new (full) string with couling nuclei)

    Subfunction of check_equiv_and_fast_motion(). Creates the new
    hyperfine tensors and nuclear string. For detailed description see
    check_equiv_and_fast_motion().
    """
    expanded__Nucsvec = ""
    for i in range(0, neqvec):
        expanded__Nucsvec += eqiuvec[i]*(Nuc[i]+",")
        A_tmp = np.tile(A[i], (eqiuvec[i], 1))
        if i == 0:
            new_A_tensors = A_tmp
        else:
            new_A_tensors = np.concatenate((new_A_tensors, A_tmp), axis=0)
    expanded__Nucsvec = expanded__Nucsvec[:-1]
    return new_A_tensors, expanded__Nucsvec


def coupled_isotopes_indexvector(Indexvec):
    """coupled_isotopes_indexvector(Indexvec)

    in:   Indexvec   (vectors with indices according to the number of isotopes)

    out: Indecvec    (coupled index vector)

    Takes the index vector of a single element (eg. N) and creates the
    coupled vector using tensor products.
    If the Sys.Nucs input is "N,H" the corresponding input Indexvector
    (generated by the function get_indexvector_isotopes()) is:

        [0,1],[0,1]

    The returned index vectors after applying a sequence of tensor products is:

        [0,0,1,1],[0,1,0,1]

    This coupled index vectors are returned. This index vectors are the basis
    to set up nuclear spin systems with all combinations of isotopes.
    """
    dim = []
    dimen = len(Indexvec)
    for i in range(0, dimen):
        dim.append(len(Indexvec[i]))
    for i in range(0, dimen):
        for k in range(0, dimen):
            if k != i:
                if i <= k:
                    Indexvec[i] = np.kron(Indexvec[i], np.ones(dim[k]))
                else:
                    Indexvec[i] = np.kron(np.ones(dim[k]), Indexvec[i])
    return Indexvec


def create_nucvec(Ind, NucIso):
    """create_nucvec(Ind,NucIso)

    in:  Ind                      (indexvectors for each nuclei)
         NucIso                   (vector of isotopes for the nuclei)

    out: Sys_String               (vector with all isotopes combinations)
         Sys_isotope_weight       (vector with corresponding weighting factors)

    Takes the index vectors from the tensor products (Ind) and
    the corresponding vectors with the nuclear isotopes and creates
    a mixture of all possible isotopes combinations.
    If eg. "N,H" is passed for Sys.Nucs  than the index vectors (Ind) created
    by the functions get_indexvector_isotopes() and
    coupled_isotopes_indexvector() are:

        [0,0,1,1],[0,1,0,1H]

    with the NucIso vectors:

        ["14N","15N"],["1H',"2H"]

    This functions now creates  vectors (Sys_String) with all possinle isotopes
    combinations:

        ["14N,1H"],["14N,2H"],["15N,1H"],["15N,2H"]

    and the corresponding probabilities of the isotope mixtures
    (Sys_isotope_weight):

        [0.9962104048, 0.0001095952, 0.0036795952, 4.048e-07]

    Less suprisingly is the isotope mixture with 14N and 1H by far the most
    probable due to their natural abundance.
    """
    weight = 1
    strings = []
    tmp_key = []
    tmp_val = []
    for i in range(0, len(Ind)):
        string = []
        Ind_tmp = Ind[i]
        NucIso_tmp = NucIso[i]
        for k in range(0, len(Ind_tmp)):
            string.append(NucIso_tmp[int(Ind_tmp[k])])
        strings.append(string)
    for k in range(0, len(NucIso)):
        NucIso_tmp = NucIso[k]
        for i in range(0, len(NucIso_tmp)):
            Ind_tmp = NucIso_tmp[i]
            Info = Nucdic.nuclear_properties(Ind_tmp)
            tmp_key.append(Ind_tmp)
            tmp_val.append(Info[2])
    tmp_dictionary = dict(zip(tmp_key, tmp_val))
    Sys_String = []
    Sys_isotope_weight = []
    s = 0
    for i in range(0, len(strings[0])):
        strings_tmp = ""
        weight = 1.0
        for k in range(0, len(strings)):
            s += 1
            if k == 0:
                strings_tmp += str(strings[k][i])
            else:
                strings_tmp += ","+str(strings[k][i])
            if max(Ind[k][:]) == 0:
                pass
            else:
                weight_info = tmp_dictionary[strings[k][i]]
                weight *= weight_info
        Sys_String.append(strings_tmp)
        Sys_isotope_weight.append(weight)
    return Sys_String, Sys_isotope_weight


def get_indexvector_isotopes(Nuc, hyperfine_dim):
    """get_indexvector_isotopes(Nuc,hyperfine_dim)

    in:  Nuc                             (String with couling nuclei)
         hyperfine_dim                   (number of treated nuclei)

    out: Indexvectors                    (indexvectors for each nuclei)
         NucIsotopes                     (vector with isotopes for each nuclei)

    The function takes the input for a given Sys.Nucs string and a number
    of couling nuclei and creates an indexvector for each nuclei. This
    index vector runs from 0 to N-1, where N is the number of isotopes for
    a nuclei. If for example the nuclei is a "H" (hydrogen) or a
    "Mg" (magnesium) the indexvector is:

        Indexvector["H"] = [0,1]
        Indexvector["Mg"] = [0,1,2]

    This is because "H" has two stable isotopes and "Mg" has three stable
    isotopes.
    The function also produces a vector where the isotopes (NucIsotopes) for
    each nuclei are listed as strings. For a "Mg" or a "H" the NucIsotope
    vector is:

        NucIsotopes["H"] = ["1H","2H"]
        NucIsotopes["Mg"] = ["24Mg","25Mg","26Mg"]

    The Indexvectors (vector of indexvectors) as well as the NucIsotopes
    (vector of NucIsotopes) are returned.
    """
    NucIsotopes = []
    Indexvectors = []
    for i in range(0, hyperfine_dim):
        Iso = Nucdic.isotopes_catalogue(Nuc[i])
        NucIsotopes.append(Iso)
        Indexvector = np.linspace(0, len(Iso)-1, len(Iso), dtype=np.int32)
        Indexvectors.append(Indexvector)
    return Indexvectors, NucIsotopes


def remove_sub_threshold(Param, Sys__Nucsvec, w):
    """ remove_sub_threshold(Sys__Nucsvec,w)

    in:  Sys__Nucsvec          (vector with all isotope combinations)
         w                    (vector with the corresponding weighting factors)

    Caution: Works directly on the passed variables due to call by reference.
    Deletes all isotopes combinations with a combined probability below the
    defined threshold. The threshold is defined as global variable at the top
    of this file and is called abund_threshold.
    """
    s = len(Sys__Nucsvec)-1
    for s in range(s, -1, -1):
        if w[s] < Param.abund_threshold:
            del Sys__Nucsvec[s]
            del w[s]
    return


def read_single_isotope_comb(Param, _Nucsvec):
    if Param._nofA is None:
        return
    if Param._nofA  > 1:
        try:
            Nuc = _Nucsvec.split(',')
        except:
            Nuc = [_Nucsvec]
    else:
        Nuc = [_Nucsvec]
    Param._I = []
    Param._mI = []
    Param._g_n = []
    Param._Iequiv = []
    for i in range(0, len(Nuc)):
        if _Nucsvec is None:
            continue
        Nucinfo = Nucdic.nuclear_properties(Nuc[i])
        N = Nucinfo[1]
        gyro = 1*Nucinfo[0]
        Param._g_n.append(tool.gyro2gn(gyro))
        Ispin = (N-1)/2
        Param._I.append(Ispin)
        Param._Iequiv.append(Ispin*Param._equiv[i])
        Param._mI.append(np.linspace(-Ispin, Ispin, N))
    return


def remove_permutations(Par, _Nucsvec, w, Force=False):
    """remove_double_combinations(Sys,Sys__Nucsvec,w,Force =False)

    in:  Sys             (one class with definitions of spin system parameters)
         Sys__Nucsvec     (vector with all combinations of isotopes)
         w               (corresponding weighting factors)
         Force=False    (forces the operations independent of the conditions)

    Caution: Works directly on the passed variables due to call by reference.
    Removes permutations which are doubled. Assume a spin system with
    n = [2,2], Nucs = "N,H" is transformed in the fast-motion regime to a
    system "N,N,H,H". There requirement is still that the coupling is
    to equivalent nuclei (in general the A-tensor is identical within the
    H's and N's). The isotopes combiniations above the probability threshhold
    will be:

        1. "14N,14N,1H,1H"
        2. "14N,15N,1H,1H"
        3. "15N,14N,1H,1H"
        4. "14N,14N,2H,1H"
        5. "14N,14N,1H,2H"

    Since 2. and 3. (and 4 and 5) are indentical (just a perumation of a
    isotope within the equivalent coupling nuclei group) one of them can be
    removed and the other douled in weight. Leaving:

        1. "14N,14N,1H,1H"
        2. "14N,15N,1H,1H"    weight*2
        3. "14N,14N,1H,2H"    weight*2

    This was a description using an example of the very general procedure
    implemented in this function. The new reduced list of isotope combinations
    as well as the new weighting factors are produced (call by reference).
    """
    if (Force or Par.tcorr is not None) and Par._m is not None:
        s = len(_Nucsvec)-1
        if isinstance(Par._m, int):
            Par._m = [Par._m]
        for s in range(s, -1, -1):
            str_tmp1 = _Nucsvec[s].split(",")
            for k in range(0, s):
                str_tmp2 = _Nucsvec[k].split(",")
                q = 0
                str1 = []
                str2 = []
                issame = True
                for t in range(0, len(Par._m)):
                    str1.append(str_tmp1[q:q+Par._m[t]])
                    str2.append(str_tmp2[q:q+Par._m[t]])
                    if sorted(str1[t]) != sorted(str2[t]):
                        issame = False
                    q += Par._m[t]
                if issame:
                    del _Nucsvec[s]
                    w[k] += w[s]
                    del w[s]
                    break
    return


# *****************************************************************************
# Other functionalities and flags and erromessages
# *****************************************************************************


def check_if_instance(Sys):
    try:
        x = Sys()
        if isinstance(x, Sys):
            Sys = Sys()
        return Sys
    except:
        return Sys


def get_weighting_factor(Sys):
    if hasattr(Sys, "weight"):
        weight = Sys.weight
    else:
        weight = 1.0
    return weight


def warningflag(n=0):
    if n == 0:
        w0str = ("\nTreating equivalent nuclei for isotopes mixtures" +
                 " might be very slow!\n")
        print(w0str)
    return

# *****************************************************************************
# PUBLIC CLASSES
# *****************************************************************************


class Parameters(object):
    """
    Constructs an instance of a class with experimental parameters

    Parameters
    ----------
    Range :    :class:`list`
               Magnetic field range in mT.

    mwFreq :   :class:`float`
               Microwave frequency in MHz.

    A :        :class:`float` or :class:`list`
               g value or tensor. A single value corresponds to
               an isotropic g-value. A list with two elements to an axial
               symmetricg-tensor where the first element is
               associated with the perpendicular component and the second
               element with the parallel componen, respectively.
               Three elements correspond to the prinicipal axis value of
               a rhombic g-tensor.

    A :        :class:`float`, :class:`list` or :class:`list` of :class:`list`
               Hyperfine value or tensor. A single value corresponds to
               an isotropic value. A list with two elements to an axial
               symmetric hyperfine tensor where the first element is
               associated with the perpendicular component and the second
               element with the parallel componen, respectively.
               Three elements correspond to the prinicipal axis value of
               a rhombic hyperfine tensor. For multiple nuclei each list
               is assigned to a hyperfine tensor ([[A1], [A2], ....])

    Nucs :     :class:`string`
               Elements or specified nuclear isotopes. For more then one
               coupling nucleus, seperated by a comma (e.g., "14N,1H,13C").
               If all isotopes, according to their natural abundance should
               be taken into account only the element symbol should be given
               without the atomic number ("N,H,C"). Mixtures are also possible
               ("1H,N,13C").

    n :        :class:`int` or :class:`list` of :class:`int`
               Number of equivalent nuclei.

    mwfreq :   :class:`float`
               Microwave frequency in MHz.

    Harmonic : :class:`int`
               0 = absorptive, 1 = first derivative (default)

    mwPhase :  :class:`float`
               Microwave phase offset in radians.

    ModAmp :  :class:`float`
              Include effects of field modulation like overmodulation in mT.

    Points :  :class:`int`
              Number of field points. The default is 1024.

    tcorr :   :class:`float` or :class:`list` of floats.
              Rotational correlation time in ns. For axial symmetric
              rotational diffusion use a list with two elements, where the
              first element is the perpendicular rotational correlation time
              and the second element is the parallel rotational correlation
              time of the rotation diffusion operator.

    logtcorr : :class:`float`
               Decadic logarithm of the rotational correlation time

    weight :  :class:`float`
              Weighting factor if multiple spin species are combined in a
              linear combination

    abund_threshold : :class:`float`
                      Threshold level for prunning isotope mixtures with
                      a small (combined) natural abundance.

    motion :  :class:`string`
              Fast-motion: 'fast', slow-motion 'slow'. If not given, the
              program evaluates which motional regime is preferable.

    Solver :  :class:`string`, (only relevant in slow-motion)
              SLE Solver: 'CG' for conjugated gradients, "Lanczos" for Lanczos.
              The Lanczos algorithm is used as a default to solve the
              stochastic Liouville equation.

    LMKmax :  :class:`list` of :class:`int`, (only relevant in slow-motion)
              Maxmimum rank of L, M and K for the spatial basis.
              The slow-motion algorithm takes a default basis if LMKmax
              is not provided.

    SNR :     :class:`float`
              Singal-to-noise ratio for addition of artificial white noise.
              The default value is None (noise-free).

    Returns
    -------
    Parameters :   :class:`object`
                Contains attributes according to keyword arguments or the
                attributes have their default values.



    See Also
    --------
    simulate :  Function which uses the Parameters object for simulation.

    Validate_Parameters : A class which validates a object of class Parameters.

    Notes
    -------
    This class is needed to create in instance of the class
    Parameter. This instance is provided to the simulation function
    simulate().

    Two different approaches can be applied to full the instance
    of a Parameter class with attributes.
    The Parameter class has the member function attributes() which prints
    all attributes with their assigned values of the instance.

    Examples
    --------

    Set the Parameters attributes using an instance with default settings..

    >>> import cwEPRsim.EPRsim as sim
    >>> Param = sim.Parameters()
    >>> Param.Range = [335 ,350]
    >>> Param.mwfreq = 9.6
    >>> Param.Harmonic = 1


    Set the Parameters attributes by keyword arguments:

    >>> import cwEPRsim.EPRsim as sim
    >>> R = [335 ,350]
    >>> mwFreq = 9.6
    >>> Har = 1
    >>> Param = sim.Parameters(Harmonic=H, mwFreq=mwfreq, Range=R)

    Set part of theParameters attributes by keyword arguments and others
    after initializing the object.

    >>> import cwEPRsim.EPRsim as sim
    >>> R = [335 ,350]
    >>> Pa = sim.Parameters(Range=R)
    >>> Pa.mwfreq = 9.6


    Advanced example for a slow-motion simulation of a fully axial system
    (maximal K-rank is set to zero):

    >>> import cwEPRsim.EPRsim as sim
    >>> Pa = sim.Parameters()
    >>> Pa.Range = [335 ,350]
    >>> Pa.g = [2, 2.05]
    >>> Pa.Nucs = "14N"
    >>> Pa.A = [12, 110]
    >>> Pa.mwfreq = 9.6
    >>> Pa.LMKmax = [18, 2, 0]
    >>> Pa.mwPhase = 0.1
    >>> Pa.Solver = 'CG'

    A alphabetically ordered list of default parameters, or user-defined
    parameters, can be easily generated:

    >>> import cwEPRsim.EPRsim as sim
    >>> Pa = sim.Parameters()
    >>> Pa.attributes()
    A: None
    abund_threshold: 0.0001
    g: 2.0023193
    Harmonic: 1
    LMKmax: [14, 2, 6]
    logtcorr: None
    lw: [0.1, 0.1]
    ModAmp: 0
    motion: unknown
    mwFreq: 9.6
    mwPhase: 0
    n: 1
    Nucs: None
    Points: 1024
    Range: [330, 360]
    S: 0.5
    SNR: None
    Solver: Lanczos
    tcorr: None
    verbosity: True
    weight: 1
    """
    def __init__(self, **kwargs):
        self.Range = [330, 360]
        self.mwFreq = 9.6
        self.S = 0.5
        self.g = con.g_free
        self.A = None
        self.Nucs = None
        self.motion = 'solid'
        self.Harmonic = 1
        self.mwPhase = 0
        self.ModAmp = 0
        self.lw = [0.1, 0.1]
        self.Points = 1024
        self.tcorr = None
        self.logtcorr = None
        self.weight = 1
        self.verbosity = True
        self.n = 1
        self.abund_threshold = 1e-4
        self.SNR = None
        self._warningflag = 0
        self._tcorriso = None
        self._I = [0]
        self._Iequiv = [0]
        self._mI = [0]
        self._g_n = [0]
        self._nA = 0
        self._equiv = np.ones(1)
        self._Nucsvec = [None]
        self._w = [1]
        self._nofA = None
        self._m = None
        # Solid state parameter
        self.nKnots = 12
        self.n_explicit = 3
        self.Singlet = False
        self.Triplet = False
        self.field_warning = False
        self.D = None
        self.DPair = None
        self.J = None
        self.DirektConv = True
        for key, value in kwargs.items():
            setattr(self, key, value)

    def attributes(self):
        """
        Prints all attributes with assigned values
        """
        sortedkeys = sorted(self.__dict__, key=str.lower)
        for keys in sortedkeys:
            if not keys.startswith("_"):
                print(keys + ": " + str(self.__dict__[keys]))


class Validate_Parameters:
    """
    Gets simulation information from a object of class Parameters

    Parameters
    ----------
    Parameters : :class:`object`
                 Object of the class Parameters.


    Returns
    -------
    Ob :        :class:`object`
                Object of the class Validate_Parameter



    See Also
    --------
    getInfo :  Get information about a forthcoming simulation of a defined
               Parameter object.

    Notes
    -------

    Evaluates a object of the class Parameters. This function is used
    in the simulation framework to redefine parameters and is therefore
    a internal class of cwEPRsim.
    However, an object of  Validate_Parameters can be used to get information
    about a potential simulation before such is carried out.
    For this the member function getInfo() can be used. All other member
    functions are private functions.
    """
    def __init__(self, Parameters):
        self.Sim_objects = []
        Param = copy(Parameters)
        self._run_validation(Param)

    def _run_validation(self, Parameters):
        Parameters = check_if_instance(Parameters)
        Val.validate_spin_system(Parameters)
        redefine_nuclear_coupling(Parameters)
        Val._redefine_tcorr(Parameters)
        for k in range(len(Parameters._Nucsvec)):
            Parameters.Nucs = Parameters._Nucsvec[k]
            read_single_isotope_comb(Parameters, Parameters.Nucs)
            self.Sim_objects.append(Simulation_Params(Parameters, k))

    def getInfo(self):
        """
        Gets information about the potential simulation of a set of parameters

        Notes
        -------

        Prints valuable information about the potential simulation for
        a the set of parameters used to construct the object of the
        Validate_Parameters class.
        """
        num = len(self.Sim_objects)
        print("\n********Pre-simulation information********")
        print("Number of explicitly treated isotope combinations: " + str(num))
        for i in range(0, num):
            obj = self.Sim_objects[i]
            print("\nNumber: " + str(i+1))
            print("Treated nuclear spins: " + str(obj._Nucsvec))
            print("Nuclear spin quantum number:" + str(obj._I))
            print("Equivalent nuclear spins: " + str(obj._equiv))
            print("Isotope mixture weight: "+str(obj._w[i]))
            print("\n")
        print("\n")


class Simulation_Params:
    def __init__(self, Par, k):
        self._Nucsvec = Par._Nucsvec[k]
        self._equiv = Par._equiv
        self._nofA = Par._nofA
        self.A = Par.A
        self.g = Par.g
        self.iso = Par.iso
        self._I = Par._I
        self._w = Par._w
        self._mI = Par._mI
        self._g_n = Par._g_n
        self._tcorriso = Par._tcorriso
        self._Iequiv = Par._Iequiv
        self._warningflag = Par._warningflag
        self.motion = Par.motion
        self.Bfield = Par.Bfield
        self.FreqTofield = 1
        self.FieldtoFreq = 1
        self.Pplus = None
        self.SNR = Par.SNR
        self.motion = Par.motion
        self.mwFreq = Par.mwFreq
        self.lw = Par.lw
        self.tcorr = Par.tcorr
