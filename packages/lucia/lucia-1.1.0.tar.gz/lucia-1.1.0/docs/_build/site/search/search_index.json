{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"lucia INSTALLATION | DOCUMENTATION | LICENSE An audio game engine written in python Goals: The goal of lucia is to change the audio game creation method from the now old and no longer maintained bgt, to python. Lucia should not act as a starting game, but as a base, that a high quality game can be build upon. In addition lucia should be cross platform, At Least on windows and mac. Code / dependencies that doesn't meet these requirements cannot be a part of lucia. Installation There's the to default ways to install lucia. Through pip pip install lucia Or the manual way git clone https://github.com/LuciaSoftware/lucia.git cd lucia python setup.py install Building / Running: Running tests: To run the tests run the following command: python setup.py test Generating documentation: To generate Lucia's documentation, you first need to install pydoc-markdown pip install pydoc-markdown after go into the \"docs\" folder: cd docs And run: pydocmd build Alternatively, you can also view a local demo of the docs by executing the following command: pydocmd serve Contributing Everyone is welcome to help improve Lucia. start here License: Copyright (C) 2019 LuciaSoftware and it's contributors. This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, version 3 of the License. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this program. If not, see https://github.com/LuciaSoftware/lucia/blob/master/LICENSE.","title":"Home"},{"location":"#lucia","text":"","title":"lucia"},{"location":"#installation-documentation-license","text":"","title":"INSTALLATION | DOCUMENTATION | LICENSE"},{"location":"#an-audio-game-engine-written-in-python","text":"","title":"An audio game engine written in python"},{"location":"#goals","text":"The goal of lucia is to change the audio game creation method from the now old and no longer maintained bgt, to python. Lucia should not act as a starting game, but as a base, that a high quality game can be build upon. In addition lucia should be cross platform, At Least on windows and mac. Code / dependencies that doesn't meet these requirements cannot be a part of lucia.","title":"Goals:"},{"location":"#installation","text":"There's the to default ways to install lucia. Through pip pip install lucia Or the manual way git clone https://github.com/LuciaSoftware/lucia.git cd lucia python setup.py install","title":"Installation"},{"location":"#building-running","text":"","title":"Building / Running:"},{"location":"#running-tests","text":"To run the tests run the following command: python setup.py test","title":"Running tests:"},{"location":"#generating-documentation","text":"To generate Lucia's documentation, you first need to install pydoc-markdown pip install pydoc-markdown after go into the \"docs\" folder: cd docs And run: pydocmd build Alternatively, you can also view a local demo of the docs by executing the following command: pydocmd serve","title":"Generating documentation:"},{"location":"#contributing","text":"Everyone is welcome to help improve Lucia. start here","title":"Contributing"},{"location":"#license","text":"Copyright (C) 2019 LuciaSoftware and it's contributors. This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, version 3 of the License. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this program. If not, see https://github.com/LuciaSoftware/lucia/blob/master/LICENSE.","title":"License:"},{"location":"cli/","text":"The cli utilities Lucia contains varius CLI utilities, that can aid you in creating games quicker. Below follows an explenation of the varius CLI utilities found in lucia. The CLI utilities are automatically installed along lucia, so no extra setup is required to use them. All of the CLI utilities can be localed in the \"lucia.cli\" package. Note: Many CLI utilities provides help by just typing their name without any arguments. The Packer Utility The packer util, located in \"lucia..cli.packer\" is an util that takes care of packing all your game resources into a compressed and encrypted pack file, that you will then be able to load with lucia in your game. Create a pack file: To use the packer util, do the following: Go into your resource folder (containing audio / map data or anything else really) cd resources/ invoke the packer. lucia.packer name key Where: name is the name of the pack file, fx: resources.dat key is the encryption key to use (you will need it later, when loading your packfile into Lucia). Load the created pack file into lucia: To load your created pack file into lucia, so you and the audio backends can use the data within it, can be done the following way: Note: This asumes that you have copied the newly created pack file from where you created it into the same folder, where your game source is located. # This should take place after lucia.initialize has been called. ress = lucia.ResourceFile(key=\"THE_ENCRYPTION_KEY_YOU_USED_BEFORe\") # this key needs to match the one you used before, or else the decryption will fail. ress.load(\"resources.dat\") # \"resources.dat\" is the name of your pack file, here we tell lucia, that it can be found in the same folder, and that it's called resources.dat. lucia.set_global_resources_file(ress) # This tells lucia to use the above resource file as the global resource file. What this does is, telling the audio backends to search for audio data in the above pack file before trying anything else. API Source: lucia.packfile","title":"cli"},{"location":"cli/#the-cli-utilities","text":"Lucia contains varius CLI utilities, that can aid you in creating games quicker. Below follows an explenation of the varius CLI utilities found in lucia. The CLI utilities are automatically installed along lucia, so no extra setup is required to use them. All of the CLI utilities can be localed in the \"lucia.cli\" package. Note: Many CLI utilities provides help by just typing their name without any arguments.","title":"The cli utilities"},{"location":"cli/#the-packer-utility","text":"The packer util, located in \"lucia..cli.packer\" is an util that takes care of packing all your game resources into a compressed and encrypted pack file, that you will then be able to load with lucia in your game.","title":"The Packer Utility"},{"location":"cli/#create-a-pack-file","text":"To use the packer util, do the following: Go into your resource folder (containing audio / map data or anything else really) cd resources/ invoke the packer. lucia.packer name key Where: name is the name of the pack file, fx: resources.dat key is the encryption key to use (you will need it later, when loading your packfile into Lucia).","title":"Create a pack file:"},{"location":"cli/#load-the-created-pack-file-into-lucia","text":"To load your created pack file into lucia, so you and the audio backends can use the data within it, can be done the following way: Note: This asumes that you have copied the newly created pack file from where you created it into the same folder, where your game source is located. # This should take place after lucia.initialize has been called. ress = lucia.ResourceFile(key=\"THE_ENCRYPTION_KEY_YOU_USED_BEFORe\") # this key needs to match the one you used before, or else the decryption will fail. ress.load(\"resources.dat\") # \"resources.dat\" is the name of your pack file, here we tell lucia, that it can be found in the same folder, and that it's called resources.dat. lucia.set_global_resources_file(ress) # This tells lucia to use the above resource file as the global resource file. What this does is, telling the audio backends to search for audio data in the above pack file before trying anything else.","title":"Load the created pack file into lucia:"},{"location":"cli/#api-source","text":"lucia.packfile","title":"API Source:"},{"location":"api/lucia/","text":"lucia The main Lucia module The functions here are responsible for initializing and quitting lucia, showing the game window, handle global events and so on. In addition, this part of lucia also contains most keyboard functions. AudioBackend AudioBackend(self, /, *args, **kwargs) BASS int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x. int (). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. int('0b100', base=0) 4 FMOD int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x. int (). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. int('0b100', base=0) 4 OPENAL int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x. int (). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. int('0b100', base=0) 4 initialize initialize(audiobackend=1) Initialize lucia and the underlying graphic, audio, keyboard, interface engines quit quit() Shutdown lucia and close underlying engines freeing up system resources show_window show_window(title='LuciaGame', size=(640, 480)) Shows the main game window on the screen, this is most likely called at the start of a game process_events process_events() This processes events for the window This should be called in any loop, to insure that the window and application stays responsive key_pressed key_pressed(key_code) Checks if a key was pressed down this frame (single key press) * key_code: A pygame.K_ key code returns: True if the specified key kode was pressed, False otherwise. key_released key_released(key_code) Checks if a key was released down this frame (single key release) * key_code: A pygame.K_ key code returns: True if the specified key kode was released, False otherwise. key_down key_down(key_code) Checks if a key is beeing held down. * key_code: A pygame.K_ key code returns: True if the specified key kode is beeing held down, False otherwise. key_up key_up(key_code) Check if a key isn't beeing held down (ie if it's not pressed and held) * key_code : A pygame.K_ key code returns: True if key is not held down, False otherwise lucia.data Provides functions for easily manipulating textual or binary data. Currently includes encryption and compression. unsupportedAlgorithm unsupportedAlgorithm(self, /, *args, **kwargs) raised when the user tries supplying an algorithm not specified in constants output An output which automatically selects the first available output on the system outputs Built-in mutable sequence. If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified. lucia.packfile Lucia's resource pack module This module will aid in the interaction with and creation of data files for storing game assets. A lucia resource file is a binary file format with the ability to have encryption and/or compression instituted on a per-file basis at creation time. Using the get method one may retrieve the contents of any file added to the pack, for example to be used in a memory load function of a sound system. InvalidPackHeader InvalidPackHeader(self, /, *args, **kwargs) raised when the packs header is invalid ResourceFileVersion ResourceFileVersion(self, /, *args, **kwargs) The version should only change if changes are introduced that breaks backwards compatibility v1 int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x. int (). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. int('0b100', base=0) 4 LoadPolicy LoadPolicy(self, /, *args, **kwargs) The load policy used when loading in data from a resource file LOAD_ALL loads everything into ram. LOAD_INDEX only load in the filenames and where they are located on disk. LOAD_ALL int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x. int (). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. int('0b100', base=0) 4 LOAD_INDEX int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x. int (). For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. int('0b100', base=0) 4 ResourceFileItem ResourceFileItem(self, name, content, compress, encrypt) Internal object representing an item in the pack. ResourceFile ResourceFile(self, key, header=b'LURF', version=1) The resource file object You will interact with resource files through methods provided by this object. This object may have any number of instances, however only one instance should interact with a given file on the file system at a time. load ResourceFile.load(self, filename, policy=1) Opens a resource file to be read. This file will be checked for validity based on matching header, version, and a non-0 number of files. If one of these conditions fails, InvalidPackHeader will be raised. Otherwise this object will be loaded with the contents. :param filename: The file name to be read from the file system. :param policy (optional): The load policy to use, defaults to LoadPolicy.LOAD_ALL save ResourceFile.save(self, filename) Saves data added to this object to a resource file. When creating a resource file, this is the final method you would call. args: :param filename: The file name on disk to write to. Will be overwritten if already exists. add_file ResourceFile.add_file(self, name, compress=True, encrypt=True, internalname=None) Adds a file on disk to the pack, optionally compressing and/or encrypting it. args: :param name: The file name to read from. :param compress (boolean, optional): Whether compression should be applied to this file. Defaults to True. :param encrypt (boolean, optional): Whether encryption should be applied to this file. Defaults to True. :param internalname (optional): Internal file name to be used inside the pack. If None, the default, internal name will be same as name on disk. get ResourceFile.get(self, name) [summary] Args: name ([str]): The key to lookup in the data file Returns: bytes or none: Returns the found result, or none if nothing with the specified key was found.","title":"lucia"},{"location":"api/lucia.ui/","text":"lucia.ui lucia.ui.menu Menu Menu(self, scroll_sound='', enter_sound='', open_sound='', border_sound='', music='') audiogame virtual menu This object functions as an audiogame menu, where up/down/enter can be used to interact and choose an option. Sounds such as the movement sound, selection sound, etc may be specified. This is an almost direct conversion of bgt's dynamic_menu class, though it contains some enhancements found in other extensions such as m_pro. args: scroll_sound (str, optional): File name of the sound that will be played when the cursor moves within the menu because an arrow key was pressed. enter_sound (str, optional): File name of the sound that will be played when enter is pressed to choose an option. open_sound (str, optional): File name of the sound that will be played when the menu is presented to the user. border_sound (str, optional): File name of the sound played when you hit the edge of the menu when trying to move. music (str, optional): File name of the background music that will be played while this menu is running. set_callback Menu.set_callback(self, callback) Sets the menus callback. The callback will be called every iteration of the loop. args: callback (obj): The method to use as callback. This method should be either a module or a class and provide the necessary output functions, see lucia.output for an example. raises: ValueError if callback is not callable add_speech_method Menu.add_speech_method(self, method, shouldInterrupt=True) selects the speech method and interrupt flag args: method (obj): The method to use. This method should be either a module or a class and provide the necessary output functions, see lucia.output for an example. shouldInterrupt (bool, optional): determines if this speech method should interrupt already existing speech when speaking something new. Default is True. add_item_tts Menu.add_item_tts(self, item, internal_name='') adds a spoken item to the menu. args: item (str): The text of the item to be added. This is the text you will here when you come across it in the menu. internal_name (str, optional): The internal name of this item. when you retrieve the selected item by name this will be returned. Defaults to the spoken text of the item. run Menu.run(self, intro='select an option', interrupt=True) presents this menu to the user. This function blocks until the menu is closed, either by selecting an item or pressing escape. Available controls are up/down arrows, enter, and escape. Wrapping is not supported. args: intro (str, optional): The text that will be spoken when the menu is presented, this will occur at the same time as the open sound. Default is 'select an option' interrupt (bool, optional): Determines if speech is interrupted when it is queued to be spoken. For your sanity, this should always be True. Defaults to True. returns: str if an option was selected, containing the option's internal name. -1 if escape was pressed. YesNoMenu YesNoMenu(*args) A yes/no menu This simply takes a menu and initializes it with options of Yes and No, you would then have to call run and get the return. The internal names of the items are lower case. args: args (tuple): Set of arguments to pass to Menu. init lucia.ui.menu2 advanced menu for advanced use this menu module provides highly flexible menu items with different events and an advanced menu handling Menu Menu(self, items, clicksound='', edgesound='', wrapsound='', entersound='', opensound='', itempos=0, title='menu', fpscap=120, on_index_change=None, callback_function=None) run Menu.run(self) when this function is called, menu loop starts. If the user make the menu return such as pressing enter on an item that has can_return attribute set to true the loop ends and it usually returns results as a list of dictionaries lucia.ui.virtualinput","title":"ui"},{"location":"api/lucia.utils/","text":"lucia.utils lucia.utils.instance_checker InstanceChecker InstanceChecker(self, f) An instance checker This is similar to bgt's instance object, to make sure a game can be running only once. args: f (str): The name to be registered as a mutex. is_running InstanceChecker.is_running(self) check if another instance is already running returns: True if this instance is already registered, false otherwise. lucia.utils.network number_to_words number_to_words(number, include_and=False) returns a string representation for the given number lucia.utils.rotation Rotation class This is modeled on the bgt rotation class from Sam Tupy. Input and output are in degrees. Vector Vector(self, x=0.0, y=0.0, z=0.0) an object representing what bgt calls a vector This represents a point in 3-space, where positive x is right, positive y is forward, and positive z is up. The property coords can be used to get and set a tuple of the coordinates represented by this vector with no rounding applied. args: x (float, optional): The starting x coordinate of this vector y (float, optional): The starting y coordinate of this vector z (float, optional): The starting z coordinate of this vector. move move(coords, deg, pitch=0.0, factor=1.0) moves a vector in a given direction by a scale factor of factor Takes a vector as input, applies the translation, and returns a vector as output. Probably best done as player.coords=move(player.coords,player.facing) or something similar. The scale factor is used if you wish to move more than 1 coordinate, otherwise you simply apply the unit circle. args: coords (tuple or list): The current point in 3-space you wish to move. deg (float): The current facing of an object pitch (float, optional): The vertical degrees you wish to move. Defaults to 0, no vertical movement. factor (float, optional): The scale factor you wish to move by. Passing 1 is equivalent to one unit move in any direction, but for warping in a particular direction you can pass a higher factor. Defaults to 1. returns: a transformed vector calculate_angle calculate_angle(x1, y1, x2, y2, deg) given two points, returns the angle of the second one relative to the first. This function is useful for reporting a direction of an object to a player, for example. In this example the 'origin' point would be the player and the 'distant' point would be the object the player is tracking. args: x1 (float): The x coordinate of the origin point. y1 (float): The y coordinate of the origin point. x2 (float): The x coordinate of the distant point y2 (float): The y coordinate of the distant point deg (float): The absolute direction the origin point is facing, for offsets. returns: an angle (in degrees) of the distant point relative to the origin point, shifted by the orientation of the origin. get_1d_distance get_1d_distance(x1, x2) returns the distance on a 1-dimensional plane from x1 to x2 get_2d_distance get_2d_distance(x1, y1, x2, y2) returns the pythagorean distance between two points on an x-y plane. get_3d_distance get_3d_distance(x1, y1, z1, x2, y2, z2) returns the pythagorean distance between two points in 3-space. lucia.utils.timer Timer Timer(self) A timer class, to track time mesured in millis elapsed Returns the exact elapsed time since this timer was created or last restarted. restart Timer.restart(self) Restarts the timer, and set it's elapsed time to 0. pause Timer.pause(self) Pauses the timer at a certain position. resume Timer.resume(self) Resumes the timer after being paused.","title":"utils"}]}