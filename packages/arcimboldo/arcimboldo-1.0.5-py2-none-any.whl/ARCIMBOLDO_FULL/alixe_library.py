#! /usr/bin/env python
# -*- coding: utf-8 -*-

# Import libraries
# Python Standard Modules
import copy
import time
import cProfile
import ConfigParser
import logging
logging.getLogger().setLevel(20)
import math
import operator
import os
import re
import shutil
import subprocess
import sys
import tarfile
# External Python Libraries
import numpy
from Bio.PDB import *
#import pandas
# Our modules
try:
    import Bioinformatics
except ImportError:
    print "\n I couldn't import Bioinformatics\n"
    print sys.exc_info()[1]
try:
    import ADT
except ImportError:
    print "\n I couldn't import ADT\n"
    print sys.exc_info()[1]
try:
    import SELSLIB2
except ImportError:
    print "\n I couldn't import SELSLIB2\n"
    print sys.exc_info()[1]
try:
    import unitCellTools
except ImportError:
    print "\n I couldn't import unitCellTools\n"
    print sys.exc_info()[1]


"""
This module was originally developed to support the program ALIXE. It contains functions related to

It also contains a space group dictionary
"""

# Functions to help in optimization
def timing(f):
    """

    :param f:
    :type f:
    :return:
    :rtype:
    """

    def wrap(*args, **kwds):
        time1 = time.time()
        ret = f(*args, **kwds)
        time2 = time.time()
        print ('%s function took %0.3f s' % (f.__name__, (time2 - time1)))
        return ret

    return wrap


def profileit(func):
    """

    :param func:
    :type func:
    :return:
    :rtype:
    """

    def wrapper(*args, **kwargs):
        datafn = func.__name__ + ".profile"  # Name the data file sensibly
        prof = cProfile.Profile()
        retval = prof.runcall(func, *args, **kwargs)
        prof.dump_stats(datafn)
        return retval

    return wrapper

# SPACE GROUP DICTIONARY

# These are used for polar space groups
x = 'x'
y = 'y'
z = 'z'

dictio_space_groups = {}

# Key is space group number, except for non standard settings
# Dictionary contains the following fields:
# symbol --> The space group symbol as a string, found in the CRYST card of the pdb
# symops --> A dictionary with the symmetry operations. Keys are numbers from 1 to n,
# being n the number of symmetry operations
#            Each symop is itself a dictionary, with a 'tra' and a 'rot' key, that contain the vectors/matrices (floats)
#            dictio_space_groups[1]['symbol'] --> 'P 1' # standard Hermann-Mauguin symbol
#            dictio_space_groups[1]['short_symbol'] --> 'P 1' # Reduced notation
#            dictio_space_groups[1]['xHM_symbol'] --> 'P 1' # extended Hermann-Mauguin symbol
#            dictio_space_groups[1]['hall_symbol'] --> 'P 1'
#            dictio_space_groups[1]['symops'][1]['tra'] --> [0.0, 0.0, 0.0]
#            dictio_space_groups[1]['symops'][1]['rot'] --> [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]
#            dictio_space_groups[1]['origins_list'] --> [[x, y, z]]
#                                                       if space group is non polar then it will have the coordinates
#            dictio_space_groups[1]['polar'] --> True
#            dictio_space_groups[1]['latt'] --> 1 useful to generate ins files from here
#            dictio_space_groups[1]['symm_cards'] --> [] useful to generate ins files from here

# LATT instruction correspondence with centering of unit cells
# P -> 1 I -> 2 R on hexagonal axes -> 3 F -> 4 A -> 5 B -> 6 C -> 7

dictio_space_groups[1] = {'symbol': 'P 1', 'short_symbol': 'P1', 'xHM_symbol':'P 1' , 'hall_symbol':'P 1' ,'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}},
                          'point': 1, 'laue': '-1',
                          'origins_list': [[x, y, z]], 'polar': True, 'latt': 1, 'symm_cards': []}

# NOTE CM: A1 has not been tested. On the other hand, only 1 structure in the PDB
# dictio_space_groups['A1'] = {'symbol':'A 1' , 'short_symbol': 'A1', 'xHM_symbol': 'A 1' , 'hall_symbol': 'A 1',
#                              'symops': {
#     1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}},
#                           'point': 1, 'laue': '-1',
#                           'origins_list': None, 'polar': True, 'latt': 1, 'symm_cards': []}

# NOTE CM: Not tested, no structures in the PDB
# dictio_space_groups['B1'] = {'symbol':'B 1' , 'short_symbol':'B1' , 'xHM_symbol':'B 1' , 'hall_symbol':'B 1' ,
#                              'symops': {
#     1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}},
#                           'point': 1, 'laue': '-1',
#                           'origins_list': None, 'polar': True, 'latt': 1, 'symm_cards': []}

# NOTE CM: Not tested, no structures in the PDB
# dictio_space_groups['C1'] = {'symbol':'C 1' , 'short_symbol':'C1' , 'xHM_symbol':'C 1' , 'hall_symbol': 'C 1',
#                              'symops': {
#     1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}},
#                           'point': 1, 'laue': '-1',
#                           'origins_list': None, 'polar': True, 'latt': 1, 'symm_cards': []}

# NOTE CM: Not tested, no structures in the PDB
# dictio_space_groups['I1'] = {'symbol': 'I 1' , 'short_symbol': 'I1', 'xHM_symbol': 'I 1', 'hall_symbol':'I 1' ,'symops': {
#     1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}},
#                           'point': 1, 'laue': '-1',
#                           'origins_list': None, 'polar': True, 'latt': 1, 'symm_cards': []}

# NOTE CM: Not tested, no structures in the PDB
# dictio_space_groups['F1'] = {'symbol':'F 1' , 'short_symbol':'F1' , 'xHM_symbol':'F 1' , 'hall_symbol':'F 1' ,'symops': {
#     1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}},
#                           'point': 1, 'laue': '-1',
#                           'origins_list': [[x, y, z]], 'polar': True, 'latt': 1, 'symm_cards': []}

dictio_space_groups[3] = {'symbol': 'P 1 2 1', 'short_symbol': 'P2', 'xHM_symbol': 'P 1 2 1', 'hall_symbol':'P 2y',
                          'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}},
                          'point': 2, 'laue': '2/m',
                          'origins_list': [[0.0, y, 0.0], [0.0, y, 1 / 2.0], [1 / 2.0, y, 0.0], [1 / 2.0, y, 1 / 2.0]],
                          'polar': True, 'latt': 1, 'symm_cards': ['SYMM -x, y, -z\n']}

dictio_space_groups[4] = {'symbol': 'P 1 21 1', 'short_symbol': 'P21', 'xHM_symbol': 'P 1 21 1', 'hall_symbol':'P 2yb',
                          'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}},
                          'point': 2, 'laue': '2/m',
                          'origins_list': [[0.0, y, 0.0], [0.0, y, 1 / 2.0], [1 / 2.0, y, 0.0], [1 / 2.0, y, 1 / 2.0]],
                          'polar': True, 'latt': 1, 'symm_cards': ['SYMM -x, y+0.5, -z\n']}


dictio_space_groups[5] = {'symbol': 'C 1 2 1', 'short_symbol': 'C2', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    3: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}},
                          'point': 2, 'laue': '2/m',
                          'origins_list': [[0.0, y, 0.0], [0.0, y, 1 / 2.0]], 'polar': True, 'latt': 7,
                          'symm_cards': ['SYMM -x, y, -z\n']}

dictio_space_groups['I2'] = {'symbol': 'I 1 2 1', 'short_symbol': 'I2', 'xHM_symbol': 'I 1 2 1',
                             'hall_symbol': 'C 2y (x,y,-x+z)',
                             'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    3: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}},
                             'point': 2, 'laue': '2/m',
                             'origins_list': [[0.0, y, 0.0], [0.0, y, 1 / 2.0]], 'polar': True, 'latt': 2,
                             'symm_cards': ['SYMM -x, y, -z\n']}

dictio_space_groups[16] = {'symbol': 'P 2 2 2', 'short_symbol': 'P222', 'xHM_symbol': 'P 2 2 2',
                           'hall_symbol': 'P 2 2',
                           'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},     # x, y, z
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},   # x, -y, -z
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},   # -x, y, -z
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},  # -x, -y, z
                           'point': 222, 'laue': '2/mm',
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [0.0, 1 / 2.0, 0.0],
                                            [0.0, 1 / 2.0, 1 / 2.0], [1 / 2.0, 0.0, 0.0], [1 / 2.0, 0.0, 1 / 2.0],
                                            [1 / 2.0, 1 / 2.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False,
                           'latt': 1, 'symm_cards': ['SYMM -x, -y, z\n', 'SYMM x, -y, -z\n', 'SYMM -x, y, -z\n']}

dictio_space_groups[17] = {'symbol': 'P 2 2 21', 'short_symbol': 'P2221', 'xHM_symbol': 'P 2 2 21',
                           'hall_symbol': 'P 2c 2' ,'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x, y, z
    2: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}, # -x, -y, z+1/2
    3: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x, y, -z+1/2
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}}, # x, -y, -z
                           'point': 222, 'laue': '2/mm',
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [0.0, 1 / 2.0, 0.0],
                                            [0.0, 1 / 2.0, 1 / 2.0], [1 / 2.0, 0.0, 0.0], [1 / 2.0, 0.0, 1 / 2.0],
                                            [1 / 2.0, 1 / 2.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False,
                           'latt': 1,
                           'symm_cards': ['SYMM -x, -y, z+0.5\n','SYMM -x, y, -z+0.5\n', 'SYMM x, -y, -z\n']}

# NOTE CM: Not tested, only two proteins in the PDB
dictio_space_groups['P2122']= {'symbol': 'P 21 2 2', 'short_symbol': 'P2122', 'xHM_symbol': 'P 21 2 2',
                               'hall_symbol': 'P 2c 2 (z,x,y)', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},  # x, y, z
    2: {'tra': [1 / 2.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},  # x+1/2, -y, -z
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},  # -x, y, -z
    4: {'tra': [1 / 2.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},  # -x+1/2 , -y, z
                       'point': 222, 'laue': '2/mm',
                       'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [0.0, 1 / 2.0, 0.0],[0.0, 1 / 2.0, 1 / 2.0],
                       [1 / 2.0, 0.0, 0.0], [1 / 2.0, 0.0, 1 / 2.0], [1 / 2.0, 1 / 2.0, 0.0],
                       [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                               'symm_cards': ['SYMM x+0.5, -y, -z\n','SYMM -x+0.5, -y, z\n','SYMM -x, y, -z\n']}

# NOTE CM: Not tested, only three proteins in the PDB
dictio_space_groups['P2212']= {'symbol': 'P 2 21 2', 'short_symbol': 'P2212','xHM_symbol': 'P 2 21 2',
                               'hall_symbol': 'P 2c 2 (y,z,x)', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x, y, z
    2: {'tra': [0.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x, -y+1/2, -z
    3: {'tra': [0.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x, y+1/2, -z
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}} # -x, -y, z
    ,
                       'point': 222, 'laue': '2/mm',
                       'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [0.0, 1 / 2.0, 0.0],[0.0, 1 / 2.0, 1 / 2.0],
                       [1 / 2.0, 0.0, 0.0], [1 / 2.0, 0.0, 1 / 2.0], [1 / 2.0, 1 / 2.0, 0.0],
                       [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False,
                        'latt': 1,'symm_cards': ['SYMM -x, y+0.5, -z\n','SYMM x, -y+0.5, -z\n','SYMM -x, -y, z\n']}


dictio_space_groups[18] = {'symbol': 'P 21 21 2', 'short_symbol': 'P21212', 'xHM_symbol': 'P 21 21 2',
                               'hall_symbol': 'P 2 2ab' ,'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x, y, z
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}, # -x, -y, z
    3: {'tra': [1/2.0, 1/2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x+1/2, y+1/2, -z
    4: {'tra': [1/2.0, 1/2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x+1/2, -y+1/2, -z
    },
                           'point': 222, 'laue': '2/mm',
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [0.0, 1 / 2.0, 0.0],
                                            [0.0, 1 / 2.0, 1 / 2.0], [1 / 2.0, 0.0, 0.0], [1 / 2.0, 0.0, 1 / 2.0],
                                            [1 / 2.0, 1 / 2.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False,
                           'latt': 1,
                           'symm_cards': ['SYMM -x, -y, z\n', 'SYMM -x+0.5, y+0.5, -z\n', 'SYMM x+0.5, -y+0.5, -z\n']}

dictio_space_groups['P22121'] = {'symbol': 'P 2 21 21', 'short_symbol': 'P22121', 'xHM_symbol': 'P 2 21 21',
                               'hall_symbol': 'P 2 2ab (z,x,y)' ,'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x, y, z
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x, -y, -z
    3: {'tra': [0.0, 1/2.0, 1/2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x, y+1/2, -z+1/2
    4: {'tra': [0.0, 1/2.0, 1/2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}}, # -x, -y+1/2, z+1/2
                           'point': 222, 'laue': '2/mm',
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [0.0, 1 / 2.0, 0.0],
                                            [0.0, 1 / 2.0, 1 / 2.0], [1 / 2.0, 0.0, 0.0], [1 / 2.0, 0.0, 1 / 2.0],
                                            [1 / 2.0, 1 / 2.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False,
                           'latt': 1,
                           'symm_cards': ['SYMM x, -y, -z\n', 'SYMM -x, y+0.5, -z+0.5\n', 'SYMM -x, -y+0.5, z+0.5\n']}

dictio_space_groups['P21221']={'symbol': 'P 21 2 21', 'short_symbol': 'P21221', 'xHM_symbol': 'P 21 2 21',
                               'hall_symbol': 'P 2 2ab (y,z,x)' ,'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x, y, z
    2: {'tra': [1/2.0, 0.0, 1/2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x+1/2, -y, -z+1/2
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x, y, -z
    4: {'tra': [1/2.0, 0.0, 1/2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}}, # -x+1/2, -y, z+1/2
                           'point': 222, 'laue': '2/mm',
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [0.0, 1 / 2.0, 0.0],
                                            [0.0, 1 / 2.0, 1 / 2.0], [1 / 2.0, 0.0, 0.0], [1 / 2.0, 0.0, 1 / 2.0],
                                            [1 / 2.0, 1 / 2.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False,
                           'latt': 1,
                           'symm_cards': ['SYMM -x, y, -z\n', 'SYMM -x+0.5, -y, z+0.5\n', 'SYMM x+0.5, -y, -z+0.5\n']}


dictio_space_groups[19] = {'symbol': 'P 21 21 21', 'short_symbol': 'P212121','xHM_symbol': 'P 21 21 21',
                            'hall_symbol': 'P 2ac 2ab','symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x, y, z
    2: {'tra': [1/2.0, 0.0, 1/2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}, # -x+1/2, -y, z+1/2
    3: {'tra': [0.0, 1/2.0, 1/2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x, y+1/2, -z+1/2
    4: {'tra': [1/2.0, 1/2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x+1/2, -y+1/2, -z
    },
                           'point': 222, 'laue': '2/mm',
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [0.0, 1 / 2.0, 0.0],
                                            [0.0, 1 / 2.0, 1 / 2.0], [1 / 2.0, 0.0, 0.0], [1 / 2.0, 0.0, 1 / 2.0],
                                            [1 / 2.0, 1 / 2.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False,
                           'latt': 1, 'symm_cards': ['SYMM x+0.5, -y+0.5, -z\n', 'SYMM -x, y+0.5, -z+0.5\n',
                                                     'SYMM -x+0.5, -y, z+0.5\n']}

dictio_space_groups[20] = {'symbol': 'C 2 2 21', 'short_symbol': 'C2221', 'xHM_symbol': 'C 2 2 21',
                            'hall_symbol': 'C 2c 2' ,'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x, y, z
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x, -y, -z
    3: {'tra': [0.0, 0.0, 1/2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x, y, -z+1/2
    4: {'tra': [0.0, 0.0, 1/2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}, # -x, -y, z+1/2
    5: {'tra': [1/2.0, 1/2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x+1/2, y+1/2, z
    6: {'tra': [1/2.0, 1/2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x+1/2, -y+1/2, -z
    7: {'tra': [1/2.0, 1/2.0, 1/2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x+1/2, y+1/2, -z+1/2
    8: {'tra': [1/2.0, 1/2.0, 1/2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}}, # -x+1/2, -y+1/2, z+1/2
                           'point': 222, 'laue': '2/mm',
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 2.0, 0.0, 0.0],
                                            [1 / 2.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 7,
                           'symm_cards': ['SYMM -x, y, -z+0.5\n', 'SYMM -x, -y, z+0.5\n', 'SYMM x, -y, -z\n']}

# NOTE CM: Not tested, only one structure in the pdb and it is DNA
dictio_space_groups['B2212'] = {'symbol': 'B 2 21 2', 'short_symbol': 'B2212', 'xHM_symbol':'B 2 21 2' ,
                            'hall_symbol': 'B 2 2b', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x,y,z

    2: {'tra': [0.0, 1/2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x, -y+1/2, -z

    3: {'tra': [1/2.0, 1/2.0, 1/2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x+1/2, y+1/2, -z+1/2

    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}, # -x, -y, z

    5: {'tra': [1/2.0, 0.0, 1/2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x+1/2, y, z+1/2

    6: {'tra': [1/2.0, 1/2.0, 1/2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x+1/2,-y+1/2,-z+1/2

    7: {'tra': [0.0, 1/2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x, y+1/2, -z

    8: {'tra': [1/2.0, 0.0, 1/2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]} #  -x+1/2,-y,z+1/2
    },
                           'point': 222, 'laue': '2/mm',
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 2.0, 0.0, 0.0],
                                            [1 / 2.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 6,
                           'symm_cards': ['SYMM x, -y+0.5, -z\n', 'SYMM -x, y+0.5, -z\n', 'SYMM -x, -y, z\n']}

# NOTE CM: Not tested, no structures deposited at the pdb
dictio_space_groups['A2122'] = {'symbol': 'A 21 2 2', 'short_symbol': 'A2122', 'xHM_symbol':'A 21 2 2' ,
                            'hall_symbol': 'A 2a 2a', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x, y, z
    2: {'tra': [1/2.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x+1/2,-y,-z
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x, y, -z
    4: {'tra': [1/2.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}, # -x+1/2, -y, z
    5: {'tra': [0.0,1/2.0,1/2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x,y+1/2,z+1/2
    6: {'tra': [1/2.0,1/2.0,1/2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x+1/2,-y+1/2,-z+1/2
    7: {'tra': [0.0,1/2.0,1/2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x,y+1/2,-z+1/2
    8: {'tra': [1/2.0,1/2.0,1/2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]} # -x+1/2,-y+1/2,z+1/2
},
                           'point': 222, 'laue': '2/mm',
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 2.0, 0.0, 0.0],
                                            [1 / 2.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 5,
                           'symm_cards': None} # TODO: produce these symm cards


dictio_space_groups[21] = {'symbol': 'C 2 2 2', 'short_symbol': 'C222','xHM_symbol':'C 2 2 2' ,
                            'hall_symbol':'C 2 2', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    5: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    6: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    7: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},
                           'point': 222, 'laue': '2/mm',
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 2.0, 0.0, 0.0],
                                            [1 / 2.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 7,
                           'symm_cards': ['SYMM -x, -y, z\n', 'SYMM x, -y, -z\n', 'SYMM -x, y, -z\n']}

# NOTE CM: Not tested, there are not structures deposited at the PDB
dictio_space_groups['A222']={'symbol': 'A 2 2 2', 'short_symbol': 'A222','xHM_symbol':'A 2 2 2' ,
                            'hall_symbol':'A 2 2', 'symops': {
    1: {'tra': [0.0,0.0,0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x, y, z
    2: {'tra': [0.0,0.0,0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x, -y, -z
    3: {'tra': [0.0,0.0,0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x, y, -z
    4: {'tra': [0.0,0.0,0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}, # -x, -y, z
    5: {'tra': [0.0,1/2.0,1/2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x, y+1/2, z+1/2
    6: {'tra': [0.0,1/2.0,1/2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x, -y+1/2, -z+1/2
    7: {'tra': [0.0,1/2.0,1/2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x, y+1/2, -z+1/2
    8: {'tra': [0.0,1/2.0,1/2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}}, # -x, -y+1/2, z+1/2
                           'point': 222, 'laue': '2/mm',
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 2.0, 0.0, 0.0],
                                            [1 / 2.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 5,
                           'symm_cards': None} # TODO: produce these symm cards

# NOTE CM: Not tested, there are not structures deposited at the PDB
dictio_space_groups['B222'] = {'symbol': 'B 2 2 2', 'short_symbol': 'B222','xHM_symbol':'B 2 2 2' ,
                            'hall_symbol':'B 2 2', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x, y, z
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x, -y, -z
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x, y, -z
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}, # -x, -y, z
    5: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]}, # x+1/2, y, z+1/2
    6: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x+1/2, -y, -z+1/2
    7: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x+1/2, y, -z+1/2
    8: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}}, # -x+1/2, -y, z+1/2
                           'point': 222, 'laue': '2/mm',
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 2.0, 0.0, 0.0],
                                            [1 / 2.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 6,
                           'symm_cards': None} # TODO: produce these symm cards

dictio_space_groups[22] = {'symbol': 'F 2 2 2', 'short_symbol': 'F222', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    5: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    6: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    7: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    9: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    10: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    11: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    12: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    13: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    14: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    15: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    16: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},
                           'point': 222, 'laue': '2/mm',
                           'origins_list': [[0.0, 0.0, 0.0], [1 / 4.0, 1 / 4.0, 1 / 4.0], [1 / 2.0, 1 / 2.0, 1 / 2.0],
                                            [3 / 4.0, 3 / 4.0, 3 / 4.0]], 'polar': False, 'latt': 4,
                           'symm_cards': ['SYMM -x, -y, z\n', 'SYMM x, -y, -z\n', 'SYMM -x, y, -z\n']}

dictio_space_groups[23] = {'symbol': 'I 2 2 2', 'short_symbol': 'I222', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    5: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    6: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    7: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},
                           'point': 222, 'laue': '2/mm',
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [0.0, 1 / 2.0, 0.0],
                                            [1 / 2.0, 0.0, 0.0]], 'polar': False, 'latt': 2,
                           'symm_cards': ['SYMM -x, -y, z\n', 'SYMM x, -y, -z\n', 'SYMM -x, y, -z\n']}

dictio_space_groups[24] = {'symbol': 'I 21 21 21', 'short_symbol': 'I212121', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    3: {'tra': [1 / 2.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    4: {'tra': [0.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    5: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    6: {'tra': [1 / 2.0, 1 / 2.0, 1.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    7: {'tra': [1.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [1 / 2.0, 1.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [0.0, 1 / 2.0, 0.0],
                            [1 / 2.0, 0.0, 0.0]],
                           'polar': False, 'latt': 2, 'point': 222, 'laue': '2/mm',
                           'symm_cards': ['SYMM x+0.5, -y+0.5, -z\n', 'SYMM -x, y+0.5, -z+0.5\n',
                                          'SYMM -x+0.5, -y, z+0.5\n']}

dictio_space_groups[75] = {'symbol': 'P 4', 'short_symbol': 'P4', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},
                           'origins_list': [[0.0, 0.0, z], [1 / 2.0, 1 / 2.0, z]], 'polar': True, 'latt': 1,
                           'symm_cards': ['SYMM -x, -y, z\n', 'SYMM -y, x, z\n', 'SYMM y, -x, z\n']}

dictio_space_groups[76] = {'symbol': 'P 41', 'short_symbol': 'P41', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 1 / 4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 3 / 4.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},
                           'origins_list': [[0.0, 0.0, z], [1 / 2.0, 1 / 2.0, z]], 'polar': True, 'latt': 1,
                           'symm_cards': ['SYMM y, -x, z+0.75\n', 'SYMM -y, x, z+0.25\n', 'SYMM -x, -y, z+0.5\n']}

dictio_space_groups[77] = {'symbol': 'P 42', 'short_symbol': 'P42', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},
                           'origins_list': [[0.0, 0.0, z], [1 / 2.0, 1 / 2.0, z]], 'polar': True, 'latt': 1,
                           'symm_cards': ['SYMM -y, x, z+0.5\n', 'SYMM -x, -y, z\n',
                                          'SYMM y, -x, z+0.5\n']}

dictio_space_groups[78] = {'symbol': 'P 43', 'short_symbol': 'P43', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 3 / 4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 1 / 4.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},
                           'origins_list': [[0.0, 0.0, z], [1 / 2.0, 1 / 2.0, z]], 'polar': True, 'latt': 1,
                           'symm_cards': ['SYMM -y, x, z+0.75\n', 'SYMM -x, -y, z+1.5\n', 'SYMM -x, -y, z+0.5\n',
                                          'SYMM y, -x, z+1.25\n', 'SYMM y, -x, z+2.25\n', '']}

dictio_space_groups[79] = {'symbol': 'I 4', 'short_symbol': 'I4', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    5: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    6: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    8: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},
                           'origins_list': [[0.0, 0.0, z]], 'polar': True, 'latt': 2,
                           'symm_cards': ['SYMM -x, -y, z\n', 'SYMM -y, x, z\n', 'SYMM y, -x, z\n']}

dictio_space_groups[80] = {'symbol': 'I 41', 'short_symbol': 'I41', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [1 / 2.0, 0.0, 3 / 4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [1 / 2.0, 0.0, 3 / 4.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    5: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    6: {'tra': [1.0, 1 / 2.0, 0.625], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [1.0, 1 / 2.0, 0.625], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    8: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},
                           'origins_list': [[0.0, 0.0, z]], 'polar': True, 'latt': 2,
                           'symm_cards': ['SYMM -x+0.5, -y+0.5, z+0.5\n', 'SYMM y+0.5, -x, z+0.75\n',
                                          'SYMM -y, x+0.5, z+0.25\n']}

dictio_space_groups[89] = {'symbol': 'P 4 2 2', 'short_symbol': 'P422', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},      # x, y, z
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},     # -y, x, z
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},     # y, -x, z
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},    # x, -y, -z
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},    # -x, y, -z
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},    # -x, -y, z
    7: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},     # y, x, -z
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]}},  # -y, -x, -z
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 2.0, 1 / 2.0, 0.0],
                                            [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                           'symm_cards': ['SYMM -y, -x, -z\n', 'SYMM y, -x, z\n', 'SYMM y, x, -z\n', 'SYMM -x, -y, z\n',
                                          'SYMM x, -y, -z\n', 'SYMM -y, x, z\n', 'SYMM -x, y, -z\n']}

dictio_space_groups[90] = {'symbol': 'P 4 21 2', 'short_symbol': 'P4212', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    5: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]}},
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 2.0, 1 / 2.0, 0.0],
                                            [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                           'symm_cards': ['SYMM -y+0.5, x+0.5, z\n', 'SYMM -x, -y, z\n', 'SYMM -x, -y, z\n',
                                          'SYMM x+0.5, -y+0.5, -z\n', 'SYMM y, x, -z\n', 'SYMM y+0.5, -x+0.5, z\n',
                                          'SYMM -y, -x, -z\n', 'SYMM -x+0.5, y+0.5, -z\n']}

dictio_space_groups[91] = {'symbol': 'P 41 2 2', 'short_symbol': 'P4122', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},          # x, y, z
    2: {'tra': [0.0, 0.0, 1 / 4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},     # -y, x, z+1/4
    3: {'tra': [0.0, 0.0, 3 / 4.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},     # y, -x, z+3/4
    4: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},    # x, -y, -z+1/2
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},        # -x, y, -z
    6: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},    # -x, -y, z+1/2
    7: {'tra': [0.0, 0.0, 3 / 4.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},     # y, x, -z+3/4
    8: {'tra': [0.0, 0.0, 1 / 4.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]}},  # -y, -x, -z+1/4
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 2.0, 1 / 2.0, 0.0],
                                            [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                           'symm_cards': ['SYMM -x, -y, z+0.5\n', 'SYMM -y, x, z+0.25\n', 'SYMM x, -y, -z+0.5\n',
                                          'SYMM -y, -x, -z+0.25\n', 'SYMM y, -x, z+0.75\n', 'SYMM -x, y, -z\n',
                                          'SYMM y, x, -z+0.75\n']}

dictio_space_groups[92] = {'symbol': 'P 41 21 2', 'short_symbol': 'P41212', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},               # x, y, z
    2: {'tra': [1/2.0, 1/2.0, 1/4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},        # -y+1/2, x+1/2, z+1/4
    3: {'tra': [1 / 2.0, 1 / 2.0, 3 / 4.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},  # y+1/2, -x+1/2, z+3/4
    4: {'tra': [1 / 2.0, 1 / 2.0, 3 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}, # x+1/2, -y+1/2, -z+3/4
    5: {'tra': [1 / 2.0, 1 / 2.0, 1 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]}, # -x+1/2, y+1/2, -z+1/4
    6: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},         # -x, -y, z+1/2
    7: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},              # y, x, -z
    8: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]}},       # -y, -x, -z+1/2
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 2.0, 1 / 2.0, 0.0],
                                            [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                           'point': 422, 'laue': '4/mm',
                           'symm_cards': ['SYMM -x, -y, z+0.5\n', 'SYMM -x+0.5, y+0.5, -z+0.25\n',
                                          'SYMM y+0.5, -x+0.5, z+0.75\n', 'SYMM x+0.5, -y+0.5, -z+0.75\n',
                                          'SYMM -y+0.5, x+0.5, z+0.25\n', 'SYMM -y, -x, -z+0.5\n', 'SYMM y, x, -z\n']}

dictio_space_groups[93] = {'symbol': 'P 42 2 2', 'short_symbol': 'P4222', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]}},
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 2.0, 1 / 2.0, 0.0],
                                            [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                           'symm_cards': ['SYMM y, -x, z+0.5\n', 'SYMM -x, -y, z\n', 'SYMM x, -y, -z\n',
                                          'SYMM -x, -y, z\n', 'SYMM -y, x, z+0.5\n', 'SYMM x, -y, -z\n',
                                          'SYMM -y, -x, -z+0.5\n', 'SYMM y, x, -z+0.5\n', 'SYMM -x, y, -z\n']}

dictio_space_groups[94] = {'symbol': 'P 42 21 2', 'short_symbol': 'P42212', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    5: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]}},
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 2.0, 1 / 2.0, 0.0],
                                            [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                           'symm_cards': ['SYMM x+0.5, -y+0.5, -z+0.5\n', 'SYMM -x, -y, z\n',
                                          'SYMM -y+0.5, x+0.5, z+0.5\n', 'SYMM -x+0.5, y+0.5, -z+0.5\n',
                                          'SYMM y, x, -z\n','SYMM -y, -x, -z\n', 'SYMM y+0.5, -x+0.5, z+0.5\n']}

dictio_space_groups[95] = {'symbol': 'P 43 2 2', 'short_symbol': 'P4322', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 3 / 4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 1 / 4.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    6: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [0.0, 0.0, 1 / 4.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [0.0, 0.0, 3 / 4.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]}},
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 2.0, 1 / 2.0, 0.0],
                                            [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                           'symm_cards': ['SYMM -y, x, z+0.75\n', 'SYMM -x, -y, z+1.5\n', 'SYMM -x, -y, z+0.5\n',
                                          'SYMM y, x, -z+0.25\n', 'SYMM y, -x, z+1.25\n', 'SYMM x, -y, -z+0.5\n',
                                          'SYMM -x, y, -z\n', 'SYMM y, -x, z+2.25\n', 'SYMM -y, -x, -z+0.75\n']}

dictio_space_groups[96] = {'symbol': 'P 43 21 2', 'short_symbol': 'P43212', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [1 / 2.0, 1 / 2.0, 3 / 4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [1 / 2.0, 1 / 2.0, 1 / 4.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [1 / 2.0, 1 / 2.0, 1 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    5: {'tra': [1 / 2.0, 1 / 2.0, 3 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    6: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]}},
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 2.0, 1 / 2.0, 0.0],
                                            [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                           'symm_cards': ['SYMM 0.5-y, 0.5+x, 0.75+z\n', 'SYMM -x, -y, 0.5+z\n',
                                          'SYMM 0.5+y, 0.5-x, 0.25+z\n', 'SYMM 0.5-x, 0.5+y, 0.75-z\n',
                                          'SYMM y, x, -z\n', 'SYMM 0.5+x, 0.5-y, 0.25-z\n', 'SYMM -y, -x, 0.5-z\n']}

dictio_space_groups[97] = {'symbol': 'I 4 2 2', 'short_symbol': 'I422', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    9: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    10: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    11: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    12: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    13: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    14: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    15: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    16: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]}},
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 2,
                           'symm_cards': ['SYMM -y, -x, -z\n', 'SYMM y, -x, z\n', 'SYMM y, x, -z\n', 'SYMM -x, -y, z\n',
                                          'SYMM x, -y, -z\n', 'SYMM -y, x, z\n', 'SYMM -x, y, -z\n']}

dictio_space_groups[98] = {'symbol': 'I 41 2 2', 'short_symbol': 'I4122', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [1 / 2.0, 0.0, 3 / 4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [1 / 2.0, 0.0, 3 / 4.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [1 / 2.0, 0.0, 3 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    5: {'tra': [1 / 2.0, 0.0, 3 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    9: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    10: {'tra': [1.0, 1 / 2.0, 0.625], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    11: {'tra': [1.0, 1 / 2.0, 0.625], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    12: {'tra': [1.0, 1 / 2.0, 0.625], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    13: {'tra': [1.0, 1 / 2.0, 0.625], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    14: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    15: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    16: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]}},
                           'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 2,
                           'symm_cards': ['SYMM -y, x+0.5, z+0.25\n', 'SYMM -x+0.5, -y+0.5, z+0.5\n',
                                          'SYMM y+0.5, -x, z+0.75\n', 'SYMM y+0.5, x+0.5, -z+0.5\n',
                                          'SYMM -x+0.5, y, -z+0.75\n', 'SYMM x, -y+0.5, -z+1.25\n', 'SYMM -y, -x, -z\n',
                                          'SYMM x, -y+0.5, -z+0.25\n']}

dictio_space_groups[143] = {'symbol': 'P 3', 'short_symbol': 'P3', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]}},
                            'origins_list': [[0.0, 0.0, z], [1 / 3.0, 2 / 3.0, z], [2 / 3.0, 1 / 3.0, z]],
                            'polar': True, 'latt': 1,
                            'symm_cards': ['SYMM -x+y, -x, z\n', 'SYMM -y, x-y, z\n']}

dictio_space_groups[144] = {'symbol': 'P 31', 'short_symbol': 'P31', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]}},
                            'origins_list': [[0.0, 0.0, z], [1 / 3.0, 2 / 3.0, z], [2 / 3.0, 1 / 3.0, z]],
                            'polar': True, 'latt': 1,
                            'symm_cards': ['SYMM -y, x-y, z+0.333333333333\n','SYMM -x+y, -x, z+0.666666666667\n']}

dictio_space_groups[145] = {'symbol': 'P 32', 'short_symbol': 'P32', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]}},
                            'origins_list': [[0.0, 0.0, z], [1 / 3.0, 2 / 3.0, z], [2 / 3.0, 1 / 3.0, z]],
                            'polar': True, 'latt': 1,
                            'symm_cards': ['SYMM -y, x-y, z+0.666666666667\n','SYMM -x+y, -x, z+0.333333333333\n']}

dictio_space_groups[146] = {'symbol': 'H 3', 'short_symbol': 'H3', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [1 / 3.0, 2 / 3.0, 2 / 3.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    5: {'tra': [1 / 3.0, 2 / 3.0, 2 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    6: {'tra': [1 / 3.0, 2 / 3.0, 2 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [2 / 3.0, 1 / 3.0, 1 / 3.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    8: {'tra': [2 / 3.0, 1 / 3.0, 1 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    9: {'tra': [2 / 3.0, 1 / 3.0, 1 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]}},
                            'point': 3, 'laue': '-3',
                            'origins_list': [[0.0, 0.0, z]], 'polar': True, 'latt': 3,
                            'symm_cards': ['SYMM -x+y, -x, z\n', 'SYMM -y, x-y, z\n']}

dictio_space_groups['R 3'] = {'symbol': 'R 3', 'short_symbol': 'R3', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]}},
                              'origins_list': [[x, x, x]], 'polar': True, 'latt': 1,
                              'symm_cards': ['SYMM y, z, x\n', 'SYMM z, x, y\n']}

dictio_space_groups[149] = {'symbol': 'P 3 1 2', 'short_symbol': 'P312', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 1.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 3.0, 2 / 3.0, 0.0],
                                             [1 / 3.0, 2 / 3.0, 1 / 2.0], [2 / 3.0, 1 / 3.0, 0.0],
                                             [2 / 3.0, 1 / 3.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'symm_cards': ['SYMM x, x-y, -z\n','SYMM -y, -x, -z\n','SYMM -x+y, y, -z\n',
                                           'SYMM -x+y, -x, z\n','SYMM -y, x-y, z\n']}

dictio_space_groups[150] = {'symbol': 'P 3 2 1', 'short_symbol': 'P321', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'symm_cards':['SYMM x-y, -y, -z\n', 'SYMM -x, -x+y, -z\n', 'SYMM y, x, -z\n',
                                          'SYMM -x+y, -x, z\n', 'SYMM -y, x-y, z\n']}


dictio_space_groups[151] = {'symbol': 'P 31 1 2', 'short_symbol': 'P3112', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    5: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 3.0, 2 / 3.0, 0.0],
                                             [1 / 3.0, 2 / 3.0, 1 / 2.0], [2 / 3.0, 1 / 3.0, 0.0],
                                             [2 / 3.0, 1 / 3.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'symm_cards':['SYMM y, x, -z\n', 'SYMM -y, x-y, z+0.333333333333\n',
                                          'SYMM -x+y, -x, z+0.666666666667\n', 'SYMM x-y, -y, -z+0.666666666667\n',
                                          'SYMM -x, -x+y, -z+0.333333333333\n']}

dictio_space_groups[152] = {'symbol': 'P 31 2 1', 'short_symbol': 'P3121', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[1.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    5: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[-1.0, 0.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'symm_cards': ['SYMM y, x, -z\n', 'SYMM -y, x-y, z+0.333333333333\n',
                                           'SYMM -x+y, -x, z+0.666666666667\n', 'SYMM x-y, -y, -z+0.666666666667\n',
                                           'SYMM -x, -x+y, -z+0.333333333333\n']}

dictio_space_groups[153] = {'symbol': 'P 32 1 2', 'short_symbol': 'P3212', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    5: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0], [1 / 3.0, 2 / 3.0, 0.0],
                                             [1 / 3.0, 2 / 3.0, 1 / 2.0], [2 / 3.0, 1 / 3.0, 0.0],
                                             [2 / 3.0, 1 / 3.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'symm_cards': ['SYMM -y, x-y, z+0.666666666667\n', 'SYMM -x+y, -x, z+0.333333333333\n',
                                           'SYMM -y, -x, -z+0.333333333333\n', 'SYMM x, x-y, -z\n',
                                           'SYMM -x+y, y, -z+0.666666666667\n']}

dictio_space_groups[154] = {'symbol': 'P 32 2 1', 'short_symbol': 'P3221', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[1.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    5: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[-1.0, 0.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'symm_cards': ['SYMM -y, x-y, z+0.666666666667\n', 'SYMM -x+y, -x, z+0.333333333333\n',
                                           'SYMM y, x, -z\n', 'SYMM -x, -x+y, -z+0.666666666667\n',
                                           'SYMM x-y, -y, -z+0.333333333333\n']}

dictio_space_groups[155] = {'symbol': 'H 3 2', 'short_symbol': 'H32', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    7: {'tra': [1 / 3.0, 2 / 3.0, 2 / 3.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    8: {'tra': [1 / 3.0, 2 / 3.0, 2 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    9: {'tra': [1 / 3.0, 2 / 3.0, 2 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    10: {'tra': [1 / 3.0, 2 / 3.0, 2 / 3.0], 'rot': [[1.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    11: {'tra': [1 / 3.0, 2 / 3.0, 2 / 3.0], 'rot': [[-1.0, 0.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    12: {'tra': [1 / 3.0, 2 / 3.0, 2 / 3.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    13: {'tra': [2 / 3.0, 1 / 3.0, 1 / 3.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    14: {'tra': [2 / 3.0, 1 / 3.0, 1 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    15: {'tra': [2 / 3.0, 1 / 3.0, 1 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    16: {'tra': [2 / 3.0, 1 / 3.0, 1 / 3.0], 'rot': [[1.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    17: {'tra': [2 / 3.0, 1 / 3.0, 1 / 3.0], 'rot': [[-1.0, 0.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    18: {'tra': [2 / 3.0, 1 / 3.0, 1 / 3.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 3,
                            'symm_cards': ['SYMM x-y, -y, -z\n', 'SYMM -x, -x+y, -z\n', 'SYMM y, x, -z\n',
                                           'SYMM -x+y, -x, z\n', 'SYMM -y, x-y, z\n']}

dictio_space_groups['R 3 2'] = {'symbol': 'R 3 2', 'short_symbol': 'R32', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]}},
                                'origins_list': [[0.0, 0.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False,
                                'latt': 1, 'symm_cards': ['SYMM -z, -y, -x\n', 'SYMM -x, -z, -y\n', 'SYMM y, z, x\n',
                                                          'SYMM -y, -x, -z\n', 'SYMM z, x, y\n']}

dictio_space_groups[168] = {'symbol': 'P 6', 'short_symbol': 'P6', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},         # x, y, z
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},        # x-y, x, z
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},        # y, -x+y, z
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},       # -y, x-y, z
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},       # -x+y, -x, z
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},      # -x, -y, z
                            'origins_list': [[0.0, 0.0, z]], 'polar': True, 'latt': 1, 'point': 6, 'laue': '6/m',
                            'symm_cards': ['SYMM x-y, x, z\n', 'SYMM -x, -y, z\n', 'SYMM -x+y, -x, z\n',
                                           'SYMM -y, x-y, z\n', 'SYMM y, -x+y, z\n']}

dictio_space_groups[169] = {'symbol': 'P 61', 'short_symbol': 'P61', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},         # x, y, z
    2: {'tra': [0.0, 0.0, 1 / 6.0], 'rot': [[1.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},    # x-y, x, z+1/6
    3: {'tra': [0.0, 0.0, 5 / 6.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},    # y, -x+y, z+5/6
    4: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},   # -y, x-y, z+1/3
    5: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},   # -x+y, -x, z+2/3
    6: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},  # -x, -y, z+1/2
                            'origins_list': [[0.0, 0.0, z]], 'polar': True, 'latt': 1, 'point': 6, 'laue': '6/m',
                            'symm_cards': ['SYMM y, -x+y, z+0.833333333333\n', 'SYMM -x, -y, z+0.5\n',
                                           'SYMM -y, x-y, z+0.333333333333\n', 'SYMM x-y, x, z+0.166666666667\n',
                                           'SYMM -x+y, -x, z+0.666666666667\n']}

dictio_space_groups[170] = {'symbol': 'P 65', 'short_symbol': 'P65', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},         # x, y, z
    2: {'tra': [0.0, 0.0, 5 / 6.0], 'rot': [[1.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},    # x-y, x, z+5/6
    3: {'tra': [0.0, 0.0, 1 / 6.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},    # y, -x+y, z+1/6
    4: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},   # -y, x-y, z+2/3
    5: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},   # -x+y, -x, z+1/3
    6: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},  # -x, -y, z+1/2
                            'origins_list': [[0.0, 0.0, z]], 'polar': True, 'latt': 1, 'point': 6, 'laue': '6/m',
                            'symm_cards': ['SYMM -y, x-y, z+0.666666666667\n', 'SYMM -x+y, -x, z+0.333333333333\n',
                                           'SYMM x-y, x, z+0.833333333333\n', 'SYMM -x, -y, z+0.5\n',
                                           'SYMM y, -x+y, z+0.166666666667\n']}

dictio_space_groups[171] = {'symbol': 'P 62', 'short_symbol': 'P62', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},        # x, y, z
    2: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[1.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},   # x-y, x, z+1/3
    3: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},   # y, -x+y, z+2/3
    4: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},  # -y, x-y, z+2/3
    5: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},  # -x+y, -x, z+1/3
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},     # -x, -y, z
                            'origins_list': [[0.0, 0.0, z]], 'polar': True, 'latt': 1, 'point': 6, 'laue': '6/m',
                            'symm_cards': ['SYMM -y, x-y, z+0.666666666667\n', 'SYMM y, -x+y, z+0.666666666667\n',
                                           'SYMM -x, -y, z\n', 'SYMM -x+y, -x, z+0.333333333333\n',
                                           'SYMM x-y, x, z+0.333333333333\n']}

dictio_space_groups[172] = {'symbol': 'P 64', 'short_symbol': 'P64', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},        # x, y, z
    2: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[1.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},   # x-y, x, z+2/3
    3: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},   # y, -x+y, z+1/3
    4: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},  # -y, x-y, z+1/3
    5: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},  # -x+y, -x, z+2/3
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},     # -x, -y, z
                            'origins_list': [[0.0, 0.0, z]], 'polar': True, 'latt': 1, 'point': 6, 'laue': '6/m',
                            'symm_cards': ['SYMM y, -x+y, z+0.333333333333\n','SYMM -x, -y, z\n',
                                           'SYMM -y, x-y, z+0.333333333333\n','SYMM x-y, x, z+0.666666666667\n',
                                           'SYMM -x+y, -x, z+0.666666666667\n']}

dictio_space_groups[173] = {'symbol': 'P 63', 'short_symbol': 'P63', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},         # x, y, z
    2: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[1.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},    # x-y , x, z+1/2
    3: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},    # y, -x+y, z+1/2
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},       # -y, x-y, z
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},       # -x+y, -x, z
    6: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},  # -x, -y, z+1/2
                            'origins_list': [[0.0, 0.0, z]], 'polar': True, 'latt': 1, 'point': 6, 'laue': '6/m',
                            'symm_cards': ['SYMM -x, -y, z+0.5\n','SYMM -x+y, -x, z\n','SYMM -y, x-y, z\n',
                                           'SYMM x-y, x, z+0.5\n','SYMM y, -x+y, z+0.5\n']}

dictio_space_groups[177] = {'symbol': 'P 6 2 2', 'short_symbol': 'P622', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    7: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    9: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    10: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    11: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 1.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    12: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'point':'622','laue':'6/mmm',
                            'symm_cards': ['SYMM x, x-y, -z\n','SYMM -y, -x, -z\n','SYMM x-y, x, z\n',
                                           'SYMM -x, -x+y, -z\n','SYMM y, x, -z\n','SYMM -x, -y, z\n',
                                           'SYMM -x+y, -x, z\n','SYMM x-y, -y, -z\n','SYMM -x+y, y, -z\n',
                                           'SYMM -y, x-y, z\n','SYMM y, -x+y, z\n']}

dictio_space_groups[178] = {'symbol': 'P 61 2 2', 'short_symbol': 'P6122', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 1 / 6.0], 'rot': [[1.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 5 / 6.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    5: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    7: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[-1.0, 0.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    9: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    10: {'tra': [0.0, 0.0, 5 / 6.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    11: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 1.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    12: {'tra': [0.0, 0.0, 1 / 6.0], 'rot': [[1.0, 0.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'point': '622', 'laue': '6/mmm',
                            'symm_cards':['SYMM -Y, X-Y, 1/3+Z\n','SYMM -X+Y, -X, 2/3+Z\n','SYMM -X, -Y, 1/2+Z\n',
                                          'SYMM Y, -X+Y, 5/6+Z\n','SYMM X-Y, X, 1/6+Z\n','SYMM Y, X, 1/3-Z\n',
                                          'SYMM X-Y, -Y, -Z\n','SYMM -X, -X+Y, 2/3-Z\n','SYMM -Y, -X, 5/6-Z\n',
                                          'SYMM -X+Y, Y, 1/2-Z\n','SYMM X, X-Y, 1/6-Z\n']}

dictio_space_groups[179] = {'symbol': 'P 65 2 2', 'short_symbol': 'P6522', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 5 / 6.0], 'rot': [[1.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 1 / 6.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    5: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    7: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[-1.0, 0.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    9: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    10: {'tra': [0.0, 0.0, 1 / 6.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    11: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 1.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    12: {'tra': [0.0, 0.0, 5 / 6.0], 'rot': [[1.0, 0.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'point':'622','laue':'6/mmm',
                            'symm_cards': ['SYMM -Y, X-Y, 2/3+Z\n','SYMM -X+Y, -X, 1/3+Z\n','SYMM -X, -Y, 1/2+Z\n',
                                           'SYMM Y, -X+Y, 1/6+Z\n','SYMM X-Y, X, 5/6+Z\n','SYMM Y, X, 2/3-Z\n',
                                           'SYMM X-Y, -Y, -Z\n','SYMM -X, -X+Y, 1/3-Z\n','SYMM -Y, -X, 1/6-Z\n',
                                           'SYMM -X+Y, Y, 1/2-Z\n','SYMM X, X-Y, 5/6-Z\n']}


dictio_space_groups[180] = {'symbol': 'P 62 2 2', 'short_symbol': 'P6222', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[1.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    5: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    7: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[-1.0, 0.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    9: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    10: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    11: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 1.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    12: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[1.0, 0.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'point':'622','laue':'6/mmm',
                            'symm_cards': ['SYMM -Y, X-Y, 2/3+Z\n','SYMM -X+Y, -X, 1/3+Z\n','SYMM -X, -Y, Z\n',
                                           'SYMM Y, -X+Y, 2/3+Z\n','SYMM X-Y, X, 1/3+Z\n','SYMM Y, X, 2/3-Z\n',
                                           'SYMM X-Y, -Y, -Z\n','SYMM -X, -X+Y, 1/3-Z\n','SYMM -Y, -X, 2/3-Z\n',
                                           'SYMM -X+Y, Y, -Z\n','SYMM X, X-Y, 1/3-Z\n']}

dictio_space_groups[181] = {'symbol': 'P 64 2 2', 'short_symbol': 'P6422', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[1.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    5: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    7: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[-1.0, 0.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    9: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    10: {'tra': [0.0, 0.0, 1 / 3.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    11: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 1.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    12: {'tra': [0.0, 0.0, 2 / 3.0], 'rot': [[1.0, 0.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'point':'622','laue':'6/mmm',
                            'symm_cards': ['SYMM y, x, -z+0.333333333333\n','SYMM y, -x+y, z+0.333333333333\n',
                                           'SYMM -x+y, y, -z\n','SYMM -x, -y, z\n','SYMM -y, x-y, z+0.333333333333\n',
                                           'SYMM x-y, -y, -z\n','SYMM x-y, x, z+0.666666666667\n',
                                           'SYMM -x+y, -x, z+0.666666666667\n','SYMM -y, -x, -z+0.333333333333\n',
                                           'SYMM -x, -x+y, -z+0.666666666667\n','SYMM x, x-y, -z+0.666666666667\n']}

dictio_space_groups[182] = {'symbol': 'P 63 2 2', 'short_symbol': 'P6322', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[1.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    3: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, -1.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    7: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    8: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    9: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    10: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    11: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 1.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    12: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, -1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [0.0, 0.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'point':'622','laue':'6/mmm',
                            'symm_cards': ['SYMM x-y, -y, -z\n','SYMM -x, -y, z+0.5\n','SYMM -x, -x+y, -z\n',
                                           'SYMM y, x, -z\n','SYMM -x+y, -x, z\n','SYMM x, x-y, -z+0.5\n',
                                           'SYMM -x+y, y, -z+0.5\n','SYMM -y, x-y, z\n','SYMM x-y, x, z+0.5\n',
                                           'SYMM -y, -x, -z+0.5\n','SYMM y, -x+y, z+0.5\n',]}

dictio_space_groups[195] = {'symbol': 'P 2 3', 'short_symbol': 'P23', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    7: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    9: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    10: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    11: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    12: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'symm_cards': ['SYMM z, x, y\n', 'SYMM x, -y, -z\n', 'SYMM -x, -y, z\n', 'SYMM z, -x, -y\n',
                                           'SYMM -y, z, -x\n', 'SYMM -y, -z, x\n', 'SYMM y, z, x\n', 'SYMM -z, x, -y\n',
                                           'SYMM -x, y, -z\n', 'SYMM -z, -x, y\n']}

dictio_space_groups[196] = {'symbol': 'F 2 3', 'short_symbol': 'F23', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    7: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    9: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    10: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    11: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    12: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    13: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    14: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    15: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    16: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    17: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    18: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    19: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    20: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    21: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    22: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    23: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    24: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    25: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    26: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    27: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    28: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    29: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    30: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    31: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    32: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    33: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    34: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    35: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    36: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    37: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    38: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    39: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    40: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    41: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    42: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    43: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    44: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    45: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    46: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    47: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    48: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [1 / 4.0, 1 / 4.0, 1 / 4.0], [1 / 2.0, 1 / 2.0, 1 / 2.0],
                                             [3 / 4.0, 3 / 4.0, 3 / 4.0]], 'polar': False, 'latt': 4,
                            'symm_cards': ['SYMM z, x, y\n','SYMM x, -y, -z\n','SYMM -x, -y, z\n','SYMM y, -z, -x\n',
                                           'SYMM z, -x, -y\n','SYMM -y, z, -x\n','SYMM -y, -z, x\n','SYMM y, z, x\n',
                                           'SYMM -z, x, -y\n','SYMM -x, y, -z\n','SYMM -z, -x, y\n']}




dictio_space_groups[197] = {'symbol': 'I 2 3', 'short_symbol': 'I23', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    7: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    9: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    10: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    11: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    12: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    13: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    14: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    15: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    16: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    17: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    18: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    19: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    20: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    21: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    22: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    23: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    24: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0]], 'polar': False, 'latt': 2,
                            'symm_cards': ['SYMM z, x, y\n', 'SYMM x, -y, -z\n', 'SYMM -x, -y, z\n', 'SYMM z, -x, -y\n',
                                           'SYMM -y, z, -x\n', 'SYMM -y, -z, x\n', 'SYMM y, z, x\n', 'SYMM -z, x, -y\n',
                                           'SYMM -x, y, -z\n', 'SYMM -z, -x, y\n']}

dictio_space_groups[198] = {'symbol': 'P 21 3', 'short_symbol': 'P213', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    4: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    5: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    6: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    7: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    8: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    9: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    10: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    11: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    12: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'symm_cards': ['SYMM -z, x+0.5, -y+0.5\n', 'SYMM z, x, y\n', 'SYMM -x, y+0.5, -z+0.5\n',
                                           'SYMM z+0.5, -x+0.5, -y\n', 'SYMM y+0.5, -z+0.5, -x\n',
                                           'SYMM -z+0.5, -x, y+0.5\n', 'SYMM x+0.5, -y+0.5, -z\n',
                                           'SYMM -y, z+0.5, -x+0.5\n','SYMM y, z, x\n', 'SYMM -y+0.5, -z, x+0.5\n',
                                           'SYMM -x+0.5, -y, z+0.5\n']}



dictio_space_groups[199] = {'symbol': 'I 21 3', 'short_symbol': 'I213', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    4: {'tra': [0.0, 1 / 2.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    5: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    6: {'tra': [1 / 2.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    7: {'tra': [0.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    8: {'tra': [1 / 2.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    9: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    10: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    11: {'tra': [1 / 2.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    12: {'tra': [0.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    13: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    14: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    15: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    16: {'tra': [1 / 2.0, 1.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    17: {'tra': [1 / 2.0, 1 / 2.0, 1.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    18: {'tra': [1.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    19: {'tra': [1 / 2.0, 1.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    20: {'tra': [1.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    21: {'tra': [1 / 2.0, 1 / 2.0, 1.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    22: {'tra': [1 / 2.0, 1 / 2.0, 1.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    23: {'tra': [1.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    24: {'tra': [1 / 2.0, 1.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0]], 'polar': False, 'latt': 2,
                            'symm_cards': ['SYMM -y, -z, x+0.5\n', 'SYMM -x, -y, z+0.5\n', 'SYMM -x, y+0.5, -z\n',
                                           'SYMM -y, z+0.5, -x\n', 'SYMM z, x, y\n', 'SYMM -z, x+0.5, -y\n',
                                           'SYMM x, -y+0.5, -z+0.5\n', 'SYMM -z, -x, y+0.5\n', 'SYMM y, z, x\n',
                                           'SYMM z+0.5, -x, -y\n']}

dictio_space_groups[207] = {'symbol': 'P 4 3 2', 'short_symbol': 'P432', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    9: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    10: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    11: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    12: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    13: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    14: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    15: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    16: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    17: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    18: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    19: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    20: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    21: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    22: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    23: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    24: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'symm_cards': ['SYMM y, z, x\n', 'SYMM -y, x, z\n', 'SYMM y, -x, z\n',
                                           'SYMM -x, -y, z+0.5\n', 'SYMM -y, -z, x+0.5\n', 'SYMM y, x, -z\n',
                                           'SYMM z, x, y\n', 'SYMM x, z, -y\n', 'SYMM x, -y, -z+0.5\n',
                                           'SYMM -z, y, x\n', 'SYMM -z, -x, y+0.5\n', 'SYMM -x, y, -z\n',
                                           'SYMM -y, z, -x\n', 'SYMM z, y, -x\n', 'SYMM -y, -x, -z+0.5\n',
                                           'SYMM z+0.5, -x, -y\n', 'SYMM -z, x, -y\n', 'SYMM -z, -x, y\n']}

dictio_space_groups[208] = {'symbol': 'P 42 3 2', 'short_symbol': 'P4232', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    3: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    4: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    5: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    6: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    9: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    10: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    11: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    12: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    13: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    14: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    15: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    16: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    17: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    18: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    19: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    20: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    21: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    22: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    23: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    24: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'symm_cards': ['SYMM -z+0.5, y+0.5, x+0.5\n', 'SYMM -y, -z, x+0.5\n',
                                           'SYMM -x, -y, z+0.5\n', 'SYMM -y+0.5, -x+0.5, -z\n',
                                           'SYMM y+0.5, x+0.5, -z+0.5\n', 'SYMM z, x, y\n',
                                           'SYMM x+0.5, z+0.5, -y+0.5\n', 'SYMM x, -y, -z+0.5\n',
                                           'SYMM -z, -x, y+0.5\n', 'SYMM -x, y, -z\n', 'SYMM -y, z, -x\n',
                                           'SYMM -y+0.5, x+0.5, z+0.5\n', 'SYMM y, z, x\n', 'SYMM z+0.5, -x, -y\n',
                                           'SYMM -z, x, -y\n', 'SYMM z+0.5, y+0.5, -x+0.5\n',
                                           'SYMM y+0.5, -x+0.5, z+0.5\n', 'SYMM -z, -x, y\n']}

dictio_space_groups[209] = {'symbol': 'F 4 3 2', 'short_symbol': 'F432', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    9: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    10: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    11: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    12: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    13: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    14: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    15: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    16: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    17: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    18: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    19: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    20: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    21: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    22: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    23: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    24: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]},
    25: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    26: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    27: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    28: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    29: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    30: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    31: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    32: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    33: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    34: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    35: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    36: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    37: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    38: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    39: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    40: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    41: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    42: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    43: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    44: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    45: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    46: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    47: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    48: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]},
    49: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    50: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    51: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    52: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    53: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    54: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    55: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    56: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    57: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    58: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    59: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    60: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    61: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    62: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    63: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    64: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    65: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    66: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    67: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    68: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    69: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    70: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    71: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    72: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]},
    73: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    74: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    75: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    76: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    77: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    78: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    79: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    80: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    81: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    82: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    83: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    84: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    85: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    86: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    87: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    88: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    89: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    90: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    91: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    92: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    93: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    94: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    95: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    96: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 4,
                            'symm_cards': ['SYMM y, z, x\n', 'SYMM -y, x, z\n', 'SYMM y, -x, z\n',
                                           'SYMM -x, -y, z+0.5\n', 'SYMM -y, -z, x+0.5\n', 'SYMM y, x, -z\n',
                                           'SYMM z, x, y\n', 'SYMM x, z, -y\n', 'SYMM x, -y, -z+0.5\n',
                                           'SYMM -z, y, x\n', 'SYMM -z, -x, y+0.5\n', 'SYMM -x, y, -z\n',
                                           'SYMM -y, z, -x\n', 'SYMM z, y, -x\n', 'SYMM -y, -x, -z+0.5\n',
                                           'SYMM z+0.5, -x, -y\n', 'SYMM -z, x, -y\n', 'SYMM -z, -x, y\n']}

dictio_space_groups[210] = {'symbol': 'F 41 3 2', 'short_symbol': 'F4132', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    3: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    4: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    5: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    6: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    9: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    10: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    11: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    12: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    13: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    14: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    15: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    16: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    17: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    18: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    19: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    20: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    21: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    22: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    23: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    24: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]},
    25: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    26: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    27: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    28: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    29: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    30: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    31: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    32: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    33: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    34: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    35: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    36: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    37: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    38: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    39: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    40: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    41: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    42: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    43: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    44: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    45: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    46: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    47: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    48: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]},
    49: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    50: {'tra': [3 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    51: {'tra': [3 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    52: {'tra': [3 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    53: {'tra': [3 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    54: {'tra': [3 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    55: {'tra': [3 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    56: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    57: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    58: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    59: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    60: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    61: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    62: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    63: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    64: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    65: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    66: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    67: {'tra': [3 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    68: {'tra': [3 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    69: {'tra': [3 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    70: {'tra': [3 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    71: {'tra': [3 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    72: {'tra': [3 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]},
    73: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    74: {'tra': [3 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    75: {'tra': [3 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    76: {'tra': [3 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    77: {'tra': [3 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    78: {'tra': [3 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    79: {'tra': [3 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    80: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    81: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    82: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    83: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    84: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    85: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    86: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    87: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    88: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    89: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    90: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    91: {'tra': [3 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    92: {'tra': [3 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    93: {'tra': [3 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    94: {'tra': [3 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    95: {'tra': [3 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    96: {'tra': [3 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 4,
                            'symm_cards': ['SYMM -y+0.25, -x+0.25, -z+1.25\n', 'SYMM -z+0.75, y+0.75, x+0.25\n',
                                           'SYMM -x, -y+0.5, z+0.5\n', 'SYMM x+0.5, -y, -z+0.5\n',
                                           'SYMM -y+1.25, -x+0.25, -z+0.25\n', 'SYMM -z, -x+0.5, y+0.5\n',
                                           'SYMM z, x, y\n', 'SYMM z+0.75, y+0.25, -x+0.75\n',
                                           'SYMM -y+0.75, x+0.75, z+0.25\n', 'SYMM y+1.25, -x+0.75, z+0.75\n',
                                           'SYMM -z+0.5, x+0.5, -y\n', 'SYMM -y, -z+0.5, x+0.5\n',
                                           'SYMM y+0.75, x+0.25, -z+0.75\n', 'SYMM -x+0.5, y+0.5, -z\n',
                                           'SYMM y, z, x\n', 'SYMM -y+0.5, z+0.5, -x\n',
                                           'SYMM x+0.75, z+0.25, -y+0.75\n', 'SYMM z+0.5, -x, -y+0.5\n']}

dictio_space_groups[211] = {'symbol': 'I 4 3 2', 'short_symbol': 'I432', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    3: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    4: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    5: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    6: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    9: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    10: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    11: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    12: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    13: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    14: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    15: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    16: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    17: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    18: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    19: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    20: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    21: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    22: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    23: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    24: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]},
    25: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    26: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    27: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    28: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    29: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    30: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    31: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    32: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    33: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    34: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    35: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    36: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    37: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    38: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    39: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    40: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    41: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    42: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    43: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    44: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    45: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    46: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    47: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    48: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 2,
                            'symm_cards': ['SYMM y, z, x\n', 'SYMM -y, x, z\n', 'SYMM y, -x, z\n',
                                           'SYMM -x, -y, z+0.5\n', 'SYMM -y, -z, x+0.5\n', 'SYMM y, x, -z\n',
                                           'SYMM z, x, y\n', 'SYMM x, z, -y\n', 'SYMM x, -y, -z+0.5\n',
                                           'SYMM -z, y, x\n', 'SYMM -z, -x, y+0.5\n', 'SYMM -x, y, -z\n',
                                           'SYMM -y, z, -x\n', 'SYMM z, y, -x\n', 'SYMM -y, -x, -z+0.5\n',
                                           'SYMM z+0.5, -x, -y\n', 'SYMM -z, x, -y\n', 'SYMM -z, -x, y\n']}

dictio_space_groups[212] = {'symbol': 'P 43 3 2', 'short_symbol': 'P4332', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [3 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    3: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    4: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    5: {'tra': [3 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    6: {'tra': [3 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [3 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    9: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    10: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    11: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    12: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    13: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    14: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    15: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    16: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    17: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    18: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    19: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    20: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    21: {'tra': [3 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    22: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    23: {'tra': [3 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    24: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'point': '432', 'laue': 'm-3m',
                            'symm_cards': ['SYMM x+0.75, z+0.25, -y+0.75\n', 'SYMM -y+0.75, -x+0.75, -z+1.25\n',
                                           'SYMM -y+0.25, x+0.75, z+0.75\n', 'SYMM y-0.25, x+0.25, -z+0.75\n',
                                           'SYMM -z, x+0.5, -y+0.5\n', 'SYMM -y+0.75, -x+0.75, -z+0.25\n',
                                           'SYMM z, x, y\n', 'SYMM z+0.75, y+0.25, -x+0.75\n',
                                           'SYMM z+0.5, -x+0.5, -y\n', 'SYMM -x, y+0.5, -z+0.5\n',
                                           'SYMM -z+0.5, -x, y+0.5\n', 'SYMM x+0.5, -y+0.5, -z\n',
                                           'SYMM -y, z+0.5, -x+0.5\n', 'SYMM y, z, x\n',
                                           'SYMM -z+0.75, y+0.75, x+0.25\n', 'SYMM y+0.25, -x+0.25, z+0.25\n',
                                           'SYMM -y+0.5, -z, x+0.5\n', 'SYMM -x+0.5, -y, z+0.5\n']}

dictio_space_groups[213] = {'symbol': 'P 41 3 2', 'short_symbol': 'P4132', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [1 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    3: {'tra': [3 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    4: {'tra': [3 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    5: {'tra': [1 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    6: {'tra': [1 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [1 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    9: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    10: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    11: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    12: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    13: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    14: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    15: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    16: {'tra': [1 / 2.0, 1 / 2.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    17: {'tra': [0.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    18: {'tra': [1 / 2.0, 0.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    19: {'tra': [3 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    20: {'tra': [3 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    21: {'tra': [1 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    22: {'tra': [3 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    23: {'tra': [1 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    24: {'tra': [3 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0], [1 / 2.0, 1 / 2.0, 1 / 2.0]], 'polar': False, 'latt': 1,
                            'point': '432', 'laue': 'm-3m',
                            'symm_cards': ['SYMM x+0.25, z+0.75, -y+0.25\n', 'SYMM y, z, x\n',
                                           'SYMM z+0.25, y+0.75, -x+0.25\n', 'SYMM -z, x+0.5, -y+0.5\n',
                                           'SYMM z, x, y\n', 'SYMM z+0.5, -x+0.5, -y\n', 'SYMM -x, y+0.5, -z+0.5\n',
                                           'SYMM y+0.75, -x+0.75, z+0.75\n', 'SYMM -z+0.5, -x, y+0.5\n',
                                           'SYMM x+0.5, -y+0.5, -z\n', 'SYMM -y, z+0.5, -x+0.5\n',
                                           'SYMM -y+0.25, -x+0.25, -z+0.75\n', 'SYMM -z+0.25, y+0.25, x+0.75\n',
                                           'SYMM -y+0.5, -z, x+0.5\n', 'SYMM -y+0.75, x+0.25, z+0.25\n',
                                           'SYMM y+0.25, x-0.25, -z+0.25\n', 'SYMM -x+0.5, -y, z+0.5\n']}

dictio_space_groups[214] = {'symbol': 'I 41 3 2', 'short_symbol': 'I4132', 'symops': {
    1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    2: {'tra': [1 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    3: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    4: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    5: {'tra': [1 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    6: {'tra': [1 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    7: {'tra': [1 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    8: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    9: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    10: {'tra': [0.0, 1 / 2.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    11: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    12: {'tra': [1 / 2.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    13: {'tra': [0.0, 1 / 2.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    14: {'tra': [1 / 2.0, 0.0, 0.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    15: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    16: {'tra': [0.0, 0.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    17: {'tra': [1 / 2.0, 0.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    18: {'tra': [0.0, 1 / 2.0, 0.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    19: {'tra': [1 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    20: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    21: {'tra': [1 / 4.0, 1 / 4.0, 3 / 4.0], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    22: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    23: {'tra': [1 / 4.0, 3 / 4.0, 1 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    24: {'tra': [1 / 4.0, 1 / 4.0, 1 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]},
    25: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
    26: {'tra': [3 / 4.0, 3 / 4.0, 0.625], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]},
    27: {'tra': [3 / 4.0, 0.625, 0.625], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0]]},
    28: {'tra': [3 / 4.0, 0.625, 0.625], 'rot': [[0.0, 0.0, 1.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0]]},
    29: {'tra': [3 / 4.0, 0.625, 3 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]},
    30: {'tra': [3 / 4.0, 0.625, 3 / 4.0], 'rot': [[0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    31: {'tra': [3 / 4.0, 3 / 4.0, 0.625], 'rot': [[0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]},
    32: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, 1.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    33: {'tra': [1 / 2.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.0]]},
    34: {'tra': [1 / 2.0, 1.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, -1.0], [1.0, 0.0, 0.0]]},
    35: {'tra': [1 / 2.0, 1 / 2.0, 1.0], 'rot': [[0.0, 0.0, 1.0], [-1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    36: {'tra': [1.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, -1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, 0.0, 0.0]]},
    37: {'tra': [1 / 2.0, 1.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]},
    38: {'tra': [1.0, 1 / 2.0, 1 / 2.0], 'rot': [[0.0, 0.0, -1.0], [1.0, 0.0, 0.0], [0.0, -1.0, 0.0]]},
    39: {'tra': [1 / 2.0, 1 / 2.0, 1.0], 'rot': [[0.0, 1.0, 0.0], [0.0, 0.0, -1.0], [-1.0, 0.0, 0.0]]},
    40: {'tra': [1 / 2.0, 1 / 2.0, 1.0], 'rot': [[1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]},
    41: {'tra': [1.0, 1 / 2.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, -1.0]]},
    42: {'tra': [1 / 2.0, 1.0, 1 / 2.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
    43: {'tra': [3 / 4.0, 0.625, 0.625], 'rot': [[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    44: {'tra': [3 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, -1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, -1.0]]},
    45: {'tra': [3 / 4.0, 3 / 4.0, 0.625], 'rot': [[0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0]]},
    46: {'tra': [3 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[0.0, 0.0, -1.0], [0.0, -1.0, 0.0], [-1.0, 0.0, 0.0]]},
    47: {'tra': [3 / 4.0, 0.625, 3 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 1.0, 0.0]]},
    48: {'tra': [3 / 4.0, 3 / 4.0, 3 / 4.0], 'rot': [[-1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, -1.0, 0.0]]}},
                            'origins_list': [[0.0, 0.0, 0.0]], 'polar': False, 'latt': 2,
                            'point': '432', 'laue': 'm-3m',
                            'symm_cards': ['SYMM x+0.25, z+0.75, -y+0.25\n', 'SYMM y, z, x\n',
                                           'SYMM z+0.25, y+0.75, -x+0.25\n', 'SYMM -z, x+0.5, -y+0.5\n',
                                           'SYMM z, x, y\n', 'SYMM z+0.5, -x+0.5, -y\n', 'SYMM -x, y+0.5, -z+0.5\n',
                                           'SYMM y+0.75, -x+0.75, z+0.75\n', 'SYMM -z+0.5, -x, y+0.5\n',
                                           'SYMM x+0.5, -y+0.5, -z\n', 'SYMM -y, z+0.5, -x+0.5\n',
                                           'SYMM -y+0.25, -x+0.25, -z+0.75\n', 'SYMM -z+0.25, y+0.25, x+0.75\n',
                                           'SYMM -y+0.5, -z, x+0.5\n', 'SYMM -y+0.75, x+0.25, z+0.25\n',
                                           'SYMM y+0.25, x-0.25, -z+0.25\n', 'SYMM -x+0.5, -y, z+0.5\n']}


# Functions

#@timing
def add_cryst_card(cryst_card, path_pdb): #NOTE: Maybe should be moved to Bioinformatics.py
    """ Add a cryst1 record to a pdb file

    Args:
        cryst_card (str): cryst1 record
        path_pdb (str): path to the pdb file to modify. Note that it will be overwritten

    Returns:
        The return value. True for success, False otherwise.
    
    """
    try:
        file_pdb = open(path_pdb, 'r')
        content_pdb = file_pdb.read()
        file_pdb.close()
        new_file = open(path_pdb, 'w')  # Overwrite and put CRYST card
        new_file.write(cryst_card + "\n")
        new_file.write(content_pdb)
        new_file.close()
        return True
    except:
        print 'Something went wrong adding the cryst1 record to the pdb at',path_pdb
        return False


#@timing
def apply_origin_shift_and_compute_wMPE_and_CC(n_reflections, symops, array_ref, array_miller_indices, array_f_sigf,
                                               current_array, current_weights, array_evalues, array_aux, sg_number,
                                               f_fom):
    """

    :param n_reflections:
    :type n_reflections:
    :param symops:
    :type symops:
    :param array_ref:
    :type array_ref:
    :param array_miller_indices:
    :type array_miller_indices:
    :param array_f_sigf:
    :type array_f_sigf:
    :param current_array:
    :type current_array:
    :param current_weights:
    :type current_weights:
    :param array_evalues:
    :type array_evalues:
    :param array_aux:
    :type array_aux:
    :param sg_number:
    :type sg_number:
    :param f_fom:
    :type f_fom:
    :return:
    :rtype:
    """

    def single_polar_axis(np, ns, shiftx, shifty, shiftz, n_reflections, array_ref, array_miller_indices,
                          array_f_sigf, current_array, current_weights, array_evalues,f_fom):
        """Computes the best origin shift between two given phase sets for polar space groups

        Supported space groups:
        (P2,P21,C2,A2,I2) --> polar direction is B
        (P4,P41,P42,P43,I4,I41) --> polar direction is C
        (P3,P31,P32) --> polar direction is C
        (P6,P61,P62,P63,P64,P65,R3:H) --> polar direction is C
        (R3) --> polar direction is A+B+C

        :param np: polar direction indicator
        :type np: int
        :param ns: number of origin shifts to test
        :type ns: int
        :param shiftx: shift in x direction
        :type shiftx: float
        :param shifty: shift in y direction
        :type shifty: float
        :param shiftz: shift in z direction
        :type shiftz: float
        :param n_reflections: number of reflections in both phs files
        :type n_reflections: int
        :param array_ref:
        :type array_ref: list
        :param array_miller_indices: sorted miller indices list
        :type array_miller_indices: list
        :param array_f_sigf:
        :type array_f_sigf: list
        :param current_array:
        :type current_array: list
        :param current_weights:
        :type current_weights: list
        :param array_evalues:
        :type array_evalues: list
        :param f_fom: If True, F-weighted MPD will be computed, if False, E-value weighted MPD
        :type f_fom: bool
        :return:
        :rtype:
        """

        # Use first layer to get initial polar shift
        tm = [-99999.0 for _ in range(n_reflections)]
        for i in xrange(n_reflections):
            if array_ref[i][1] < -998.0 or current_array[i][1] < -998.0:
                continue
            l = array_miller_indices[i][0]  # Polar direction A?
            if np == 2:
                l = array_miller_indices[i][1]  # Polar direction B
            elif np == 3:
                l = array_miller_indices[i][2]  # Polar direction C
            elif np == 4:
                l = array_miller_indices[i][0] + array_miller_indices[i][1] + array_miller_indices[i][
                    2]  # Polar direction A+B+C
            #else:
            tm[i] = int(l)  # Save the indexes of the polar directions
        for n in xrange(0, ns):  # Iterate over all possible shifts considering the non polar directions variations
            r = 0.0
            s = 0.0
            j = 0
            for i in xrange(n_reflections):
                if int(abs(tm[i])) != 1:
                    continue
                y = tm[i] * 0.0174533 * (array_ref[i][1] - 360 * (
                int(array_miller_indices[i][0]) * shiftx[n] + int(array_miller_indices[i][1]) * shifty[n] + int(
                    array_miller_indices[i][2]) * shiftz[n]) - current_array[i][1])
                r = r + numpy.cos(y) * current_array[i][0]
                s = s + numpy.sin(y) * current_array[i][0]
                j = j + 1
            # if j == 0:
            #     print "Sorry, no reflection with h=1 or -1 was found"
            #     # deallocate?
            #     #sys.exit(0)
            t = 0.1591549 * numpy.arctan2(s, r)
            m = 1
            for nj in xrange(10):
                v = 0.0
                w = 0.0
                for i in xrange(n_reflections):
                    if int(abs(tm[i])) > m:
                        continue
                    v = v + tm[i] * (((999.5 + 0.002777778 * (array_ref[i][1] - current_array[i][1]) - t * tm[i] - int(
                        array_miller_indices[i][0]) * shiftx[n] - int(array_miller_indices[i][1]) * shifty[n] - int(
                        array_miller_indices[i][2]) * shiftz[n]) % 1.0) - 0.5) * math.pow(current_array[i][0], 2)
                    w = w + math.pow((current_array[i][0] * tm[i]), 2)
                if w < 0.1:  # break en el caso de convergencia e ir a calcular ya el mapcc y el wmpe
                    break
                t = t + v / w
                m = m + m
            s = 0.0
            u = 0.0
            sumatorio_sf = 0
            sumatorio_wwsf = 0
            num_mapcc = 0.0
            for i in xrange(n_reflections):
                if f_fom == True:
                    num_mapcc = num_mapcc + \
                                (array_f_sigf[i][0] ** 2) * \
                                numpy.cos(0.0174533 * (abs(((999.5 + 0.002777778 * (array_ref[i][1] -
                                                                                    current_array[i][1])
                                                             - (t * tm[i])
                                                             - (int(array_miller_indices[i][0]) * shiftx[n])
                                                             - (int(array_miller_indices[i][1]) * shifty[n])
                                                             - (int(array_miller_indices[i][2]) * shiftz[n]))
                                                            % 1.0) - 0.5)
                                                       * current_array[i][0]))
                elif f_fom == False:
                    num_mapcc = num_mapcc + \
                                (array_evalues[i] ** 2) * \
                                numpy.cos(0.0174533 * (abs(((999.5 + 0.002777778 * (array_ref[i][1] -
                                                                                    current_array[i][1])
                                                             - (t * tm[i])
                                                             - int(array_miller_indices[i][0]) * shiftx[n]
                                                             - int(array_miller_indices[i][1]) * shifty[n]
                                                             - int(array_miller_indices[i][2]) * shiftz[n])
                                                            % 1.0) - 0.5)
                                                       * current_array[i][0]))
                if f_fom == True:
                    sumatorio_sf = sumatorio_sf + math.pow(array_f_sigf[i][0], 2)
                    sumatorio_wwsf = sumatorio_wwsf + (
                    math.pow(array_f_sigf[i][0], 2) * math.pow(current_weights[i], 2))
                elif f_fom == False:
                    sumatorio_sf = sumatorio_sf + math.pow(array_evalues[i], 2)
                    sumatorio_wwsf = sumatorio_wwsf + (math.pow(array_evalues[i], 2) * math.pow(current_weights[i], 2))
                if tm[i] < -99998:
                    continue
                s = s + abs(((999.5 + 0.002777778 * (array_ref[i][1] - current_array[i][1]) - t * tm[i] - int(
                    array_miller_indices[i][0]) * shiftx[n] - int(array_miller_indices[i][1]) * shifty[n] - int(
                    array_miller_indices[i][2]) * shiftz[n]) % 1.0) - 0.5) * current_array[i][0]
                u = u + current_array[i][0]
            mpe = 360 * s / u

            # NOTE: ISSUE in correctly computing mapCC in polar space groups, check
            mapcc = num_mapcc / sumatorio_sf
            if np == 1 or np == 4:
                shiftx[n] = shiftx[n] + t
            elif np == 2 or np == 4:
                shifty[n] = shifty[n] + t
            elif np == 2 or np == 4:
                shiftz[n] = shiftz[n] + t
            list_mapcc.append((mapcc, [shiftx[n], shifty[n], shiftz[n]]))
            list_wmpe.append((mpe, [shiftx[n], shifty[n], shiftz[n]]))  # Save MPE and origin shift associated
        # After ns iterations, we should have a list with all wmpe calculated for the different origin shifts
        list_wmpe.sort(key=lambda x: x[0], reverse=False)
        list_mapcc.sort(key=lambda x: x[0], reverse=True)
        return list_wmpe, list_mapcc

    #@timing
    def triclinic_polar_axes(n_reflections, symops, array_ref, array_miller_indices, array_f_sigf, current_array,
                             current_weights, array_evalues, array_aux, sg_number, f_fom):
        #print "Currently,this space group is not supported"
        #sys.exit()
        array_MPE = [0.0 for _ in range(17)]
        # Set up coefficients for triclinic case (3 polar directions, slow)
        p = 0.0
        q = 0.0
        for i in xrange(n_reflections):
            if array_ref[i][1] < -998.0 or current_array[i][1] < -998.0:
                continue
            array_MPE[16] = array_MPE[16] + current_array[i][0]  # wMPE denominator
            x = int(array_miller_indices[i][0])
            y = int(array_miller_indices[i][1])
            z = int(array_miller_indices[i][2])
            array_MPE[3] = array_MPE[3] + z * x * current_array[i][0]
            array_MPE[4] = array_MPE[4] + z * y * current_array[i][0]
            array_MPE[5] = array_MPE[5] + math.pow(z, 2) * current_array[i][0]
            array_MPE[6] = array_MPE[6] + math.pow(x, 2) * current_array[i][0]
            array_MPE[7] = array_MPE[7] + x * y * current_array[i][0]
            array_MPE[8] = array_MPE[8] + math.pow(x, 2) * current_array[i][0]
            if array_miller_indices[i][0] != 0:
                continue
            array_MPE[0] = array_MPE[0] + math.pow(y, 2) * current_array[i][0]
            array_MPE[1] = array_MPE[1] + y * z * current_array[i][0]
            array_MPE[2] = array_MPE[2] + math.pow(z, 2) * current_array[i][0]
            p = max(p, abs(y))
            q = max(p, abs(z))
        z = array_MPE[0] * array_MPE[2] - math.pow(array_MPE[1], 2)
        array_MPE[0] = array_MPE[0] / z
        array_MPE[1] = array_MPE[1] / z
        array_MPE[2] = array_MPE[2] / z
        array_MPE[9] = array_MPE[8] * array_MPE[5] - math.pow(array_MPE[4], 2)
        array_MPE[10] = array_MPE[3] * array_MPE[4] - array_MPE[7] * array_MPE[5]
        array_MPE[11] = array_MPE[7] * array_MPE[4] - array_MPE[8] * array_MPE[3]
        array_MPE[12] = array_MPE[6] * array_MPE[5] - math.pow(array_MPE[3], 2)
        array_MPE[13] = array_MPE[7] * array_MPE[3] - array_MPE[6] * array_MPE[4]
        array_MPE[14] = array_MPE[6] * array_MPE[8] - math.pow(array_MPE[7], 2)
        z = array_MPE[6] * array_MPE[9] + array_MPE[7] * array_MPE[10] + array_MPE[3] * array_MPE[11]
        for i in xrange(9, 16):
            array_MPE[i] = array_MPE[7] / z
        # Find initial delta(y) and delta(z) using h=0 reflections
        mi = int(20 * p * q + 1.1)
        jk = 0
        jr = 0
        # print 'mi',mi
        for nm in xrange(1, mi + 1):
            q = 9 * math.pow(10, 9)
            jk = ((jk * 3613 + 45289) % 214326)
            ey = 6.2831853 * 4.6657895 * math.pow(10, -6)
            jr = ((jr * 1366 + 150889) % 714025)
            ez = 6.2831853 * 4.6657895 * math.pow(10, -6)
            testvar = False
            while testvar == False:
                p = 0.0
                r = 0.0
                s = 0.0
                for i in xrange(n_reflections):
                    if array_ref[i][1] < -998.0 or current_array[i][1] < -998.0 or array_miller_indices[i][0] != 0:
                        continue
                    y = int(array_miller_indices[i][1])
                    z = int(array_miller_indices[i][2])
                    x = (999.5 + 0.002777778 * (array_ref[i][1] - current_array[i][1]) - y * ey - z * ez % 1.0) - 0.5
                    u = x * current_array[i][0]
                    p = p + x * u
                    r = r + y * u
                    s = s + z * u
                if p > (q - 0.0001):
                    testvar = True
                else:
                    q = p
                    ey = ey + r * array_MPE[2] - s * array_MPE[1]
                    ez = ez + r * array_MPE[0] - s * array_MPE[1]
            # Use h=1 reflections to find initial delta(x)
            r = 0.0
            s = 0.0
            for i in xrange(n_reflections):
                if array_ref[i][1] < -998.0 or current_array[i][1] < -998.0 or abs(array_miller_indices[i][0]) != 1:
                    continue
                y = array_miller_indices[i][1]
                z = array_miller_indices[i][2]
                x = 0.0174533 * (
                array_ref[i][1] - int(array_miller_indices[i][0]) * (360 * (y * ey + z * ez) + current_array[i][1]))
                r = r + numpy.cos(x)
                s = s + numpy.sin(x)
            ex = 0.1591549 * numpy.arctan2(s,
                                           r)  # x, s and r are in radians, needed for numpy, so we convert back to revolutions/degrees
            # Refine origin shift using all reflections
            for nj in xrange(1, 5):
                u = 0.0
                v = 0.0
                w = 0.0
                for i in range(n_reflections):
                    if array_ref[i][1] < -998.0 or current_array[i][1] < -998.0:
                        continue
                    x = int(array_miller_indices[i][0])
                    y = int(array_miller_indices[i][1])
                    z = int(array_miller_indices[i][2])
                    q = ((999.5 + 0.002777778 * (
                    array_ref[i][1] - current_array[i][1]) - x * ex - y * ey - z * ez % 1.0) - 0.5) * current_array[i][
                            0]
                    u = u + x * q
                    v = v + y * q
                    w = w + z * q
                ex = ex + u * array_MPE[9] + v * array_MPE[10] + w * array_MPE[11]
                ey = ex + u * array_MPE[10] + v * array_MPE[12] + w * array_MPE[13]
                ez = ex + u * array_MPE[11] + v * array_MPE[13] + w * array_MPE[14]
            # Calculate E-weighted mean phase error
            s = 0.0
            for i in xrange(n_reflections):
                if array_ref[i][1] < -998.0 or current_array[i][1] < -998.0:
                    continue
                q = abs((999.5 + 0.002777778 * (array_ref[i][1] - current_array[i][1]) - int(
                    array_miller_indices[i][0]) * ex - int(array_ref[i][1]) * ey - int(
                    array_ref[i][2]) * ez % 1.0) - 0.5)
                s = s + q * current_array[i][
                    0]  # currrent_array ya tiene el weigth for f o por e aplicado
            s = 360 * s / array_MPE[17]
            mpe = s
            shiftx = ex
            shifty = ey
            shiftz = ez
            list_wmpe.append((mpe, [shiftx, shifty, shiftz]))  # Save MPE and origin shift associated
        # After nm iterations, we should have a list with all wmpe calculated for the different origin shifts
        list_wmpe.sort(key=lambda x: x[0], reverse=False)
        # TODO: Calculate and save also mapCC
        list_mapcc = []  # I return it empty for now
        return list_wmpe, list_mapcc

    ########
    # Main #
    ########
    polar, origins = get_origins_from_sg_dictionary(sg_number)
    list_wmpe = []
    list_mapcc = []
    ##########################
    # Polar space group case #
    ##########################
    if polar == True:
        shiftx = [0.0 for _ in range(len(origins))]
        shifty = [0.0 for _ in range(len(origins))]
        shiftz = [0.0 for _ in range(len(origins))]
        for indori,ori in enumerate(origins):
            # polar_directions = [True if isinstance(ori[i],str) else False for i,_ in enumerate(ori)]
            if not isinstance(ori[0],str):
                shiftx[indori] = ori[0]
            else:
                shiftx[indori] = 0.0 # then we set to 0.0 the value for the polar direction A
            if not isinstance(ori[1],str):
                shifty[indori] = ori[1]
            else:
                shifty[indori] = 0.0 # then we set to 0.0 the value for the polar direction B
            if not isinstance(ori[2], str):
                shiftz[indori] = ori[2]
            else:
                shiftz[indori] = 0.0  # then we set to 0.0 the value for the polar direction C


        # Use the LATT information to get the polar direction
        # P -> 1 # I -> 2 # R -> 3 # F -> 4 # A -> 5 # B -> 6 # C -> 7

        ns = len(shiftx)  # allowed origin shifts
        nl = dictio_space_groups[sg_number]["latt"]  # lattice type
        np = None
        if sg_number in [3,4,5,'I2']: # B polar axis
            np = 2
            return single_polar_axis(np=np, ns=ns, shiftx=shiftx, shifty=shifty, shiftz=shiftz,
                              n_reflections=n_reflections, array_ref=array_ref,
                              array_miller_indices=array_miller_indices,
                              array_f_sigf=array_f_sigf, current_array=current_array,
                              current_weights=current_weights, array_evalues=array_evalues, f_fom=f_fom)
        elif sg_number=='R 3': # Rhomboedral, A+B+C polar axis
            np = 4
            return single_polar_axis(np=np, ns=ns, shiftx=shiftx, shifty=shifty, shiftz=shiftz,
                              n_reflections=n_reflections, array_ref=array_ref,
                              array_miller_indices=array_miller_indices,
                              array_f_sigf=array_f_sigf, current_array=current_array,
                              current_weights=current_weights, array_evalues=array_evalues, f_fom=f_fom)
        elif sg_number in [1,'A1','B1','C1','I1','F1']: # This will go to the triclinic case
            print 'Not yet implemented'
            sys.exit(0)
            return triclinic_polar_axes(n_reflections, symops, array_ref, array_miller_indices,
                                 array_f_sigf, current_array, current_weights, array_evalues,
                                 array_aux, sg_number, f_fom)

        else: # Then it must be some of the C polar axis space group
            np = 3
            return single_polar_axis(np=np, ns=ns, shiftx=shiftx, shifty=shifty, shiftz=shiftz,
                              n_reflections=n_reflections, array_ref=array_ref,
                              array_miller_indices=array_miller_indices,
                              array_f_sigf=array_f_sigf, current_array=current_array,
                              current_weights=current_weights, array_evalues=array_evalues, f_fom=f_fom)

    ##############################
    # Non-polar space group case #
    ##############################
    elif polar == False:
        # Non polar space groups
        array_num_mapcc = [0.0 for _ in range(
            17)]  # Holds summatory over the product structure factors or normalized structure factors, the weight of the current reflection and the cosine of deltaphi (phase difference)
        sumatorio_sf = 0  # Holds summatory over the product structure factors or normalized structure factors and the weight for the current phs and reflection
        sumatorio_wwsf = 0  # Holds summatory over product structure factors or normalized structure factors and the squared weight for the current phs and reflection
        array_MPE = [0.0 for _ in range(17)]
        for i in xrange(n_reflections):
            if array_ref[i][1] < -998.0 or current_array[i][1] < -998.0:
                # print "He entrado en la condicin de las reflexiones ausentes"
                continue
            if f_fom == True:
                sumatorio_sf = sumatorio_sf + math.pow(array_f_sigf[i][0], 2)
                sumatorio_wwsf = sumatorio_wwsf + (math.pow(array_f_sigf[i][0], 2) * math.pow(current_weights[i], 2))
            elif f_fom == False:
                sumatorio_sf = sumatorio_sf + math.pow(array_evalues[i], 2)
                sumatorio_wwsf = sumatorio_wwsf + (math.pow(array_evalues[i], 2) * math.pow(current_weights[i], 2))
            for o in xrange(len(origins)):
                t = array_ref[i][1] + 360.0 * (
                origins[o][0] * (array_miller_indices[i][0] % 12) + origins[o][1] * (array_miller_indices[i][1] % 12) +
                origins[o][2] * (
                array_miller_indices[i][2] % 12)) + 9900.0  # 9900 es 27 veces y media una circunferencia
                # current_array[i][0] ya viene con el weigth aplicado para el MPE (o sea, corresponde a weigth * E o weigth * F)
                array_MPE[o] = array_MPE[o] + abs(((t - current_array[i][1]) % 360.0) - 180.0) * current_array[i][
                    0]  # wMPE numerator
                if f_fom == True:
                    # array_num_mapcc[o]=array_num_mapcc[o]+current_weights[i]*math.pow(array_f_sigf[i][0],2)*numpy.cos(0.0174533*(abs(((t-current_array[i][1])%360.0)-180.0)))
                    # NOTE: Testing correct formula for MAPCC calculation
                    array_num_mapcc[o] = array_num_mapcc[o] + math.pow(array_f_sigf[i][0], 2) * numpy.cos(
                        0.0174533 * (abs(((t - current_array[i][1]) % 360.0) - 180.0)))
                elif f_fom == False:
                    array_num_mapcc[o] = array_num_mapcc[o] + current_weights[i] * math.pow(array_evalues[i],
                                                                                            2) * numpy.cos(
                        0.0174533 * abs(((t - current_array[i][1]) % 360.0) - 180.0))
            array_MPE[16] = array_MPE[16] + current_array[i][0]  # wMPE denominator
        for o in xrange(len(origins)):
            wmpe = array_MPE[o] / array_MPE[16]
            list_wmpe.append((wmpe, origins[o]))

            # map_cc= array_num_mapcc[o]/(math.sqrt(sumatorio_sf)*math.sqrt(sumatorio_wwsf))
            # NOTE: Testing correct formula for MAPCC calculation
            map_cc = array_num_mapcc[o] / sumatorio_sf
            list_mapcc.append((map_cc, origins[o]))
            # print 'Testing origin',origins[o],'wMPE',wmpe,'mapCC',map_cc
        # print '*******************************************'
        list_wmpe.sort(key=lambda x: x[0], reverse=False)
        list_mapcc.sort(key=lambda x: x[0], reverse=True)
        return list_wmpe, list_mapcc

def check_if_gimble(type_run,wd):
    if type_run=='BORGES':
        if os.path.exists(os.path.join(wd,'8_GIMBLE')):
           gimble=True
        else:
           gimble=False
    else:
        gimble=False
    return gimble

def check_dir_or_make_it(path_dir,remove=True):
    try:
        os.mkdir(path_dir)
    except OSError:
        exctype, value = sys.exc_info()[:2]
        if str(value).startswith("[Errno 17] File exists:") and remove==True:  # Then the folder exists
            print "\n ",path_dir," folder was already present. Files will be removed to start from the scratch"
            # NOTE: This is what makes sense if we already have the phs created and we just need to put them there.
            shutil.rmtree(path_dir, ignore_errors=True)
            os.mkdir(path_dir)
        else:
            print "\n ", path_dir, " folder was already present"



def check_path_phstat(path_phstat):
    # Testing the fortran executable for the phase combination
    logging.info('\nThe given path for phstat is '+path_phstat)
    if not os.path.exists(path_phstat):
        logging.critical('\nThe path given to the phstat executable does not exist')
        return False
    else:
        # Check anyway that the program works
        try:
            p = subprocess.Popen(path_phstat, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE)
            complete_output, errors = p.communicate()
            if len(complete_output) > 0:
                logging.info('\nphstat was run succesfully')
                return True
            else:
                logging.error('\nSorry, there is some error with the path given as phstat_executable')
                return False
        except:
            logging.critical('\nSorry, there is some error with the path given as phstat_executable')
            return False


def call_phstat_for_clustering(name_phstat, path_phstat, wd, resolution=2.0, seed=0, tolerance=75, n_cycles=3):
    """Given the arguments for a command line call to phstat, launch it to clusterize. Defaults are the same as in phstat.
    Using a single seed. There is another function, clustering_under_a_tolerance(), that tries with all possible seeds for a given .ls """
    ls_filename = name_phstat + ".ls"
    ins_filename = name_phstat + ".ins"
    if not (((os.path.exists(os.path.join(wd, ls_filename))) and (os.path.exists(os.path.join(wd, ins_filename))))):
        sys.exit("\nAn error has occurred. Please make sure that you have provide a .ls and a .ins file")
    command_line = []
    command_line.append(path_phstat)
    command_line.append(name_phstat)
    arguments = ["-r" + str(resolution), "-s" + str(seed), "-t" + str(tolerance), "-c" + str(n_cycles)]
    print "\n Arguments for this call: " + str(arguments)
    for i in range(len(arguments)):
        command_line.append(arguments[i])
    print "\nCommand line for this call", ' '.join(command_line)
    try:
        p = subprocess.Popen(command_line, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                             cwd=wd)
        complete_output, errors = p.communicate()
        return complete_output
    except Exception:
        exctype, value = sys.exc_info()[:2]
        print "\n An error has occurred:\n" + str(exctype) + "\n" + str(value)


# DUPLICATED FROM PREVIOUS ONE, but will not return any ouput, and other function or the main process should take care of the number of them and their identity
# TODO: fundir con la anterior y poner una variable que diga si es en paralelo o no
def call_phstat_for_clustering_in_parallel(args):
    name_phstat, wd, path_phstat, resolution, seed, tolerance, n_cycles, orisub, weight, oricheck, mapcc = args
    # Check if the correct files are there
    ls_filename = name_phstat + ".ls"
    pda_filename = name_phstat + ".pda"
    if not (((os.path.exists(os.path.join(wd, ls_filename))) and (os.path.exists(os.path.join(wd, pda_filename))))):
        sys.exit("\nAn error has occurred. Please make sure that you have provide a .ls and a .pda file")
    # If everything is OK, we continue and run phstat with the given command line
    command_line = []
    command_line.append(path_phstat)
    # NOTE change name phstat to get it to its shortest version so that FORTRAN will accept it
    #name_phstat = os.path.split(name_phstat)[1]
    path_name_phstat = os.path.join(wd, name_phstat)
    file_out = open(path_name_phstat+'.out','w')
    #command_line.append(path_name_phstat)
    command_line.append(name_phstat)
    arguments = ["-r" + str(resolution), "-s" + str(seed), "-t" + str(tolerance), "-c" + str(n_cycles)]
    if weight=='e':
        arguments.append('-e')
    if orisub=='sxosfft':
        arguments.append('-o')
    if not oricheck:
        arguments.append('-q')
    if mapcc:
        arguments.append('-k')
    for i in range(len(arguments)):
        command_line.append(arguments[i])
    try:
        print "\nCommand line used in phstat", ' '.join(command_line)
        p = subprocess.Popen(command_line, stdin=subprocess.PIPE, stdout=file_out, stderr=subprocess.PIPE,
                             cwd=wd)
    except Exception:
        exctype, value = sys.exc_info()[:2]
        print "\n An error has occurred:\n" + str(exctype) + "\n" + str(value)
        print "CHECK YOUR PHSTAT PATH IN YOUR BOR FILE!!"
        return None, None

# Yet another duplication because to do it in a pool I need that the process finishes
def call_phstat_for_clustering_in_parallel_pool(args):
    name_phstat, wd, path_phstat, resolution, seed, tolerance, n_cycles, orisub, weight, oricheck, mapcc = args
    # Check if the correct files are there
    ls_filename = name_phstat + ".ls"
    pda_filename = name_phstat + ".pda"
    if not (((os.path.exists(os.path.join(wd, ls_filename))) and (os.path.exists(os.path.join(wd, pda_filename))))):
        sys.exit("\nAn error has occurred. Please make sure that you have provide a .ls and a .pda file")
    # If everything is OK, we continue and run phstat with the given command line
    command_line = []
    command_line.append(path_phstat)
    name_phstat = os.path.split(name_phstat)[1]
    path_name_phstat = os.path.join(wd, name_phstat)
    file_out = open(path_name_phstat+'.out','w')
    command_line.append(name_phstat)
    arguments = ["-r" + str(resolution), "-s" + str(seed), "-t" + str(tolerance), "-c" + str(n_cycles)]
    if weight=='e':
        arguments.append('-e')
    if orisub=='sxosfft':
        arguments.append('-o')
    if not oricheck:
        arguments.append('-q')
    if mapcc:
        arguments.append('-k')
    for i in range(len(arguments)):
        command_line.append(arguments[i])
    try:
        print "\nCommand line used in phstat", ' '.join(command_line)
        p = subprocess.Popen(command_line, stdin=subprocess.PIPE, stdout=file_out, stderr=subprocess.PIPE,
                             cwd=wd)
        complete_output, errors = p.communicate()
        # Move the file to change its name and make it consistent with the convention (avoid putting _0 or the nseed)
        os.rename(path_name_phstat + '_'+str(seed)+'.phi', path_name_phstat + ".phi")
        return complete_output,errors
    except Exception:
        exctype, value = sys.exc_info()[:2]
        print "\n An error has occurred:\n" + str(exctype) + "\n" + str(value)
        #print "CHECK YOUR PHSTAT PATH IN YOUR BOR FILE!!"
        return None, None

# NOTE CM this is the one which should substitute all the others at the end.
def call_phstat_print_for_clustering_global(name_phstat, wd, path_phstat, resolution=2.0, seed=0, tolerance=75, n_cycles=3,
                                     orisub='sxos',weight='f',oricheck=True, mapcc=False):
    """

    :param name_phstat:
    :param wd:
    :param path_phstat:
    :param resolution:
    :param seed:
    :param tolerance:
    :param n_cycles:
    :param orisub:
    :param weight:
    :param oricheck:
    :param mapcc:
    :return:
    """
    # Check if the correct files are there
    ls_filename = name_phstat + ".ls"
    pda_filename = name_phstat + ".pda"
    if not (((os.path.exists(os.path.join(wd, ls_filename))) and (os.path.exists(os.path.join(wd, pda_filename))))):
        sys.exit("\nAn error has occurred. Please make sure that you have provide a .ls and a .pda file")
    # If everything is OK, we continue and run phstat with the given command line
    command_line = []
    command_line.append(path_phstat)
    name_phstat = os.path.split(name_phstat)[1]
    path_name_phstat = os.path.join(wd, name_phstat)
    #command_line.append(path_name_phstat)
    command_line.append(name_phstat)
    arguments = ["-r" + str(resolution), "-s" + str(seed), "-t" + str(tolerance), "-c" + str(n_cycles)]
    if weight=='e':
        arguments.append('-e')
    if orisub=='sxosfft':
        arguments.append('-o')
    if not oricheck:
        arguments.append('-q')
    if mapcc:
        arguments.append('-k')
    for i in range(len(arguments)):
        command_line.append(arguments[i])
    try:
        print "\nCommand line used in phstat", ' '.join(command_line)
        p = subprocess.Popen(command_line, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                             cwd=wd)
        complete_output, errors = p.communicate()
        # Move the file to change its name and make it consistent with the convention (avoid putting _0)
        # NOTE CM: now with multiseed with will not be _0 but the seed chosen
        #os.rename(path_name_phstat + '_0.phi', path_name_phstat + ".phi")
        return complete_output,errors
    except Exception:
        exctype, value = sys.exc_info()[:2]
        print "\n An error has occurred:\n" + str(exctype) + "\n" + str(value)
        return None,None

def call_phstat_print_for_clustering(name_phstat, wd, path_phstat, resolution=2.0, seed=0, tolerance=75, n_cycles=3,
                                     orisub='sxos',weight='f',oricheck=True, mapcc=False):
    """

    :param name_phstat:
    :type name_phstat:
    :param wd:
    :type wd:
    :param path_phstat:
    :type path_phstat:
    :param resolution:
    :type resolution:
    :param seed:
    :type seed:
    :param tolerance:
    :type tolerance:
    :param n_cycles:
    :type n_cycles:
    :param orisub: can be sxos or sxosfft
    :type orisub:
    :param weight: can be f or e
    :type weight:
    :return:
    :rtype:
    """
    # Check if the correct files are there
    ls_filename = name_phstat + ".ls"
    pda_filename = name_phstat + ".pda"
    if not (((os.path.exists(os.path.join(wd, ls_filename))) and (os.path.exists(os.path.join(wd, pda_filename))))):
        sys.exit("\nAn error has occurred. Please make sure that you have provide a .ls and a .pda file")
    # If everything is OK, we continue and run phstat with the given command line
    command_line = []
    command_line.append(path_phstat)
    # NOTE change name phstat to get it to its shortest version so that FORTRAN will accept it
    name_phstat = os.path.split(name_phstat)[1]

    path_name_phstat = os.path.join(wd, name_phstat)
    command_line.append(path_name_phstat)
    arguments = ["-r" + str(resolution), "-s" + str(seed), "-t" + str(tolerance), "-c" + str(n_cycles)]
    if weight=='e':
        arguments.append('-e')
    if orisub=='sxosfft':
        arguments.append('-o')
    if not oricheck:
        arguments.append('-q')
    if mapcc:
        arguments.append('-k')
    for i in range(len(arguments)):
        command_line.append(arguments[i])
    try:
        print "\nCommand line used in phstat", ' '.join(command_line)
        p = subprocess.Popen(command_line, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                             cwd=wd)
        complete_output, errors = p.communicate()
        # Move the file to change its name and make it consistent with the convention (avoid putting _0)
        os.rename(path_name_phstat + '_0.phi', path_name_phstat + ".phi")
        return complete_output,errors
    except Exception:
        exctype, value = sys.exc_info()[:2]
        print "\n An error has occurred:\n" + str(exctype) + "\n" + str(value)
        print "CHECK YOUR PHSTAT PATH IN YOUR BOR FILE!"
        return None,None

def call_phstat_print_for_clustering_parallel(args):
    name_phstat, wd, path_phstat, resolution, seed, tolerance, n_cycles,orisub, weight, oricheck, mapcc = args
    # Check if the correct files are there
    ls_filename = name_phstat + ".ls"
    pda_filename = name_phstat + ".pda"
    if not (((os.path.exists(os.path.join(wd, ls_filename))) and (os.path.exists(os.path.join(wd, pda_filename))))):
        sys.exit("\nAn error has occurred. Please make sure that you have provide a .ls and a .pda file")
    # If everything is OK, we continue and run phstat with the given command line
    command_line = []
    command_line.append(path_phstat)
    # NOTE change name phstat to get it to its shortest version so that FORTRAN will accept it
    name_phstat = os.path.split(name_phstat)[1]
    path_name_phstat = os.path.join(wd, name_phstat)
    file_out = open(path_name_phstat+'.out','w')
    command_line.append(path_name_phstat)
    arguments = ["-r" + str(resolution), "-s" + str(seed), "-t" + str(tolerance), "-c" + str(n_cycles)]
    if weight=='e':
        arguments.append('-e')
    if orisub=='sxosfft':
        arguments.append('-o')
    if not oricheck:
        arguments.append('-q')
    if mapcc:
        arguments.append('-k')
    for i in range(len(arguments)):
        command_line.append(arguments[i])
    try:
        print "\nCommand line used in phstat", ' '.join(command_line)
        p = subprocess.Popen(command_line, stdin=subprocess.PIPE, stdout=file_out, stderr=subprocess.PIPE,
                             cwd=wd)
    except Exception:
        exctype, value = sys.exc_info()[:2]
        print "\n An error has occurred:\n" + str(exctype) + "\n" + str(value)




def call_phstat_for_final_MPE(name_phstat, path_phstat, wd, resolution=1.0):
    """ This function calls phstat in order to calculate the MPE of a single .phs file. It returns this value. The phs, fcf and ins file with name_phstat should be already there"""
    # Check the files are really there
    current_wd = wd
    phs_filename = name_phstat + ".phs"
    fcf_filename = name_phstat + ".fcf"
    ins_filename = name_phstat + ".ins"
    if not (((os.path.exists(os.path.join(current_wd, phs_filename))) and (
    os.path.exists(os.path.join(current_wd, fcf_filename))) and (
    os.path.exists(os.path.join(current_wd, ins_filename))))):
        sys.exit(
            "\nAn error has occurred. Please make sure that you have provide a map .phs file, a .fcf and a .ins file. ")
    modelo = open(current_wd + name_phstat + ".ls", "w")
    modelo.write(name_phstat + ".phs")
    del modelo
    try:
        p = subprocess.Popen([path_phstat, name_phstat, "-f"], stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE, cwd=current_wd)
        memoria, err = p.communicate()
        print memoria
        v = memoria.split("\n")
        for k in range(len(v)):
            lineav = v[k]
            listav = lineav.split()
            if len(listav) >= 2 and listav[0] == "N" and listav[1] == "wMPE":
                wmpe = float(((v[k + 1]).split())[1])
                print "Final MPE between .phs and .fcf for " + str(name_phstat) + " is " + str(wmpe)
                return wmpe
    except Exception:
        exctype, value = sys.exc_info()[:2]
        print "\n An error has occurred:\n" + str(exctype) + "\n" + str(value)


def split_alixe_clusters(dictio_result):
    list_dictio_results = []
    for keyp in dictio_result.keys():
        if dictio_result[keyp]['ref_no_cluster'] == True:
            new_dictio_result = {}
            new_dictio_result[keyp] = copy.deepcopy(dictio_result[keyp])
            dictio_result = removeKeyDict(dictio_result, keyp)
            list_dictio_results.append(new_dictio_result)
    # Whatever left now, it should be the cluster
    if dictio_result:
        list_dictio_results.append(dictio_result)
    return list_dictio_results

def clustering_phstat_isa_under_a_tolerance(name_phstat, wd, path_phstat, tolerance=75, resolution=1.0, seed=0,
                                            n_cycles=3, orisub='sxos', weight='f',idrotclu='0', oricheck=True,
                                            mapcc=False):
    """ This function calls the fortran phstat that Isabel modified
     for clustering, and sequentially process the complete ls file.

    Requires both the .ls file and a .pdb file called like name_phstat.

    orisub can be 'sxos' or 'sxosfft' (apply or not flag -o to phstat. -o means fft
    weight can be 'f' or 'e'

    IMPORTANT: the phi files will be named as name_phstat.phi (not the old name_phstat_0.phi)

    Returns the clusters obtained under the given tolerance in the form of a dictionary

    """

    ls_not_empty = True
    count = 0
    items_to_remove = []
    dictio_cluster = {}

    path_ls = os.path.join(wd, name_phstat + ".ls")
    ls = open(path_ls, "r")
    lineas_fichero_ls = ls.readlines()
    numero_phs = len(lineas_fichero_ls)
    del ls
    print "\nThere are " + str(numero_phs) + "  .phs files in the ls file ", path_ls
    content_lines = lineas_fichero_ls

    # Prepare a file to analyse how the clusters are being formed
    path_formation = os.path.join(wd, "clustering_sequence_"+str(idrotclu))
    file_form = open(path_formation, "w")
    counter_single=0

    while ls_not_empty:
        if (len(content_lines) - len(items_to_remove)) > 0:
            # Read the ls to see what did you have before clustering
            ls = open(path_ls, "r")
            content_lines = ls.readlines()
            del ls
            complete_output, errors = call_phstat_print_for_clustering_global(name_phstat=name_phstat, wd=wd,
                                                                              path_phstat=path_phstat,
                                                                              resolution=resolution, seed=seed,
                                                                              tolerance=tolerance, n_cycles=n_cycles,
                                                                              orisub=orisub, weight=weight,
                                                                              oricheck=oricheck, mapcc=mapcc)
            print complete_output,errors

            # Retrieve the results and save to dictionary
            #dictio_result, total_runtime = read_phstat_isa_clusterization_output(complete_output,n_cycles,len(content_lines))
            dictio_result, total_runtime, seed_tested = read_phstat_isa_multiseed_clusterization_output(complete_output,n_cycles,len(content_lines))

            if seed_tested:
                list_dictio_results = split_alixe_clusters(dictio_result)
            else:
                list_dictio_results=[dictio_result]

            if seed==1:
                name_superphi=name_phstat+"_"+str(len(list_dictio_results))+".phi"
            elif seed==0:
                name_superphi = name_phstat + "_0.phi"
            # Now the rest of the steps must be performed for all the clusters
            for iclu,superclu in enumerate(list_dictio_results):
                dictio_result=superclu
                phs_in_cluster = len(dictio_result)
                # Obtain the name of the reference used
                if phs_in_cluster>1: # Then I need to rename the original phi file
                    for fichi in dictio_result.keys():
                        if dictio_result[fichi]['ref_no_cluster']!='cluster':
                            name_phi=fichi[:-4]+ '_ref.phi'
                    os.rename(os.path.join(wd,name_superphi),os.path.join(wd,name_phi))
                else: # else the file does not exist, we can only refer to the original phs
                    name_phi=dictio_result.keys()[0]


                dictio_cluster[os.path.join(wd, name_phi)] = {'dictio_result': dictio_result, 'n_phs': phs_in_cluster,
                                                              'dict_FOMs': {}}

                if phs_in_cluster==1:
                    counter_single=counter_single+1
                else:
                    counter_single=0
                file_form.write(('%-35s %-12s %-12s %-12s\n' % (name_phi, str(phs_in_cluster), str(counter_single),str(total_runtime))))

            # Overwrite the ls so that you write now just the things that didn't cluster
            ls2 = open(path_ls, 'w')
            del ls2
            items_to_remove = []
            for iclu, superclu in enumerate(list_dictio_results):
                dictio_result = superclu
                for item in dictio_result.keys():
                    items_to_remove.append(item)
            for phs in content_lines:
                phs = phs.strip()
                if phs not in items_to_remove:
                    ls3 = open(path_ls, 'a')
                    ls3.write(phs + "\n")
                    del ls3
                count = count + 1
        else:
            ls_not_empty = False
    del file_form
    return dictio_cluster

#@timing
def clustering_phstat_print_under_a_tolerance(name_phstat, wd, path_phstat, tolerance=75, resolution=1.0, seed=0,
                                              n_cycles=3):
    """ This function calls the fortran phstat_print for clustering, and sequentially process the complete ls file.
    You need to have both the .ls file and a .ins file called like name_phstat.
    IMPORTANT: the phi files will be named as name_phstat.phi (not the old name_phstat_0.phi)
    Returns the clusters obtained under the given tolerance in the form of a dictionary
    """
    listacluster = []
    ls_not_empty = True
    count = 0
    items_to_remove = []
    dictio_cluster = {}

    path_ls = os.path.join(wd, name_phstat + ".ls")
    ls = open(path_ls, "r")
    lineas_fichero_ls = ls.readlines()
    numero_phs = len(lineas_fichero_ls)
    del ls
    print "\nThere are " + str(numero_phs) + "  .phs files in the ls file ", path_ls
    content_lines = lineas_fichero_ls
    ls = open(path_ls, "r")
    ls_content = ls.read()
    del ls

    while ls_not_empty:
        if (len(content_lines) - len(items_to_remove)) > 0:
            # Read the ls to see what did you have before clustering
            ls = open(path_ls, "r")
            content_lines = ls.readlines()
            del ls
            ls = open(path_ls, 'r')
            ls_content = ls.read()
            del ls
            # Cluster
            complete_output, errors = call_phstat_print_for_clustering(name_phstat, wd, path_phstat, resolution, seed,
                                                               tolerance, n_cycles)
            print complete_output
            # Save the results
            dictio_result = read_phstat_print_clusterization_output(ls_content, complete_output,
                                                                    n_cycles)  # dictio_best[name_phs]={'MPE': 34.2 ,'shift':[0, 0.5, 0]}
            phs_in_cluster = len(dictio_result)
            # Obtain the name of the reference used
            name_phi = (os.path.split(content_lines[0])[1])[:-5] + '_ref.phi'
            dictio_cluster[os.path.join(wd, name_phi)] = {'dictio_result': dictio_result, 'n_phs': phs_in_cluster,
                                                          'dict_FOMs': {}}
            # TEMPORARY TO CHECK
            # shutil.copy(path_ls,(os.path.split(content_lines[0])[1])[:-5]+'_ref.ls')
            # Overwrite the ls so that you write now just the things that didn't cluster
            ls2 = open(path_ls, 'w')
            del ls2
            items_to_remove = []
            for item in dictio_result.keys():
                items_to_remove.append(item)
            for phs in content_lines:
                phs = phs.strip()
                if phs not in items_to_remove:
                    ls3 = open(path_ls, 'a')
                    ls3.write(phs + "\n")
                    del ls3
            os.rename(os.path.join(wd, name_phstat + ".phi"), os.path.join(wd, name_phi))
            # output_file=open(os.path.join(wd,name_phstat+".out"),'w')
            # output_file.write(complete_output)
            # del output_file
            count = count + 1
        else:
            ls_not_empty = False
            # for key in dictio_cluster.keys():
    # print key, dictio_cluster[key]
    return dictio_cluster

def change_key_dictio_clust_dict(dict_clust_by_rotclu,clust_fold):
    # NOTE: Because of the relative paths, I need to modify the dictionary now to contain the full paths
    for rotclu in dict_clust_by_rotclu.keys():
        for key1 in dict_clust_by_rotclu[rotclu].keys():
            new_key1 = os.path.join(clust_fold, os.path.split(key1)[1])
            dict_clust_by_rotclu[rotclu][new_key1] = copy.deepcopy(dict_clust_by_rotclu[rotclu][key1])
            del dict_clust_by_rotclu[rotclu][key1]
            for key2 in dict_clust_by_rotclu[rotclu][new_key1]['dictio_result'].keys():
                new_key2 = os.path.join(clust_fold, os.path.split(key2)[1])
                dict_clust_by_rotclu[rotclu][new_key1]['dictio_result'][new_key2] = copy.deepcopy(
                    dict_clust_by_rotclu[rotclu][new_key1]['dictio_result'][key2])
                del dict_clust_by_rotclu[rotclu][new_key1]['dictio_result'][key2]
    return dict_clust_by_rotclu


def change_shelxe_line_for_alixe(shelxe_line):
    '''Modifies a given shelxe line to adapt it to the necessary parameterization for alixe.

    Args:
        shelxe_line (str): command line for shelxe

    Returns:
        shelxe_line (str): modified command line for shelxe

    '''
    list_arg = shelxe_line.split()
    new_shelxe_line = ""
    for arg in list_arg:
        if arg.startswith("-a"):
            new_shelxe_line += "-a0 " # 0 autotracing cycles
        elif arg.startswith("-m"):
            new_shelxe_line += "-m5 " # 5 cycles of density modification
        elif arg.startswith("-v"):
            new_shelxe_line += "-v0 " # no density sharpening
        elif arg.startswith("-y"):
            new_shelxe_line += "-y1.0 " # use all available resolution to compute phases
        elif arg.startswith("-e"): # leave whathever free lunch was in the original shelxe line
            pass
        elif arg.startswith("-o"): # leave the trimming optimization if it was present in the original shelxe line
            pass
        else:
            new_shelxe_line += arg + " " # every other argument can be the same
    return new_shelxe_line

#@timing
def check_resolution_limit_numpy(array_refle, resolution, coef2, coef3):
    """ Filters a reflection array according to a given resolution limit

    d* = ( ha* + kb* + lc* + 2hka*b* + 2hla*c* + 2klb*c* ) ^ 1/2
    1/d = ( ha* + kb* + lc* + 2hka*b* + 2hla*c* + 2klb*c* )

    NOTE: the 0.25 factor is because we are comparing to 1/4 d, and our
    coefficients take that into account.

    coef2, for each cell dimension and angle
    0.25(abc/V)(sen/a)
    0.25(abc/V)(sen/b)
    0.25(abc/V)(sen/c)

    coef3, for each cell dimension and angle
    (abc/V)a(cos*cos-cos)
    (abc/V)b(cos*cos-cos)
    (abc/V)c(cos*cos-cos)


    :param array_refle:
    :type array_refle: list
    :param resolution:
    :type resolution: float
    :param coef2: list with three coefficients
    :type coef2: list
    :param coef3: list with three coefficients
    :type coef3: list
    :return:
    :rtype:
    """

    resolution_comp = 0.25 / (resolution ** 2)
    # resolution_check_values = [refle[0] ** 2 * coef2[0] +
    #                            refle[1] ** 2 * coef2[1] +
    #                            refle[2] ** 2 * coef2[2] +
    #                            refle[1] * refle[2] * coef3[0] +
    #                            refle[0] * refle[2] * coef3[1] +
    #                            refle[0] * refle[1] * coef3[2]
    #                            for i, refle in enumerate(array_refle)]
    # new_array_refle = [array_refle[i] for i,_ in enumerate(resolution_check_values)
    #                    if resolution_check_values[i] < resolution_comp]
    #
    # print 'new_array_refle[0]',new_array_refle[0]
    # print 'new_array_refle[1]', new_array_refle[1]

    # numpy solution to do the same thing as in the previous list_comprehensions
    # refle[0] = h = array_refle[:,0:1]
    # refle[1] = k = array_refle[:,1:2]
    # refle[2] = l = array_refle[:,2:3]

    operation_array = array_refle[:, 0:1] ** 2 * coef2[0] + \
                      array_refle[:, 1:2] ** 2 * coef2[1] + \
                      array_refle[:, 2:3] ** 2 * coef2[2] + \
                      array_refle[:, 1:2] * array_refle[:,2:3] * coef3[0] + \
                      array_refle[:, 0:1] * array_refle[:,2:3] * coef3[1] + \
                      array_refle[:, 0:1] * array_refle[:,1:2] * coef3[2]

    # print 'operation_array',operation_array

    array_ind = numpy.where(operation_array < resolution_comp)
    #print array_ind[0]


    numpy_array_refle = array_refle[array_ind[0]]


    if len(array_refle) == len(numpy_array_refle):
        #print 'No reflections were removed in the resolution check, the maximum resolution found was '
        resolution_check_values.sort(reverse=True)
        resolution_back=numpy.sqrt(0.25/resolution_check_values[0])
        # TODO: put a warning if the resolution is less than the one set for filtering
        #sys.exit(0)
        return  numpy_array_refle, resolution_back
    else:
        #print "Different array size due to elimination of reflections under the resolution limit ", \
        #    len(array_refle), '   ', len(new_array_refle)
        return  numpy_array_refle,resolution

#@timing
def check_resolution_limit(array_refle, resolution, coef2, coef3):
    """ Filters a reflection array according to a given resolution limit

    d* = ( ha* + kb* + lc* + 2hka*b* + 2hla*c* + 2klb*c* ) ^ 1/2
    1/d = ( ha* + kb* + lc* + 2hka*b* + 2hla*c* + 2klb*c* )

    NOTE: the 0.25 factor is because we are comparing to 1/4 d, and our
    coefficients take that into account.

    coef2, for each cell dimension and angle
    0.25(abc/V)(sen/a)
    0.25(abc/V)(sen/b)
    0.25(abc/V)(sen/c)

    coef3, for each cell dimension and angle
    (abc/V)a(cos*cos-cos)
    (abc/V)b(cos*cos-cos)
    (abc/V)c(cos*cos-cos)


    :param array_refle:
    :type array_refle: list
    :param resolution:
    :type resolution: float
    :param coef2: list with three coefficients
    :type coef2: list
    :param coef3: list with three coefficients
    :type coef3: list
    :return:
    :rtype:
    """

    resolution_comp = 0.25 / (resolution ** 2)
    resolution_check_values = [refle[0] ** 2 * coef2[0] +
                               refle[1] ** 2 * coef2[1] +
                               refle[2] ** 2 * coef2[2] +
                               refle[1] * refle[2] * coef3[0] +
                               refle[0] * refle[2] * coef3[1] +
                               refle[0] * refle[1] * coef3[2]
                               for i, refle in enumerate(array_refle)]
    new_array_refle = [array_refle[i] for i,_ in enumerate(resolution_check_values)
                       if resolution_check_values[i] < resolution_comp]

    if len(array_refle) == len(new_array_refle):
        #print 'No reflections were removed in the resolution check, the maximum resolution found was '
        resolution_check_values.sort(reverse=True)
        resolution_back=numpy.sqrt(0.25/resolution_check_values[0])
        # TODO: put a warning if the resolution is less than the one set for filtering
        #sys.exit(0)
        return new_array_refle, resolution_back
    else:
        #print "Different array size due to elimination of reflections under the resolution limit ", \
        #    len(array_refle), '   ', len(new_array_refle)
        return new_array_refle,resolution


def extract_INITCC_shelxe(complete_output,map=False):
    """Given the contents of an lst file (output from shelxe),
    it will parse it initial correlation coefficient and return it"""
    lines = complete_output.split("\n")
    for i in range(len(lines)):
        if lines[i].startswith(" Overall CC between native Eobs and Ecalc (from fragment)") and not map:
            initcc = float((lines[i].split()[10])[:-1])
            return initcc
        if lines[i].startswith("Overall CC between native Eobs and Ecalc (from map)") and map:
            initcc = float((lines[i].split()[10])[:-1])
            return initcc
    return -1.0

def extract_EFOM_and_pseudoCC_shelxe(complete_output):
    """Given the contents of an lst file (output from shelxe), it will look for the value of the mean FOM and Pseudo-Free CC and return them"""
    # Example format: Estimated mean FOM = 0.485   Pseudo-free CC = 49.91 %
    lines = complete_output.split("\n")
    regexFOM = re.compile('Estimated mean FOM = ')
    regexCC = re.compile('Pseudo-free CC =')
    for i in range(len(lines)):
        if bool(regexFOM.findall(lines[i])) and bool(regexCC.findall(lines[i])):
            list_val=lines[i].split()
            if len(list_val)==10: #all OK size is normal
                fom = float(list_val[4])
                pseudocc = float(list_val[8])
            elif len(list_val)==9: # one of the two values is negative
                if list_val[3].startswith('=') and len(list_val[3])>1: # fom is negative
                    fom = float(list_val[3][1:])
                    pseudocc = float(list_val[8])
                else:
                    fom = float(list_val[4])
                    pseudocc = float(list_val[7][1:])
            elif len(list_val)==8: # the two values are negative
                    fom = float(list_val[3][1:])
                    pseudocc = float(list_val[7][1:])
            #print "\nEstimated mean FOM "+str(fom)
            #print "\nPseudo-free CC "+str(pseudocc)+" %"
            return fom, pseudocc


def extract_best_CC_shelxe(complete_output):
    """Given the contents of an lst file (output from shelxe), it will look for the value of the final best value of CC"""
    # Example format:  Best trace (cycle   1 with CC  8.64%) was saved as all_phs_0_92.pdb
    lines = complete_output.split("\n")
    regexCC = re.compile('Best trace')
    for i in range(len(lines)):
        if bool(regexCC.findall(lines[i])):
            cut_first = lines[i].split("%")[0]
            CC = float(cut_first.split()[6])
            print "\nFinal CC " + str(CC) + " %"
            return CC


def extract_shift_from_shelxe(complete_output):
    # Example format: Origin shift relative to model in .ent:  dx= 0.000  dy= 0.375  dz= 0.500
    regexshift = re.compile(' Shift from model in .ent')
    lines = complete_output.split("\n")
    shift = []
    for i in range(len(lines)):
        if bool(regexshift.findall(lines[i])):
            values = lines[i].split("=")
            for x in range(len(values)):
                if x in [1, 2, 3]:
                    shift.append(float(values[x].split()[0]))
    for index in range(len(shift)):
        shift[index] = float(shift[index])
    return shift


def extract_wMPE_shelxe(lst_path):
    """Given the contents of an lst file (output from shelxe), it will look for the wMPEs values and return them"""
    # Example format:  <cos> 0.002 / 0.013  <fom> 0.261 / 0.430  MPE  89.8 / 89.2  wMPE 88.9 / 87.4
    # Or worse: <cos> 0.020 /-0.109  <fom> 0.293 / 0.584  MPE  88.6 / 99.8  wMPE 88.6 /102.7
    p = subprocess.Popen('grep  wMPE ' + lst_path, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    pout, perr = p.communicate()
    pout = pout.strip()
    regexwMPE = re.compile('wMPE')
    file_lst = open(lst_path, 'r')
    list_lines_wMPE = []
    lines_lst = file_lst.readlines()
    for i in range(len(lines_lst)):
        if bool(regexwMPE.findall(lines_lst[i])):
            list_lines_wMPE.append((lines_lst[i].strip("\n")))
    list_first = list_lines_wMPE[0].split("/")
    list_second = list_lines_wMPE[-1].split("/")
    wMPEa = float((list_first[3].split())[2])
    wMPEb = float(list_first[4])
    wMPEc = float((list_second[3].split())[2])
    wMPEd = float(list_second[4])
    return [wMPEa, wMPEb, wMPEc, wMPEd]


def extract_table_resolution_shelxe(complete_output):
    """Given the contents of an lst file (output from shelxe), it will look for the table of mean FOM and mapCC as a function of resolution and
    return it in the form of a dictionary where keys are d, FOM, mapCC and N"""
    dictio_result = {}
    lines = complete_output.split("\n")
    regex_table = re.compile('Estimated mean FOM and mapCC as a function of resolution')
    for i in range(len(lines)):
        if bool(regex_table.findall(lines[i])):
            line_res_shell = lines[
                i + 1]  # d    inf - 4.41 - 3.47 - 3.03 - 2.74 - 2.54 - 2.39 - 2.27 - 2.17 - 2.08 - 2.00
            list_res = line_res_shell.split("-")
            dictio_result["d"] = list_res[1:]
            print list_res
            line_FOM = lines[i + 2]  # <FOM>
            list_FOM = line_FOM.split()
            dictio_result["<FOM>"] = list_FOM[1:]
            print list_FOM
            line_mapCC = lines[i + 3]  # <mapCC>
            list_mapCC = line_mapCC.split()
            dictio_result["<mapCC>"] = list_mapCC[1:]
            print list_mapCC
            line_N = lines[i + 4]  # N
            list_N = line_N.split()
            dictio_result["N"] = list_N[1:]
            print list_N
    for key in dictio_result.keys():
        print key
        print dictio_result[key]
        print "\n"


def extract_remark_cluster_pdb(pdb_content):
    pdb_lines = pdb_content.split("\n")
    for line in pdb_lines:
        if line.startswith("REMARK CLUSTER"):  # E.G. REMARK CLUSTER 7
            rotclu = (line.split())[2]
            return rotclu


def extract_cryst_card_pdb(pdb_content):
    pdb_lines = pdb_content.split("\n")
    for linea in pdb_lines:
        if linea.startswith("CRYST1"):  # E.G. CRYST1   30.279   91.989   32.864  90.00 112.60  90.00 P 1 21 1      2
            cryst_card = linea
            return cryst_card
    return None

#@timing
def change_to_standard_equivalent_reflections_numpy(array_refle, space_group_key, dictio_space_groups):
    """ Puts all the reflections in the standard setting of the asymmetric reciprocal unit.

    :param array_refle: reflections array.
                       If the array comes from a phs file, H K L F FOM PHI sigF
    :type array_refle: list
    :param symops: symmetry operations obtained from dictio_space_groups[space_group_key]['symops']
    :type symops: dict
    :return array_refle: returns the array but reduced in size because of merging of equivalent reflections
    :rtype array_refle: list
   """
    ###################################################
    # PENDING TO ACTUALLY CHANGE TO NUMPY EXPRESSIONS #
    ###################################################
    print 'warning: This function is not yet exploiting numpy appropriately'

    symops = dictio_space_groups[space_group_key]['symops']
    # for key in symops.keys():
    #     print symops[key],type(symops[key])
    #     print symops[key]['rot'], type(symops[key]['rot'])
    #     print symops[key]['tra'], type(symops[key]['tra'])

    #array_first = numpy.copy(array_refle)

    for i, _ in enumerate(array_refle):
        u = array_refle[i][0]
        v = array_refle[i][1]
        w = array_refle[i][2]
        mh = array_refle[i][0]
        mk = array_refle[i][1]
        mn = array_refle[i][2]
        p = array_refle[i][5]  # phase
        for j in range(1, len(symops) + 1):  # Apply rotation symmetry operations and round to integer
            nh = int(round((u * symops[j]['rot'][0][0]) + (v * symops[j]['rot'][1][0]) + (w * symops[j]['rot'][2][0])))
            nk = int(round((u * symops[j]['rot'][0][1]) + (v * symops[j]['rot'][1][1]) + (w * symops[j]['rot'][2][1])))
            nl = int(round((u * symops[j]['rot'][0][2]) + (v * symops[j]['rot'][1][2]) + (w * symops[j]['rot'][2][2])))
            t = 1.0
            if nl > 0 or nk > 0 or nh >= 0:
                if nl < mn or nk < mk or nh < mh:
                    continue
                elif nl > mn or nk > mk:
                    mh = nh
                    mk = nk
                    mn = nl
                    if p > -0.0001:
                        array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
                        continue
            elif nl < 0 or nk < 0:
                nh = -nh
                nk = -nk
                nl = -nl
                t = -1.0
                if nl < mn or nk < mk or nh < mh:
                    continue
                elif nl > mn or nk > mk:
                    mh = nh
                    mk = nk
                    mn = nl
                    if p > -0.0001:
                        array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
                        continue
        array_refle[i][0] = float(mh)
        array_refle[i][1] = float(mk)
        array_refle[i][2] = float(mn)
        if p >= -0.0001:
            array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5

        #if numpy.array_equal(array_first,array_refle):
            # print 'This operation did not changed the starting array'

    return array_refle


#@timing
def change_to_standard_equivalent_reflections(array_refle, space_group_key):
    """ Puts all the reflections in the standard setting of the asymmetric reciprocal unit.

    :param array_refle: reflections array.
                       If the array comes from a phs file, H K L F FOM PHI sigF
    :type array_refle: list
    :param symops: symmetry operations obtained from dictio_space_groups[space_group_key]['symops']
    :type symops: dict
    :return array_refle: returns the array but reduced in size because of merging of equivalent reflections
    :rtype array_refle: list
   """
    #############################################
    # Conditions for the different point groups #
    #############################################
    #pg = dictio_space_groups[space_group_key]['point']
    #laue = dictio_space_groups[space_group_key]['laue']
    symops = dictio_space_groups[space_group_key]['symops']
    # inf=numpy.inf
    #
    # if laue == '2/mm':
    #     print 'Yeah, 2/mm Laue class'
    #     range_h = (0, inf)
    #     range_k = (0, inf)
    #     range_l = (0, inf)
    # elif laue == '2/m':
    #     print 'Yeah, 2/m Laue class'
    #     range_h = (-inf, inf)
    #     range_k = (0, inf)
    #     range_l = (0, inf)
    #     # Exclude h,k,0 if h<0
    # elif laue == '-1':
    #     print 'Yeah, -1 Laue class'
    #     range_h = (-inf, inf)
    #     range_k = (-inf, inf)
    #     range_l = (0, inf)
    #     # Exclude 0,k,l if l<0
    #     # Exclude 0,k,0 if k<0
    # elif laue == '4/mm':
    #     print 'Yeah, 4/mm Laue class'
    #     range_h = (0, inf)
    #     range_k = (0, inf) # this should be (h,inf) how can I codify it?
    #     range_l = (0, inf)
    #     # Exclude 0,k,l if k>0
    # elif laue == '-3m1':
    #     print 'Yeah, -3m1 Laue class'
    #     range_h = (0, inf)
    #     range_k = (0, inf)
    #     range_l = (0, inf)
    #     # Exclude hk0 if h<k
    # elif laue == '6/mmm':
    #     print 'Yeah, 6/mmm Laue class'
    #     range_h = (0, inf)
    #     range_k = (0, inf) # this should be (h,inf) how can I codify it?
    #     range_l = (0, inf)
    # elif laue == '-3':
    #     print 'Yeah, -3 Laue class'
    #     range_h = (0, inf)
    #     range_k = (0, inf)
    #     range_l = (-inf, inf)
    #     # Exclude h,0,l if l<0
    #     # Exclude 0,k,l if l<=0
    # elif laue == '6/m':
    #     print 'Yeah, 6/m Laue class'
    #     range_h = (0, inf)
    #     range_k = (0, inf)
    #     range_l = (0, inf)
    #     # Exclude 0,k,l if k > 0
    # elif laue == '4/m':
    #     print 'Yeah, 4/m Laue class'
    #     range_h = (0, inf)
    #     range_k = (0, inf)
    #     range_l = (0, inf)
    # elif laue == 'm-3':
    #     print 'Yeah, m-3 Laue class'
    #     range_h = (0, inf)
    #     range_k = (0, inf) # this should be (h,inf) how can I codify it?
    #     range_l = (0, inf) # this should be (h,inf) how can I codify it?
    #     # Exclude h,k,h if h<k
    # elif laue == 'm-3m':
    #     print 'Yeah, m-3m Laue class'
    #     range_h = (0, inf)
    #     range_k = (0, inf) # this should be (h,inf) how can I codify it?
    #     range_l = (0, inf) # this should be (k,inf) how can I codify it?
    # elif laue == '-31m':
    #     print 'Yeah, -31m Laue class'
    #     range_h = (0, inf)
    #     range_k = (0, inf) # this should be (h,inf) how can I codify it?
    #     range_l = (-inf, inf)
    #     # Exclude 0,k,l if l<0
    #
    #
    # for i, _ in enumerate(array_refle):
    #     u = float(array_refle[i][0]) #change this! they are already floats
    #     v = float(array_refle[i][1])
    #     w = float(array_refle[i][2])
    #     mh = array_refle[i][0]
    #     mk = array_refle[i][1]
    #     mn = array_refle[i][2]
    #     p = array_refle[i][5]  # phase
    #     if (range_h[0] <= u < range_h[1] ) and \
    #        (range_k[0] <= v < range_k[1])  and \
    #        (range_l[0] <= w < range_l[1]):
    #         print '\nThis reflection is OK'
    #         print 'u,v,w',u,v,w
    #         #sys.exit(0)
    #         continue
    #     else:
    #         print '\n Something with this reflection'
    #         print 'u,v,w',u,v,w
    #         for j in range(1, len(symops) + 1):  # Apply rotation symmetry operations and round to integer
    #             nh = int(round((u * symops[j]['rot'][0][0]) + (v * symops[j]['rot'][1][0]) + (w * symops[j]['rot'][2][0])))
    #             nk = int(round((u * symops[j]['rot'][0][1]) + (v * symops[j]['rot'][1][1]) + (w * symops[j]['rot'][2][1])))
    #             nl = int(round((u * symops[j]['rot'][0][2]) + (v * symops[j]['rot'][1][2]) + (w * symops[j]['rot'][2][2])))
    #             t = 1.0
    #             if (range_h[0] <= nh < range_h[1]) and \
    #                     (range_k[0] <= nk < range_k[1]) and \
    #                     (range_l[0] <= nl < range_l[1]):
    #                 print '\nThis reflection is now OK'
    #                 print 'u,v,w', u, v, w
    #                 print 'nh,nk,nl',nh,nk,nl
    #                 #sys.exit(0)
    #                 # t = -1.0
    #                 array_refle[i][0] = nh
    #                 array_refle[i][1] = nk
    #                 array_refle[i][2] = nl
    #                 if p >= -0.0001:
    #                     print 'I should change the phase accordingly'
    #                     array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
    #                     # phim = phi - 2pihtm = phi -2pi (h t1 + k t2 + l t3)
    #                     #sys.exit(0)
    #                 break

            #sys.exit(0)
    #     #     t = 1.0
    #     #     if nl > 0 or nk > 0 or nh >= 0:
    #     #         if nl < mn or nk < mk or nh < mh:
    #     #             continue
    #     #         elif nl > mn or nk > mk:
    #     #             mh = nh
    #     #             mk = nk
    #     #             mn = nl
    #     #             if p >= -0.0001:
    #     #                 array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
    #     #             continue
    #     #     elif nl < 0 or nk < 0:
    #     #         nh = -nh
    #     #         nk = -nk
    #     #         nl = -nl
    #     #         t = -1.0
    #     #         if nl < mn or nk < mk or nh < mh:
    #     #             continue
    #     #         elif nl > mn or nk > mk:
    #     #             mh = nh
    #     #             mk = nk
    #     #             mn = nl
    #     #             if p >= -0.0001:
    #     #                 array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
    #     #             continue
    #     # array_refle[i][0] = mh
    #     # array_refle[i][1] = mk
    #     # array_refle[i][2] = mn
    #     # if p >= -0.0001:
    #     #     array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
    #         t = 1.0
    #         if nl > 0:
    #             # equivalent to tag 2
    #             if nl < mn:
    #                 # equivalent to tag 4
    #                 continue
    #             if nl > mn:
    #                 # equivalent to tag 3
    #                 mh = nh
    #                 mk = nk
    #                 mn = nl
    #                 if p >= -0.0001:
    #                     array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
    #                 continue
    #             if nk < mk:
    #                 # equivalent to tag 4
    #                 continue
    #             if nk > mk:
    #                 # equivalent to tag 3
    #                 mh = nh
    #                 mk = nk
    #                 mn = nl
    #                 if p >= -0.0001:
    #                     array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
    #                 continue
    #             if nh < mh:
    #                 #equivalent to tag 4
    #                 continue
    #             # if none of the checks of 2 has left the loop
    #             # equivalent to tag 3
    #             mh = nh
    #             mk = nk
    #             mn = nl
    #             if p >= -0.0001:
    #                 array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
    #             continue
    #         if nl < 0:
    #             # equivalent to GOTO1
    #             nh = -nh
    #             nk = -nk
    #             nl = -nl
    #             t = -1.0
    #         if nk > 0:
    #             # equivalent to tag 2
    #             if nl < mn:
    #                 # equivalent to tag 4
    #                 continue
    #             if nl > mn:
    #                 # equivalent to tag 3
    #                 mh = nh
    #                 mk = nk
    #                 mn = nl
    #                 if p >= -0.0001:
    #                     array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
    #                 continue
    #             if nk < mk:
    #                 # equivalent to tag 4
    #                 continue
    #             if nk > mk:
    #                 # equivalent to tag 3
    #                 mh = nh
    #                 mk = nk
    #                 mn = nl
    #                 if p >= -0.0001:
    #                     array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
    #                 continue
    #             if nh < mh:
    #                 # equivalent to tag 4
    #                 continue
    #             # if none of the checks of 2 has left the loop
    #             # equivalent to tag 3
    #             mh = nh
    #             mk = nk
    #             mn = nl
    #             if p >= -0.0001:
    #                 array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
    #             continue
    #         if nk < 0:
    #             # equivalent to GOTO1
    #             nh = -nh
    #             nk = -nk
    #             nl = -nl
    #             t = -1.0
    #         if nh >= 0:
    #             # equivalent to tag 2
    #             if nl < mn:
    #                 # equivalent to tag 4
    #                 continue
    #             if nl > mn:
    #                 # equivalent to tag 3
    #                 mh = nh
    #                 mk = nk
    #                 mn = nl
    #                 if p >= -0.0001:
    #                     array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
    #                 continue
    #             if nk < mk:
    #                 # equivalent to tag 4
    #                 continue
    #             if nk > mk:
    #                 # equivalent to tag 3
    #                 mh = nh
    #                 mk = nk
    #                 mn = nl
    #                 if p >= -0.0001:
    #                     array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
    #                 continue
    #             if nh < mh:
    #                 # equivalent to tag 4
    #                 continue
    #             # if none of the checks of 2 has left the loop
    #             # equivalent to tag 3
    #             mh = nh
    #             mk = nk
    #             mn = nl
    #             if p >= -0.0001:
    #                 array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
    #             continue
    #
    #         # if none of the checks of 0 has left the loop
    #         # equivalent to tag1
    #         nh = -nh
    #         nk = -nk
    #         nl = -nl
    #         t = -1.0
    #
    #     array_refle[i][0] = mh
    #     array_refle[i][1] = mk
    #     array_refle[i][2] = mn
    #     continue
    #
    #for i in range(10):
    #    print 'i, array_refle[i],',i,array_refle[i]
    #sys.exit(0)
    for i, _ in enumerate(array_refle):
        u = float(array_refle[i][0])
        v = float(array_refle[i][1])
        w = float(array_refle[i][2])
        mh = float(array_refle[i][0])
        mk = float(array_refle[i][1])
        mn = float(array_refle[i][2])
        p = array_refle[i][5]  # phase
        for j in range(1, len(symops) + 1):  # Apply rotation symmetry operations and round to integer
            nh = int(round((u * symops[j]['rot'][0][0]) + (v * symops[j]['rot'][1][0]) + (w * symops[j]['rot'][2][0])))
            nk = int(round((u * symops[j]['rot'][0][1]) + (v * symops[j]['rot'][1][1]) + (w * symops[j]['rot'][2][1])))
            nl = int(round((u * symops[j]['rot'][0][2]) + (v * symops[j]['rot'][1][2]) + (w * symops[j]['rot'][2][2])))
            t = 1.0
            if nl > 0 or nk > 0 or nh >= 0:
                if nl < mn or nk < mk or nh < mh:
                    continue
                elif nl > mn or nk > mk:
                    mh = nh
                    mk = nk
                    mn = nl
                    if p > -0.0001:
                        array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
                        continue
            elif nl < 0 or nk < 0:
                nh = -nh
                nk = -nk
                nl = -nl
                t = -1.0
                if nl < mn or nk < mk or nh < mh:
                    continue
                elif nl > mn or nk > mk:
                    mh = nh
                    mk = nk
                    mn = nl
                    if p > -0.0001:
                        array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
                        continue
        array_refle[i][0] = float(mh)
        array_refle[i][1] = float(mk)
        array_refle[i][2] = float(mn)
        if p >= -0.0001:
            array_refle[i][5] = ((719.5 + p * t) % 360) + 0.5
    return array_refle


# NOTE: Esta funcion no va bien, la dejo en cuarentena. Tengo que ver con Isabel lo del filtering.
##def filter_array_by_evalues(array_to_filter,array_evalues):
##    filtered_array=[]
##    for r in range(len(array_to_filter)):
##        #print "Cycle",r,"len(array_evalues)",len(array_evalues)
##        list_indexes_filter=[array_to_filter[r][0],array_to_filter[r][1],array_to_filter[r][2]]
##        extrapolated=True
##        for i in range(len(array_evalues)):
##            list_indexes_evalues=[array_evalues[i][0],array_evalues[i][1],array_evalues[i][2]]
##            if list_indexes_filter==list_indexes_evalues:
##                extrapolated=False
##                #print "I found this reflection ",array_to_filter[r]," in the evalue array ",array_evalues[r]
##                break
##            elif list_indexes_filter!=list_indexes_evalues:
##                continue
##        # If after all iterations there was no match, the reflection must not be considered
##        if extrapolated==True:
##            continue
##        elif extrapolated==False:
##            filtered_array.append(array_to_filter[r])
##            array_evalues.pop(i)
##    return filtered_array


def fuse_pdbs(list_of_filepaths, path_pdb):
    """
    :param list_of_filepaths:
    :type list_of_filepaths:
    :param path_pdb:
    :type path_pdb:
    :return:
    :rtype:
    """
    list_of_structures = []
    parser = PDBParser()
    for pdb_file in list_of_filepaths:
        structure = parser.get_structure(pdb_file[:-4], pdb_file)
        list_of_structures.append(structure)
    main_structure = list_of_structures[0]
    for x, structure in enumerate(list_of_structures):
        # print "Processing ",structure," ",x
        model = structure[0]
        if x != 0:
            model.id = x
            model.serial_num = x
            main_structure.add(model)
    # print Selection.unfold_entities(main_structure,'M')
    io = PDBIO()
    io.set_structure(main_structure)
    io.save(path_pdb, write_end=False)

def get_general_info_for_alixe(Config):
    """ Read the bor file and retrieve the information about the paths in the GENERAL section

    :param path_bor:
    :return:
    """
    wd_run = Config.get("GENERAL", "working_directory")
    hkl_filename = Config.get("GENERAL", "hkl_path")
    if Config.has_option("GENERAL", "ent_path"):
        ent_filename = Config.get("GENERAL", "ent_path")
        ent_present = True
    else:
        ent_filename = None
        ent_present = False
    return wd_run,hkl_filename,ent_filename,ent_present

def get_arcirun_info_for_alixe(Config,wd,ent_present,pm):
    """ Retrieve shelxe line and info about on each type of run

    """
    sections = Config.sections()
    for section in sections:
        if section == "ARCIMBOLDO":
            name_job = Config.get("ARCIMBOLDO", "name_job")
            fragment = Config.get("ARCIMBOLDO", "fragment_to_search")
            shelxe_line = get_shelxe_line_from_html_output(name_job, wd)
            if ent_present and pm:
                shelxe_line = shelxe_line + " -x"
            shelxe_line_alixe = change_shelxe_line_for_alixe(shelxe_line)
            print "\nYou are executing ALIXE on an ARCIMBOLDO run"
            topexp = get_topexp_from_html_output(name_job, wd)
            type_run = 'ARCIMBOLDO'
            break
        elif section == "ARCIMBOLDO-BORGES":
            name_job = Config.get("ARCIMBOLDO-BORGES", "name_job")
            fragment = 1 # single copy search
            shelxe_line = get_shelxe_line_from_html_output(name_job, wd)
            if ent_present and pm:
                shelxe_line = shelxe_line + " -x"
            shelxe_line_alixe = change_shelxe_line_for_alixe(shelxe_line)
            print "\nYou are executing ALIXE on an ARCIMBOLDO_BORGES run"
            type_run = 'BORGES'
            topexp = get_topexp_from_html_output(name_job, wd)
            break
        elif section == "ARCIMBOLDO-SHREDDER":
            name_job = Config.get("ARCIMBOLDO-SHREDDER", "name_job")
            print "\nYou are executing ALIXE on an ARCIMBOLDO_SHREDDER run"
            shelxe_line = get_shelxe_line_from_html_output(name_job, wd)
            # Read the method used to know if it is launching ARCIMBOLDO_BORGES or ARCIMBOLDO_LITEs
            shred_method = Config.get('ARCIMBOLDO-SHREDDER', 'SHRED_METHOD')
            if shred_method == 'spherical' or shred_method == 'secondary_structure':
                # Then inside the working directory an ARCIMBOLDO_BORGES folder should have been written
                print "The run in which you will use ALIXE is a ", shred_method, " SHREDDER "
                fragment = 1 # single copy search
                type_run = 'BORGES'
                wd = os.path.join(wd, 'ARCIMBOLDO_BORGES')
                topexp = get_topexp_from_html_output(name_job + "_BORGESARCI", wd)
            elif shred_method == 'sequential':
                print "Currently this mode is not supported ", shred_method
                type_run = 'ARCIMBOLDO'
                sys.exit(1)
            if ent_present and pm: # Add the -x parameter to the shelxe line for post-mortem
                shelxe_line = shelxe_line + " -x"
            shelxe_line_alixe = change_shelxe_line_for_alixe(shelxe_line)
    if type_run == '':
        print "Sorry, you didn't provide any supported bor format. Autoalixe will end now"
        sys.exit(1)
    return shelxe_line_alixe,type_run, topexp, wd, fragment

def get_computing_info_for_alixe(Config):
    """ Read the bor file and retrieve the information about the computing setup

    :param path_bor:
    :return:
    """
    multiproc = False
    if not Config.has_section("CONNECTION"):
        multiproc = True
    else:
        computing = Config.get("CONNECTION", "distribute_computing")
        if computing!='multiprocessing':
            # NOTE: The operations related with reading the setup bor and the like are OK only for OUR setup
            # In condor we can read the local one from the setup.bor
            path_setup = Config.get("CONNECTION", "setup_bor_path")
            Config2 = ConfigParser.ConfigParser()
            Config2.read(path_setup)
            try:
                shelxe_path = Config2.get("LOCAL", "path_local_shelxe")
            except:
                print "\nThe bor file did not contain a LOCAL section, assuming shelxe is in the path"
                shelxe_path = 'shelxe'
        else:
            multiproc=True

    if multiproc == True:
        try:
            shelxe_path = Config.get("LOCAL", "path_local_shelxe")
        except:
            print "\nThe bor file did not contain a LOCAL section, assuming shelxe is in the path"
            shelxe_path = 'shelxe'
    return multiproc,shelxe_path


def get_list_rotation_clusters_from_dictio_fragments(dictio_fragments):
    list_rot_cluster = []
    for frag in dictio_fragments.keys():
        rotclu = dictio_fragments[frag]['rot_cluster']
        if rotclu not in list_rot_cluster:
            list_rot_cluster.append(rotclu)
    return list_rot_cluster

#@timing
def get_spacegroup_dictionary():
    return copy.deepcopy(dictio_space_groups)

#@timing
def get_spacegroup_dictionary_numpy_converted():
    dictio_mod = copy.deepcopy(dictio_space_groups)
    for key in dictio_mod.keys():
        #print 'Analysing ',key
        for i,ori in enumerate(dictio_mod[key]['origins_list']):
            #print 'converting ',ori
            new_ori = numpy.array(ori)
            #print 'new_ori',new_ori,'type(new_ori)',type(new_ori)
            dictio_mod[key]['origins_list'][i]=new_ori
        for key2 in dictio_mod[key]['symops'].keys():
            #print 'converting translation'
            tra=dictio_mod[key]['symops'][key2]['tra']
            new_tra = numpy.array(tra)
            dictio_mod[key]['symops'][key2]['tra'] = new_tra
            #print 'converting rotation'
            rot=dictio_mod[key]['symops'][key2]['rot']
            new_rot = numpy.array(rot)
            dictio_mod[key]['symops'][key2]['rot'] = new_rot
    return dictio_mod

#@timing
def get_VA_and_VB(sorted_array):
    """

    :param sorted_array:
    :type sorted_array:
    :return:
    :rtype:
    """
    va_array = [sorted_array[i][0] for i,_ in enumerate(sorted_array)]  # FOMs
    vb_array = [sorted_array[i][1] for i,_ in enumerate(sorted_array)]  # Phases
    return va_array, vb_array

#@timing
def get_VA_and_VB_numpy(sorted_array):
    """

    :param sorted_array:
    :type sorted_array:
    :return:
    :rtype:
    """
    va_array = sorted_array[:,0:1]  # FOMs
    vb_array = sorted_array[:,1:2]  # Phases
    return va_array, vb_array



#@timing
def get_epsilon_1overdsquared_and_resmax_numpy(array_ref, symops, coef2, coef3):
    """ Computes the epsilon factors for each reflection, the 1/d for each reflection and the maximum 1/d value.

    epsilon factors: for certain classes of reflections, their indices map onto themselves  times upon application
    of the point group symmetry operations, and such a reflection therefore has  times the intensity of a general
    reflection.

    :param array_ref: bidimensional array which, for each reflection, contains, in float, H K L F FOM PHI sigF
    :type array_ref: list
    :param symops: symmetry operations obtained from dictio_space_groups[space_group_key]['symops'] Example in P3: {
                   1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
                   2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
                   3: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]}}
    :type symops: dict
    :param coef2:
    :type coef2:
    :param coef3:
    :type coef3:
    :return:
    :rtype:
    """
    ###################################################
    # PENDING TO ACTUALLY CHANGE TO NUMPY EXPRESSIONS #
    ###################################################
    print 'warning: This function is not yet exploiting numpy appropriately, only final conversion'
    res_max = 0.0
    #epsilon = []
    #onedsquared = []
    for ind in range(2, len(symops) + 1): # iterate over the symmetry operations that do not correspond to the identity
        #print "ind,symops[ind]['rot']",ind,symops[ind]['rot']
        rotmat = symops[ind]['rot']
        #print "rotmat[0,0]", rotmat[0,0]
        #print "rotmat[1,0]", rotmat[1,0]
        #print "rotmat[2,0]", rotmat[2,0]
        array_rot_nh_first = (array_ref[:,0] * rotmat[0,0]) + \
                         (array_ref[:,1] * rotmat[1,0]) + \
                         (array_ref[:,2] * rotmat[2,0])
        #print 'array_rot_nh_first',array_rot_nh_first
        array_rot_nh_second =  array_rot_nh_first.astype(int)
        #print 'array_rot_nh_second',array_rot_nh_second
        array_rot_nk_first = (array_ref[:,0] * rotmat[0,1]) + \
                         (array_ref[:,1] * rotmat[1,1]) + \
                         (array_ref[:,2] * rotmat[2,1])
        #print 'array_rot_nk_first',array_rot_nk_first
        array_rot_nk_second = array_rot_nk_first.astype(int)
        #print 'array_rot_nk_second',array_rot_nk_second
        array_rot_nl_first = (array_ref[:,0] * rotmat[0,2]) + \
                         (array_ref[:,1] * rotmat[1,2]) + \
                         (array_ref[:,2] * rotmat[2,2])
        #print 'array_rot_nl_first',array_rot_nl_first
        array_rot_nl_second =  array_rot_nl_first.astype(int)
        #print 'array_rot_nl_second',array_rot_nl_second
        test1 = numpy.not_equal(array_ref[:, 0], array_rot_nh_second)
        test2 = numpy.not_equal(array_ref[:, 1], array_rot_nk_second)
        test3 = numpy.not_equal(array_ref[:, 2], array_rot_nl_second)
        # np.logical_or.reduce((x, y, z))
        truth_sym = numpy.logical_or(numpy.logical_or(test1, test2), test3)
        print 'la hora de la verdad antes ',truth_sym
        if ind == 2:
            print 'first operation'
            total_array = numpy.copy(truth_sym)
        else:
            total_array = numpy.vstack((total_array,truth_sym))

    print 'total_array',total_array
    print 'total_array.sum(axis=0)', total_array.sum(axis=0)
    print '1.0+total_array.sum(axis=0)', 1.0+total_array.sum(axis=0)
    print 'numpy.sqrt(1.0+total_array.sum(axis=0))', numpy.sqrt(1.0+total_array.sum(axis=0))
    print 'numpy.sqrt(total_array.sum(axis=0))', numpy.sqrt(total_array.sum(axis=0))
    quit()





    quit()

    ############################################################################################

    for i, _ in enumerate(array_ref):
        ceps = 1.0  # counter for the epsilon factors
        for j in range(2, len(symops) + 1):  # Apply symmetry rotations and round to integer
            # EXAMPLE symop: 2: {'tra': [3/4.0, 3/4.0, 1/4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]}
            # NOTE CM: I can change this 1.001 to a direct round in python
            nh = int(
                1.001 * ((array_ref[i][0] * symops[j]['rot'][0][0]) +
                         (array_ref[i][1] * symops[j]['rot'][1][0]) +
                         (array_ref[i][2] * symops[j]['rot'][2][0])))
            nk = int(
                1.001 * ((array_ref[i][0] * symops[j]['rot'][0][1]) +
                         (array_ref[i][1] * symops[j]['rot'][1][1]) +
                         (array_ref[i][2] * symops[j]['rot'][2][1])))
            nl = int(
                1.001 * ((array_ref[i][0] * symops[j]['rot'][0][2]) +
                         (array_ref[i][1] * symops[j]['rot'][1][2]) +
                         (array_ref[i][2] * symops[j]['rot'][2][2])))
            if nh != array_ref[i][0] or nk != array_ref[i][1] or nl != array_ref[i][2]:
                continue # pasas directamente a la siguiente operacion de simetria
            else:
                ceps=+1
        epsilon.append(numpy.sqrt(ceps))
        dtemp= array_ref[i][0] ** 2 * coef2[0] + array_ref[i][1] ** 2 * coef2[1] + array_ref[i][2] ** 2 * coef2[2] + \
               array_ref[i][1] * array_ref[i][2] * coef3[0] + array_ref[i][0] * array_ref[i][2] * coef3[1] + \
               array_ref[i][0] * array_ref[i][1] * coef3[2]
        if dtemp<0:
            dtemp=abs(dtemp)
        onedsquared.append(dtemp)
        res_max = max([res_max, onedsquared[i]])
    # print '********************************** EPSILON'
    # for ele in epsilon:
    #     print ele
    # print '********************************** ONEDSQUARED'
    # for ele in onedsquared:
    #     print ele
    # print '**********************************'
    # quit()
    epsilon = numpy.array(epsilon)
    onedsquared = numpy.array(onedsquared)
    return epsilon, onedsquared, res_max

#@timing
def get_epsilon_1overdsquared_and_resmax(array_ref, symops, coef2, coef3):
    """ Computes the epsilon factors for each reflection, the 1/d for each reflection and the maximum 1/d value.

    epsilon factors: for certain classes of reflections, their indices map onto themselves  times upon application
    of the point group symmetry operations, and such a reflection therefore has  times the intensity of a general
    reflection.

    :param array_ref: bidimensional array which, for each reflection, contains, in float, H K L F FOM PHI sigF
    :type array_ref: list
    :param symops: symmetry operations obtained from dictio_space_groups[space_group_key]['symops'] Example in P3: {
                   1: {'tra': [0.0, 0.0, 0.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]},
                   2: {'tra': [0.0, 0.0, 0.0], 'rot': [[0.0, -1.0, 0.0], [1.0, -1.0, 0.0], [0.0, 0.0, 1.0]]},
                   3: {'tra': [0.0, 0.0, 0.0], 'rot': [[-1.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 1.0]]}}
    :type symops: dict
    :param coef2:
    :type coef2:
    :param coef3:
    :type coef3:
    :return:
    :rtype:
    """
    res_max = 0.0
    epsilon = []
    onedsquared = []
    for i, _ in enumerate(array_ref):
        ceps = 1.0  # counter for the epsilon factors
        for j in range(2, len(symops) + 1):  # Apply symmetry operations and round to integer
            # EXAMPLE symop: 2: {'tra': [3/4.0, 3/4.0, 1/4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]}
            # NOTE CM: I can change this 1.001 to a direct round in python
            nh = int(
                1.001 * ((array_ref[i][0] * symops[j]['rot'][0][0]) +
                         (array_ref[i][1] * symops[j]['rot'][1][0]) +
                         (array_ref[i][2] * symops[j]['rot'][2][0])))
            nk = int(
                1.001 * ((array_ref[i][0] * symops[j]['rot'][0][1]) +
                         (array_ref[i][1] * symops[j]['rot'][1][1]) +
                         (array_ref[i][2] * symops[j]['rot'][2][1])))
            nl = int(
                1.001 * ((array_ref[i][0] * symops[j]['rot'][0][2]) +
                         (array_ref[i][1] * symops[j]['rot'][1][2]) +
                         (array_ref[i][2] * symops[j]['rot'][2][2])))
            if nh != array_ref[i][0] or nk != array_ref[i][1] or nl != array_ref[i][2]:
                continue
            else:
                ceps=+1
        epsilon.append(numpy.sqrt(ceps))
        dtemp= array_ref[i][0] ** 2 * coef2[0] + array_ref[i][1] ** 2 * coef2[1] + array_ref[i][2] ** 2 * coef2[2] + array_ref[i][1] * array_ref[i][2] * coef3[0] + array_ref[i][0] * array_ref[i][2] * coef3[1] + array_ref[i][0] * array_ref[i][1] * coef3[2]
        if dtemp<0:
            # print 'dtemp is negative',dtemp
            # print 'array_ref[i][0]',array_ref[i][0]
            # print 'array_ref[i][1]', array_ref[i][1]
            # print 'array_ref[i][2]', array_ref[i][2]
            dtemp=abs(dtemp)
            #sys.exit(0)
        onedsquared.append(dtemp)
        res_max = max([res_max, onedsquared[i]])
    return epsilon, onedsquared, res_max


def get_epsilon_only(array_ref, symops):
    """

    :param array_ref:
    :type array_ref:
    :param symops:
    :type symops:
    :return:
    :rtype:
    """
    epsilon = []
    for i, _ in enumerate(array_ref):
        u = float(array_ref[i][0])
        v = float(array_ref[i][1])
        w = float(array_ref[i][2])
        cres = 1.0  # Cumulative resolution
        for j in range(2, len(symops) + 1):  # Apply symmetry operations and round to integer
            # EXAMPLE symop: 2: {'tra': [3/4.0, 3/4.0, 1/4.0], 'rot': [[1.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 1.0, 0.0]]}
            # NOTE about F1.001 and int: is just a trick to avoid rounding errors and no need of calling functions
            nh = int(
                1.001 * ((u * symops[j]['rot'][0][0]) + (v * symops[j]['rot'][0][1]) + (w * symops[j]['rot'][0][2])))
            nk = int(
                1.001 * ((u * symops[j]['rot'][1][0]) + (v * symops[j]['rot'][1][1]) + (w * symops[j]['rot'][1][2])))
            nl = int(
                1.001 * ((u * symops[j]['rot'][2][0]) + (v * symops[j]['rot'][2][1]) + (w * symops[j]['rot'][2][2])))
            if nh != array_ref[i][0] or nk != array_ref[i][1] or nl != array_ref[i][2]:
                continue
            else:
                cres = cres + 1
        epsilon.append(numpy.sqrt(cres))
    return epsilon

#@timing
def get_evalues_and_array_aux_numpy(epsilon, onedsquared, res_max, array_hkl):
    """

    :param epsilon:
    :type epsilon:
    :param onedsquared:
    :type onedsquared:
    :param res_max:
    :type res_max:
    :param array_hkl:
    :type array_hkl:
    :return:
    :rtype:
    """
    ###################################################
    # PENDING TO ACTUALLY CHANGE TO NUMPY EXPRESSIONS #
    ###################################################
    print 'warning: This function is not yet exploiting numpy appropiatedly, only final conversion'

    rbin = 20 / max([res_max, 0.0001])
    array_evalues = [[0, 0, 0, 0.0] for _ in xrange(len(array_hkl))]
    array_aux = [0.0 for _ in range(42)]
    for i, _ in enumerate(array_hkl):
        p = rbin * onedsquared[i]
        n = min([int(p), 19])  # n represents the index of the resolution bin we are filling
        p = p - float(n)
        q = 1.0 - p
        t = (array_hkl[i][3] / epsilon[i]) ** 2
        array_aux[n] = array_aux[n] + q * t
        array_aux[n + 1] = array_aux[n + 1] + p * t
        array_aux[n + 21] = array_aux[n + 21] + q
        array_aux[n + 22] = array_aux[n + 22] + p
    for j in range(21):
        array_aux[j] = (array_aux[j + 21]) / (max([array_aux[j], 0.0001]))
    for k, _ in enumerate(array_hkl):
        p = rbin * onedsquared[k]
        n = min([int(p), 19])
        p = p - float(n)
        q = 1.0 - p
        t = numpy.sqrt((array_aux[n]) * q + (array_aux[n + 1]) * p) / epsilon[k]
        array_evalues[k] = numpy.sqrt(
            numpy.sqrt(1. / (.00390625 + 1. / (math.pow(max([0.01, t * array_hkl[k][3]]), 4)))))
    array_aux = numpy.array(array_aux)
    array_evalues = numpy.array(array_evalues)
    return array_evalues, array_aux

#@timing
def get_evalues_and_array_aux(epsilon, onedsquared, res_max, array_hkl):
    """

    :param epsilon:
    :type epsilon:
    :param onedsquared:
    :type onedsquared:
    :param res_max:
    :type res_max:
    :param array_hkl:
    :type array_hkl:
    :return:
    :rtype:
    """

    rbin = 20 / max([res_max, 0.0001])
    array_evalues = [[0, 0, 0, 0.0] for _ in xrange(len(array_hkl))]
    array_aux = [0.0 for _ in range(42)]
    for i, _ in enumerate(array_hkl):
        p = rbin * onedsquared[i]
        n = min([int(p), 19])  # n represents the index of the resolution bin we are filling
        p = p - float(n)
        q = 1.0 - p
        t = (array_hkl[i][3] / epsilon[i]) ** 2
        array_aux[n] = array_aux[n] + q * t
        array_aux[n + 1] = array_aux[n + 1] + p * t
        array_aux[n + 21] = array_aux[n + 21] + q
        array_aux[n + 22] = array_aux[n + 22] + p
    for j in range(21):
        array_aux[j] = (array_aux[j + 21]) / (max([array_aux[j], 0.0001]))
    for k, _ in enumerate(array_hkl):
        p = rbin * onedsquared[k]
        #print '***************************'
        n = min([int(p), 19])
        p = p - float(n)
        q = 1.0 - p
        #print '***************************'
        t = numpy.sqrt((array_aux[n]) * q + (array_aux[n + 1]) * p) / epsilon[k]
        array_evalues[k] = numpy.sqrt(
            numpy.sqrt(1. / (.00390625 + 1. / (math.pow(max([0.01, t * array_hkl[k][3]]), 4)))))
    return array_evalues, array_aux


def get_FOMs_from_lst_files_in_folder(dictio_fragments, ent_present=False):
    """Get the figures of merit form the shelxe output files .lst

    :param dictio_fragments:
    :type dictio_fragments:
    :param ent_present:
    :type ent_present:
    :return:
    :rtype:
    """
    print "\nAnalysing FOMs from lst files "
    for pdb_name in dictio_fragments.keys():
        lst_file = open(pdb_name + '.lst', 'r')
        lst_content = lst_file.read()
        list_fom = extract_EFOM_and_pseudoCC_shelxe(lst_content)
        dictio_fragments[pdb_name]['efom'] = list_fom[0]
        dictio_fragments[pdb_name]['pseudocc'] = list_fom[1]
        dictio_fragments[pdb_name]['initcc'] = extract_INITCC_shelxe(lst_content)
        if ent_present:  # Only if post-mortem has been performed in shelxe
            list_MPE = extract_wMPE_shelxe(pdb_name + '.lst')
            dictio_fragments[pdb_name]['list_MPE'] = list_MPE
    return dictio_fragments


def get_FOMs_from_sum_files_in_folder(wd, clust_fold, dictio_fragments, gimble=True, program='BORGES',
                                      fragment=1):
    """ Get the LLG and ZSCORE for individual solutions from the SUM folder of either BORGES or LITE run.

    :param wd: working directory of the ARCIMBOLDO, BORGES OR SHREDDER run
    :type wd: str
    :param clust_fold: folder where the files for clustering or their links are located
    :type clust_fold: str
    :param dictio_fragments:
    :type dictio_fragments: dict
    :param ent_present:
    :type ent_present: bool
    :param program: ARCIMBOLDO or BORGES
    :type program: str
    :param fragment:
    :type fragment: int
    :return:
    :rtype:
    """
    inverted = False
    if program == 'ARCIMBOLDO':
        fragfold='ens1_frag'+str(fragment)
        sum_path_LLG = os.path.join(wd, fragfold+"/5_RNP_LIBRARY/clusters.sum")
        if os.path.exists(os.path.join(wd, fragfold+"/4_PACK_LIBRARY/clusters.sum")):
            sum_path_ZSCORE_1 = os.path.join(wd, fragfold+"/4_PACK_LIBRARY/clusters.sum")
            if os.path.exists(os.path.join(wd, fragfold+"/4.5_INVERTED_LIBRARY/clusters.sum")):
                sum_path_ZSCORE_2 = os.path.join(wd, fragfold+"/4.5_INVERTED_LIBRARY/clusters.sum")
                inverted = True
        else:  # Take the FOMS from the translation folder if no packing set
            sum_path_ZSCORE_1 = os.path.join(wd, fragfold+"/3_FTF_LIBRARY/clusters.sum")
        sol_refined, conv_names_refined = SELSLIB2.readClustersFromSUM(sum_path_LLG)
        sol_pack1, conv_names_pack1 = SELSLIB2.readClustersFromSUM(sum_path_ZSCORE_1)
        if inverted:
            sol_pack2, conv_names_pack2 = SELSLIB2.readClustersFromSUM(sum_path_ZSCORE_2)
        for clu in sol_refined:
            for item in clu["heapSolutions"].asList():
                prio, solu = item
                ensemble = solu['name']
                name = conv_names_refined[ensemble]
                id_frag = os.path.abspath(os.path.join(clust_fold, ((name.split("/"))[-1])[:-4]))
                if id_frag in dictio_fragments.keys():
                    dictio_fragments[id_frag]['llg'] = solu['llg']
                    dictio_fragments[id_frag]['rot_cluster'] = solu['original_rotcluster']
        for clu in sol_pack1:
            for item in clu["heapSolutions"].asList():
                prio, solu = item
                ensemble = solu['name']
                if ensemble in conv_names_refined.keys():
                    name = conv_names_refined[ensemble]
                    id_frag = os.path.abspath(os.path.join(clust_fold, ((name.split("/"))[-1])[:-4]))
                    if id_frag in dictio_fragments.keys():
                        dictio_fragments[id_frag]['zscore'] = solu['zscore']
        if inverted:
            for clu in sol_pack2:
                for item in clu["heapSolutions"].asList():
                    prio, solu = item
                    ensemble = solu['name']
                    if ensemble in conv_names_refined.keys():
                        name = conv_names_refined[ensemble]
                        id_frag = os.path.abspath(os.path.join(clust_fold, ((name.split("/"))[-1])[:-4]))
                        if id_frag in dictio_fragments.keys():
                            dictio_fragments[id_frag]['zscore'] = solu['zscore']
    elif program == 'BORGES':
        path_pack = os.path.join(wd, "7.5_PACK_Library")
        for rotclu in os.listdir(path_pack):
            sum_path_rottra = os.path.join(wd, "7.5_PACK_Library", rotclu, "clustersRed.sum")
            if gimble:
                sum_path_rbr = os.path.join(wd, "8_GIMBLE_LLG", rotclu, "clustersNoRed.sum")
            else:
                sum_path_rbr = os.path.join(wd, "8_RBR", rotclu, "clustersNoRed.sum")
            if os.path.exists(sum_path_rottra) and os.path.exists(sum_path_rbr):
                clusters_rottra, conv_names_rottra = SELSLIB2.readClustersFromSUM(sum_path_rottra)
                clusters_rbr, conv_names_rnp = SELSLIB2.readClustersFromSUM(sum_path_rbr)
            else:
                continue
            for clu in clusters_rottra:
                for item in clu["heapSolutions"].asList():
                    prio, solu = item
                    ensemble = solu['name']
                    name = conv_names_rottra[ensemble]
                    pdb_frag = ((name.split("/"))[-1])[:-4]
                    if len(ensemble.split('-')) > 1:
                        position = (((ensemble.split('.'))[0]).split('-'))[1]
                        id_frag1 = os.path.abspath(os.path.join(clust_fold, pdb_frag + '-' + position + "_rottra_" + rotclu))
                        id_frag2 = os.path.abspath(os.path.join(clust_fold, pdb_frag + '-' + position + "_rbr_" + rotclu))
                    elif len(ensemble.split('-')) == 1:
                        id_frag1 = os.path.abspath(os.path.join(clust_fold, pdb_frag + "_rottra_" + rotclu))
                        id_frag2 = os.path.abspath(os.path.join(clust_fold, pdb_frag + "_rbr_" + rotclu))
                    if id_frag1 in dictio_fragments.keys():
                        dictio_fragments[id_frag1]['llg'] = solu['llg']
                        #dictio_fragments[id_frag1]['rot_cluster'] = solu['n_prev_cluster']
                        dictio_fragments[id_frag1]['rot_cluster'] = solu['original_rotcluster']
                        dictio_fragments[id_frag1]['zscore'] = solu['zscore']
                    if id_frag2 in dictio_fragments.keys():
                        dictio_fragments[id_frag2]['rot_cluster'] = solu['original_rotcluster']
                        dictio_fragments[id_frag2]['zscore'] = solu['zscore']
            for clu in clusters_rbr:
                for item in clu["heapSolutions"].asList():
                    prio, solu = item
                    ensemble = solu['name']
                    name = conv_names_rnp[ensemble]
                    pdb_frag = ((name.split("/"))[-1])[:-4]
                    if len(ensemble.split('-')) > 1:
                        position = (((ensemble.split('.'))[0]).split('-'))[1]
                        id_frag = os.path.abspath(os.path.join(clust_fold, pdb_frag + '-' + position + "_rbr_" + rotclu))
                    elif len(ensemble.split('-')) == 1:
                        id_frag = os.path.abspath(os.path.join(clust_fold, pdb_frag + "_rbr_" + rotclu))
                    if id_frag in dictio_fragments.keys():
                        dictio_fragments[id_frag]['llg'] = solu['llg']
    return dictio_fragments


def get_symops_from_sg_dictionary(space_group_key):
    """

    :param space_group_key:
    :type space_group_key:
    :return:
    :rtype:
    """
    if isinstance(space_group_key, int):
        symops = dictio_space_groups[space_group_key]['symops']
    elif isinstance(space_group_key, str):
        try: # This will work if it is the sg number already and it is a standard setting
            space_group_key = int(space_group_key)
            symops = dictio_space_groups[space_group_key]['symops']
        except:
            symops = dictio_space_groups[space_group_key]['symops']
    else:
        print "Space group key is not valid"
        sys.exit()
    return symops


def get_origins_from_sg_dictionary(space_group_key):
    """

    :param space_group_key:
    :type space_group_key:
    :return:
    :rtype:
    """
    # EXAMPLE: 'origins_list': [[0.0, 0.0, 0.0], [1/2.0, 1/2.0, 1/2.0]],'polar': False
    if isinstance(space_group_key, int):
        origins = dictio_space_groups[space_group_key]['origins_list']
        polar_bool = dictio_space_groups[space_group_key]['polar']
    elif isinstance(space_group_key, str):
        try: # This will work if it is the sg number already and it is a standard setting
            space_group_key = int(space_group_key)
            origins = dictio_space_groups[space_group_key]['origins_list']
            polar_bool = dictio_space_groups[space_group_key]['polar']
        except: # This is for non standard settings
            origins = dictio_space_groups[space_group_key]['origins_list']
            polar_bool = dictio_space_groups[space_group_key]['polar']
    else:
        print "Space group key is not valid"
        sys.exit()
    return polar_bool, origins


def get_latt_from_sg_dictionary(space_group_key):
    """

    :param space_group_key:
    :type space_group_key:
    :return:
    :rtype:
    """
    if isinstance(space_group_key, int):
        latt = dictio_space_groups[space_group_key]['latt']
    elif isinstance(space_group_key, str):
        space_group_key = int(space_group_key)
        latt = dictio_space_groups[space_group_key]['latt']
    else:
        print "Space group key is not valid"
        sys.exit()
    return latt


def get_space_group_number_from_symbol(space_group_string):
    """

    :param space_group_string:
    :type space_group_string: str
    :return: either space group number (for standard ones) or the symbol, but always the key for the dictionary
    :rtype: int or str
    """
    for _, key in enumerate(dictio_space_groups.iterkeys()):
        search_string = ''.join(space_group_string.split())
        current_string = ''.join(dictio_space_groups[key]["symbol"].split())
        if search_string == current_string:
            print "\n Space group string given: ", space_group_string, "has been found in the dictionary", key
            return key
    # Only if we didn't return any value
    print "Space group not found"
    return None


# NOTE: Next function uses one from Massimo's Library. It has changed with the new algorithm
# TODO: Check if it works now anyway, could be useful
def get_list_ss_elements(pdbinicial, onlyhelix=True):
    """This function gets fragments of secondary structure from a given pdb and writes them in new independent pdbs. Input: name of the pdb,
    Boolean for extracting only helices (default true)"""
    current_wd = os.getcwd()
    if not (os.path.exists(os.path.join(current_wd, pdbinicial))):
        sys.exit("\nAn error has occurred. Please make sure that you have provide a pdb file with extension .pda")
    list_dict_elements = []  # List with a dictionary per fragment
    tuplaresultado = Bioinformatics.getFragmentListFromPDB(pdbinicial, False,
                                                           False)  # def getFragmentListFromPDB(pdbf,isModel,drawDistri)
    structure, list_dic_frag = tuplaresultado[0], tuplaresultado[1]
    if onlyhelix == True:
        for frag in list_dic_frag:
            if (frag['sstype'] == 'ch' or frag['sstype'] == 'ah'):
                list_dict_elements.append(frag)
            else:
                continue
    if onlyhelix == False:
        for frag in list_dic_frag:
            list_dict_elements.append(frag)
    cab = open(pdbinicial, "r")
    pdb_content = cab.read()
    cryst_card = extract_cryst_card_pdb(pdb_content)
    cab.close()
    for i in range(len(list_dict_elements)):
        if (list_dict_elements[i])["fragLength"] >= 4:
            tuplaresultado2 = Bioinformatics.getPDBFormattedAsString(str(0), [list_dict_elements[i]], structure,
                                                                     "./")  # def getPDBFormattedAsString(nModel,lista,strucActualPDB, pathBase, dizioConv = {}, externalRes=[], useDizioConv=True, normalize=False, bfactorNor=25.0)
            filename, filecont = tuplaresultado2[0], tuplaresultado2[1]
            residue_first = filename.split("_")[1]
            filename = pdbinicial[:-4] + "_" + residue_first.strip() + "_" + list_dict_elements[i][
                'sstype'] + "_s" + str((list_dict_elements[i])[
                                           "fragLength"]) + ".pda"  # Overwrite the one that Bioinformatics returns with a more informative one
            fichero = open(filename, "w")
            fichero.write(filecont)
            fichero.close()
            add_cryst_card(cryst_card, filename)
    return True


def get_1st_2nd_MPE_from_phstat_print_output(phstat_print_output):
    """ This function reads the output from a phstat_print job. It can be used only for NON-POLAR spacegroups jobs. It returns two tuples containing on the first item the MPE and in the second one the coordinates of the origin shift associate. E.g. (83.847999999999999, ('0.00000', '0.00000', '0.00000')) """
    lineas_memoria = phstat_print_output.split("\n")
    start_read = False
    best = False
    lista_MPE = []
    first = False
    for t in range(len(lineas_memoria)):
        # print lineas_memoria[t]
        if best and len(lineas_memoria[t]) == 0:
            break
        # print "first",first,"best",best,"start_read",start_read,lineas_memoria[t].startswith("best")
        if first and not start_read and lineas_memoria[t].startswith("best"):
            # print "first lo devo mettere a False"
            first = False
        if first or (best and not (not start_read and lineas_memoria[t].startswith("best"))):
            # print "first",first,"best",best,"start_read",start_read,lineas_memoria[t].startswith("best")
            start_read = False
            guardar = lineas_memoria[t].split()
            # print guardar
            dictio_valores_MPE = lista_MPE[-1]
            if guardar[1] != "******":
                valor_MPE = float(guardar[1])
                lista_shifts = (guardar[2], guardar[3], guardar[4])
                dictio_valores_MPE.push(valor_MPE, lista_shifts)
        if lineas_memoria[t].startswith(" Cluster analysis cycle   1"):
            start_read = True
            first = True
            lista_MPE.append(ADT.Heap())
        if start_read and lineas_memoria[t].startswith("best"):
            best = True
            start_read = False
            first = False
            lista_MPE.append(ADT.Heap())
        elif not start_read and lineas_memoria[t].startswith("best"):
            best = True
            start_read = False
            first = False
            lista_MPE.append(ADT.Heap())
    lista_MPE = lista_MPE[:-1]
    for yt in range(len(lista_MPE)):
        item = lista_MPE[yt]
        primero = item.pop()
        segundo = item.pop()
    print "primero", primero
    print "segundo", segundo
    return primero, segundo


def get_mpe_against_fcf_of_all_phs_in_folder(dirname, path_phstat, resolution=1.0):
    """ This function calls call_phstat_for_final_MPE and obtains the MPE related to the .fcf of all the files in the folder.
    Be sure to have the .ins and .fcf files with the correct name for the fragments on the folder too """
    fiz = open("results_final_MPE" + resolution + ".txt", "w")
    del fiz
    print resolution
    for f in os.listdir(dirname):
        if f[-3:] == "phs":
            modelo = open(f[:-4] + ".ls", "w")
            modelo.write(f[:-4] + ".phs")
            del modelo
            name_phstat = f[:-4]
            alixe_library.call_phstat_for_final_MPE(name_phstat, path_phstat, dirname, resolution)
            print err
            print memoria
            v = memoria.split("\n")
            for k in range(len(v)):
                lineav = v[k]
                listav = lineav.split()
                if len(listav) >= 2 and listav[0] == "N" and listav[1] == "wMPE":
                    wmpe = float(((v[k + 1]).split())[1])
                    print "\nMPE of  " + f[:-4] + " to the final structure is " + str(wmpe)
                    fiz = open("results_final_MPE" + resolution + ".txt", "a")
                    fiz.write("\nMPE of  " + f[:-4] + " to the final structure is " + str(wmpe))
                    del fiz


def get_files_from_ARCIMBOLDO_for_ALIXE(wd, clust_fold, fragment=1,hard_limit_phs=1000):
    """ Links the files from the 6_EXP_VAL folder of a given ens1_fragN folder in an ARCIMBOLDO_LITE run

    :param wd: the working directory, where the ARCIMBOLDO_LITE job was launched
    :type wd: str
    :param clust_fold: the folder where to put the links and do the clustering
    :type clust_fold: str
    :param fragment: to decide which ens1_fragN folder to use
    :type fragment: int
    :param hard_limit_phs: maximum number of phs files to retrieve
    :type hard_limit_phs: int
    :return:
    :rtype:
    """
    list_phs = []
    dict_sorted_input = {}
    list_chosen = []
    fragfolder='ens1_frag'+str(fragment)
    path_expval = os.path.join(wd, fragfolder+ '/6_EXPVAL_LIBRARY')
    path_sum = os.path.join(path_expval, 'solCC.sum')
    ccval, convnames = SELSLIB2.readCCValFromSUM(path_sum)
    if hard_limit_phs == 0:
        print '\n No hard limit set for the number of phs files to get, ' \
              'setting it to the total number of solutions'
        hard_limit_phs = len(ccval)
    for i in range(len(ccval)):
        if i != hard_limit_phs:
            fullpath = ccval[i]['corresp']
            name_file = (os.path.split(fullpath)[1])[:-4]
            list_chosen.append(name_file)
            rot_cluster = ccval[i]['cluster']
            if rot_cluster not in dict_sorted_input.keys():
                dict_sorted_input[rot_cluster] = []  # You create it first
                dict_sorted_input[rot_cluster].append(
                    os.path.join(clust_fold, name_file + ".phs"))  # And then save the solution
            else:
                dict_sorted_input[rot_cluster].append(os.path.join(clust_fold, name_file + ".phs"))
        else:
            break
    dirs1 = [d for d in os.listdir(path_expval) if os.path.isdir(os.path.join(path_expval, d))]
    for dir1 in dirs1:
        next_step = os.path.join(path_expval, dir1)
        for file in os.listdir(next_step):
            if file.endswith('.tar.gz') and (file[:-7] in list_chosen):
                tar_file = tarfile.open(os.path.join(next_step, file))
                tar_file.extractall(path=clust_fold)
                members = tar_file.getmembers()
                for member in members:
                    name_file = member.name[2:]
            elif file[-3:] == "pdb" and (file[:-4] in list_chosen):
                os.link(os.path.join(next_step, file), clust_fold + file[:-4] + '.pda')
                list_phs.append(os.path.join(clust_fold, file[:-4] + ".phs"))

    if len(list_phs) <= 1:
        print "\nThere aren't enough files to cluster them within ALIXE"

    return dict_sorted_input

def get_files_from_9_EXP_BORGES(wd, clust_fold, cluster_id, mode=9, hard_limit_phs=10000):
    """ This function links the phs, lst and pdb (as pda) files from the 9*EXP in the clustering folder.

    :param wd:
    :type wd:
    :param clust_fold:
    :type clust_fold:
    :param cluster_id:
    :type cluster_id:
    :param mode: mode argument can be 9,9.5, or 9.6, corresponding to refined, rototranslated, and NMA analyzed solutions
    :type mode: str
    :param hard_limit_phs:
    :type hard_limit_phs:
    :return:
    :rtype:
    """
    folder_initcc = None
    list_chosen = []
    list_phs = []
    for folder in os.listdir(wd):
        if folder == "9.5_EXP" and mode == 9.5:
            mod = "rottra"
            folder_initcc = os.path.join(wd, folder)
        elif folder == "9_EXP" and mode == 9:
            mod = "rbr"
            folder_initcc = os.path.join(wd, folder)
        elif folder == "9.6_EXP" and mode == 9.6:
            mod = "nma"
            folder_initcc = os.path.join(wd, folder)
    cluster_folder = os.path.join(wd, folder_initcc, str(cluster_id))
    n_cluster = str(cluster_id)
    path_sum = os.path.join(cluster_folder, 'solCC.sum')
    ccval, convnames = SELSLIB2.readCCValFromSUM(path_sum)
    if hard_limit_phs == 0:
        print 'No hard limit set, setting it to the total number of solutions, ',len(ccval)
        hard_limit_phs = len(ccval)
    for i in range(len(ccval)):
        if i <= hard_limit_phs:
            fullpath = ccval[i]['corresp']
            name_file = (os.path.split(fullpath)[1])[:-4]
            list_chosen.append(name_file)
            list_phs.append(os.path.join(clust_fold, name_file + "_" + mod + "_" + n_cluster + ".phs"))
        else:
            print '\n Hitting the hard limit for the number of phs files to consider, which is',hard_limit_phs
            print '\n We will use ',i,' files out of ',len(ccval)
            break
    dirs = [d for d in os.listdir(cluster_folder) if
            os.path.isdir(os.path.join(cluster_folder, d))]  # Need to check how many subfolders are for that cluster
    for i in range(len(dirs)):
        next_step = os.path.join(wd, folder_initcc, n_cluster, str(i))  # 0, 1, etc cada uno 1000 sol
        for file in os.listdir(next_step):
            if file.endswith('.tar.gz') and (file[:-7] in list_chosen):
                tar_file = tarfile.open(os.path.join(next_step, file))
                tar_file.extractall(path=clust_fold)
                members = tar_file.getmembers()
                for member in members:
                    model_fullname = member.name  # Example case with not filtering solutions: frag136A_0_0-21.pdb
                    model_name = model_fullname[:-4]
                    if model_fullname[-4:] == ".phs":
                        os.rename(os.path.join(clust_fold, model_fullname),
                                  clust_fold + "/" + model_name + "_" + mod + "_" + n_cluster + ".phs")
                    if model_fullname[-4:] == ".lst":
                        os.rename(os.path.join(clust_fold, model_fullname),
                                  clust_fold + "/" + model_name + "_" + mod + "_" + n_cluster + ".lst")
            if file[-3:] == "pdb" and (file[:-4] in list_chosen):
                model_name = file[:-4]
                os.link(os.path.join(next_step, file),
                        clust_fold + "/" + model_name + "_" + mod + "_" + n_cluster + ".pda")
    return list_phs


def get_link_to_name_shelxe(name_shelxe, name_file_to_link, extension):
    """Links a file with a certain extension to a new one suitable for shelxe (name_shelxe) They should be on the same folder)"""
    try:
        size_extension = len(extension)
        os.link(name_file_to_link + "." + extension, name_shelxe[:-(size_extension + 1)] + "." + extension)
    except Exception:
        exctype, value = sys.exc_info()[:2]
        print "\n EXCEPTION IN GET LINK TO NAME SHELXE An error has occurred:\n" + str(exctype) + "\n" + str(value)


def get_links_for_all_pdas(dirname, name_file_to_link, extension):
    """Calls get_link_to_name_shelxe recursively to get the links to a certain file for all the pdas present in the directory"""
    list_files = list_files_by_extension(dirname, "pda")
    for file in list_files:
        get_link_to_name_shelxe(os.path.join(dirname, file), os.path.join(dirname, name_file_to_link), extension)


def get_shelxe_line_from_html_output(name_job, wd):
    '''Shelxe line is to be read from the html called as the name_job given as argument. This is done because if the shelxe line is the default one it will not appear in the bor file'''
    name_html = name_job + ".html"
    path_html = os.path.join(wd, name_html)
    file_html = open(path_html, 'r')
    lines_html = file_html.readlines()
    regexline = re.compile('^shelxe_line')
    for i in range(len(lines_html)):
        if bool(regexline.findall(lines_html[i])):
            shelxe_line = ((lines_html[i].split("="))[1]).strip()
            # print "shelxe_line",shelxe_line
            break
    return shelxe_line


def get_topexp_from_html_output(name_job, wd):
    '''topexp is to be read from the html called as the name_job given as argument'''
    name_html = name_job + ".html"
    path_html = os.path.join(wd, name_html)
    file_html = open(path_html, 'r')
    lines_html = file_html.readlines()
    regexline = re.compile('^topexp')
    for i in range(len(lines_html)):
        if bool(regexline.findall(lines_html[i])):
            topexp = ((lines_html[i].split("="))[1]).strip()
            if (lines_html[i].split("="))[0].startswith('topexp_1'):
                return topexp
            elif (lines_html[i].split("="))[0].startswith('topexp_n'):
                pass
            elif (lines_html[i].split("="))[0].startswith('topexp'):
                return topexp
    return topexp


def generate_fake_ins_for_shelxe(path_ins, cell, sg_number):
    symm_cards = dictio_space_groups[sg_number]['symm_cards']
    file_ins = open(path_ins, 'w')
    file_ins.write('CELL  1.54178  %6.3f  %6.3f  %6.3f  %6.2f%  6.2f%  6.2f\n' % (
    cell[0], cell[1], cell[2], cell[3], cell[4], cell[5]))
    latt = dictio_space_groups[sg_number]['latt']
    file_ins.write('LATT -' + str(latt) + '\n')
    for card in symm_cards:
        file_ins.write(card)
    file_ins.write('SFAC  C  H  N  O\n')  # SHELXE will not use it so it can be the same
    file_ins.write('UNIT  576 1152 192 192\n')
    del file_ins

def generate_fake_pda_for_phstat(path_pda, cell, sg_number):
    # CRYST1   58.630   60.360  113.880  90.00  90.00  90.00 P 21 21 21
    symbol=dictio_space_groups[sg_number]["symbol"]
    file_pda= open(path_pda, 'w')
    file_pda.write(unitCellTools.writeCRYSTCARDintoPDB(cell[0], cell[1], cell[2], cell[3], cell[4], cell[5],sgsymbol=symbol,znum=1))
    del file_pda



# TODO: change to general function to catch exceptions creating a folder
def generate_clustering_folder(clust_fold):
    try:
        os.mkdir(clust_fold)
        print "Creating CLUSTERING folder"
    except OSError:
        exctype, value = sys.exc_info()[:2]
        print exctype, value
        if str(value).startswith("[Errno 17] File exists:"):  # Then the folder exists
            print 'Clustering folder already exists, its contents will be overwritten if ALIXE is run. Exiting now...'
            sys.exit()
        elif str(value).startswith("[Errno 13] Permission denied:"):
            print 'The path to the clustering folder can not be created due to permission denied. Exiting now...'
            sys.exit()


def generate_input_lists_for_ALIXE_by_rotclu(dictio_fragments):
    dictio_input = {}
    list_rot_cluster = get_list_rotation_clusters_from_dictio_fragments(dictio_fragments)
    for rotclu in list_rot_cluster:
        dictio_input[rotclu] = []
        for frag in dictio_fragments.keys():
            if dictio_fragments[frag]['rot_cluster'] == rotclu:
                (dictio_input[rotclu]).append(frag + ".phs")
    return dictio_input


def generate_input_dictio_for_ALIXE_by_references(list_phs, list_references):
    dictio_ref = {}
    for phs in list_phs:
        if phs in list_references:
            dictio_ref[phs] = True
        else:
            dictio_ref[phs] = False
    return dictio_ref


def list_files_by_extension(path, extension,fullpath=True):
    """ Searches over all the files and in a directory, and if their extension is the one given, saves it

    :param path: path where to search for the files
    :param extension: extension searched for
    :param fullpath: boolean indicating whether to return the fullpath or the basename
    :return:
    """

    def listdir_fullpath(d):
        return [os.path.join(d, f) for f in os.listdir(d)]

    list_files = []
    wd = os.getcwd()
    for f in listdir_fullpath(os.path.join(wd, path)):
        if f.endswith(extension):
            if fullpath:
                list_files.append(os.path.abspath(f))
            else:
                list_files.append(os.path.basename(f))
    if len(list_files) >= 1:
        print "\nI found "+str(len(list_files))+" "+extension+" files"
        return list_files
    else:
        print "\nI didn't found any files with the extension ",extension
        return None


def merge_dicts(*dict_args):
    '''
    Given any number of dicts, shallow copy and merge into a new dict,
    precedence goes to key value pairs in latter dicts.
    '''
    result = {}
    for dictionary in dict_args:
        result.update(dictionary)
    return result


# NOTE: esta funcion requiere el input en la forma que autoalixe lo genera
def merge_rotation_clusters(clusters_first_round, list_rot_clu):
    dict_conv = {}
    for clu in clusters_first_round.keys():
        if len(clusters_first_round[clu]['rot_clust_list']) > 1:
            # Pick up one and then convert all the others to this
            ##        print "sorted(clusters_first_round[clu]['rot_clust_list'])",sorted(clusters_first_round[clu]['rot_clust_list'])
            chosen = sorted((clusters_first_round[clu]['rot_clust_list']))[0]
            ##        print "chosen",chosen
            not_chosen = sorted((clusters_first_round[clu]['rot_clust_list']))[1]
            ##        print "not chosen",not_chosen
            clusters_first_round[clu]['rot_clust_list'] = [chosen]
            dict_conv[not_chosen] = chosen
    ##        print "dict_conv",dict_conv
    list_to_remove = []
    for clu in clusters_first_round.keys():
        ##    print "dict_conv.keys()",dict_conv.keys()
        element = (clusters_first_round[clu]['rot_clust_list'])[0]
        ##    print "element",element
        ##    print "element in dict_conv.keys()",element in dict_conv.keys()
        if element in dict_conv.keys():
            value = dict_conv[element]
            print "Changing ", element, " to ", value
            clusters_first_round[clu]['rot_clust_list'] = [value]
            list_to_remove.append(element)
    # Now we will generate the list for iterating and combining on the second clustering step
    new_list_rot = []
    for rot in list_rot_cluster:
        if rot in list_to_remove:
            continue
        else:
            new_list_rot.append(rot)
    return clusters_first_round, new_list_rot


# Next function uses shelxe to generate a map file (.phs) using the arguments given as command line. It needs the argument line and the name for the pda and hkl file that shelxe will read
def phase_fragment_with_shelxe(linea_arg, name_shelxe, wd, shelxe_path):
    """Uses shelxe with the arguments in linea_arg to obtain the .phs file with the phases of the fragments"""
    # Check the files are really there
    data_filename = name_shelxe + ".hkl"
    pda_filename = name_shelxe + ".pda"
    if not (((os.path.exists(os.path.join(wd, data_filename))) and (os.path.exists(os.path.join(wd, pda_filename))))):
        sys.exit(
            "\nAn error has occurred. Please make sure that you have provide a data file in shelxe format .hkl and a pdb file with extension .pda")
    command_line = []
    command_line.append(shelxe_path)
    command_line.append(pda_filename)
    arguments = linea_arg.split()
    print "\n Arguments for this call: " + str(arguments)
    for i in range(len(arguments)):
        command_line.append(arguments[i])
    print "\nCommand line for this call", ' '.join(command_line)
    try:
        p = subprocess.Popen(command_line, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                             cwd=wd)
        complete_output, errors = p.communicate()
        return complete_output
    except Exception:
        exctype, value = sys.exc_info()[:2]
        print "\n An error has occurred:\n" + str(exctype) + "\n" + str(value)


def phase_round_with_shelxe(linea_arg, lista_clusters, wd, path_shelxe, hkl_path, ins_path, ent_path, fragment_type):
    """

    :param linea_arg:
    :type linea_arg:
    :param lista_clusters:
    :type lista_clusters:
    :param wd:
    :type wd:
    :param path_shelxe:
    :type path_shelxe:
    :param hkl_path:
    :type hkl_path:
    :param ins_path:
    :type ins_path:
    :param ent_path:
    :type ent_path:
    :param fragment_type:
    :type fragment_type:
    :return:
    :rtype:
    """
    for i in range(len(lista_clusters)):
        name_shelxe = os.path.split(lista_clusters[i])[1]
        print "\nPreparing expansion of ", name_shelxe
        path_name_shelxe = os.path.join(wd, name_shelxe)
        if fragment_type == 'pda':
            shutil.copyfile(lista_clusters[i] + ".pda", path_name_shelxe + ".pda")
        if fragment_type == 'phi':
            shutil.copyfile(lista_clusters[i] + ".phi", path_name_shelxe + ".phi")
            os.link(ins_path, path_name_shelxe + '.ins')
        if ent_path != None:  # Only for test cases where we have the ent file
            os.link(ent_path, path_name_shelxe + '.ent')
        os.link(hkl_path, path_name_shelxe + '.hkl')
        if fragment_type == 'pda':
            output = phase_fragment_with_shelxe(linea_arg, name_shelxe, wd, path_shelxe)
        elif fragment_type == 'phi':
            output = phase_with_shelxe_from_phi(linea_arg, name_shelxe, wd, path_shelxe)
        finalcc = extract_best_CC_shelxe(output)
        print '\nThis expansion produced a final cc of ', finalcc
        # # TODO: maybe put this as a parameter, like a stop if solved
        # if finalcc > 30.0:
        #     print "Your structure was probably solved, ALIXE will stop now"
        #     sys.exit()
        # else:
        #     print 'This autotracing test did not achieve a CC higher than 30, we will keep expanding'
        #     continue


def phase_with_shelxe_from_phi(linea_arg, name_shelxe, wd, path_shelxe):
    """Uses shelxe with the arguments in linea_arg to obtain the .phs file using as input a .phi file"""
    # Check the files are really there
    data_filename = name_shelxe + ".hkl"
    phi_filename = name_shelxe + ".phi"
    ins_filename = name_shelxe + ".ins"
    if not (((os.path.exists(os.path.join(wd, data_filename))) and (os.path.exists(os.path.join(wd, phi_filename))) and (
    os.path.exists(os.path.join(wd, ins_filename))))):
        sys.exit(
            "\n An error has occurred. Please make sure that you have provide a data file in shelxe format .hkl, a map file with extension .phi and a .ins file. ")
    # Prepare command line
    command_line = []
    command_line.append(path_shelxe)
    command_line.append(phi_filename)
    arguments = linea_arg.split()
    print "\n Arguments for this call: " + str(arguments)
    for i in range(len(arguments)):
        command_line.append(arguments[i])
    print "\nCommand line for this call", ' '.join(command_line)

    # Try to execute the process
    try:
        p = subprocess.Popen(command_line, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                             cwd=wd)
        complete_output, errors = p.communicate()
        return complete_output
    except Exception:
        exctype, value = sys.exc_info()[:2]
        print "\n An error has occurred:\n" + str(exctype) + "\n" + str(value)
        return None


def phase_all_pdas_in_folder(linea_arg, dirname, shelxe_path):
    """ This function calls phase_fragment_with_shelxe and phases all .pdas in the folder given with the arguments in linea_arg.
    Be sure to have the .hkl files with the correct name for the fragments on the folder too """
    for f in os.listdir(dirname):
        if f[-3:] != "pda":
            continue
        if os.path.isfile(os.path.join(dirname, f)):
            name_shelxe = f[:-4]
            output = phase_fragment_with_shelxe(linea_arg, name_shelxe, dirname, shelxe_path)
            lines = output.split("\n")
            for i in range(len(lines)):
                if lines[i].startswith(" Overall CC between native Eobs and Ecalc (from fragment)"):
                    print "\n I've calculated phases for the information contained in " + str(
                        f) + " and the CC between native Eobs and Ecalc is " + lines[i].split()[10] + " .\n"
    print "Finished generating phases from the fragments with these arguments: " + linea_arg + "\n\nFor more information, have a look to the .lst files\n\n"

def prepare_phstat_command_line(weight,orisub,resolution,):
    arguments_phstat = ["-r" + str(resolution), "-s" + str(seed), "-t" + str(global_tolerance), "-c" + str(cycles)]
    if weight == 'e':
        arguments_phstat.append('-e')
    if orisub == 'sxosfft':
        arguments_phstat.append('-o')
    arguments_phstat_text = ' '.join(arguments_phstat) + '\n'

# NOTE: very old, for the models from old grinder
def prepare_windows_for_clusterization(fragment_list, size_window, overlapping=False):
    # First we iterate over the name of the fragments. We will fill a dictionary
    dictio_models = {}
    # print fragment_list
    for frag in fragment_list:
        list_elements_name = frag.split("_")
        ##        print list_elements_name
        model_id = list_elements_name[2]
        # If the entry for that id_model key is not in the dictionary, we create it. Otherwhise, we add
        if model_id in dictio_models:
            (dictio_models[model_id]).append(frag)
        elif model_id not in dictio_models:
            dictio_models[model_id] = []
            dictio_models[model_id].append(frag)
    # We need to know first model_id and last one in order to define the windows and the stop point for the loop
    list_id = []
    for key in sorted(dictio_models.iterkeys()):
        list_id.append(key)
    first_id = list_id[0]
    last_id = list_id[-1]
    print "\n First model is " + str(first_id)
    print "\n Last model is " + str(last_id)
    # Calculate if there will be windows of smaller size
    total_models = len(list_id)
    modulus = total_models % size_window
    if overlapping == True:
        # Now we are ready to iterate over the dictionary in windows
        print "int(first_id)", int(first_id)
        print "int(last_id)", int(last_id)
        print "size_window", size_window
        print "int(last_id)+1-size_window", int(last_id) + 1 - size_window
        print "range(int(first_id),int(last_id)+2-size_window)", range(int(first_id), int(last_id) + 2 - size_window)
        for mid in range(int(first_id), int(last_id) + 2 - size_window):
            list_models_windows = []
            index = str(mid)
            ##            print "\n dictio_models[index]   ",dictio_models[index]
            for i in range(size_window):
                list_models_windows = list_models_windows + dictio_models[str(int(index) + i)]
            ##            list_models_windows=dictio_models[index]+dictio_models[str(mid+1)]+dictio_models[str(mid+2)]
            ##            print "\n list_models_windows   ", list_models_windows
            # Now we can use that list to print an .ls file
            ls_file = open("megacluster_" + index + "_" + str((mid + size_window) - 1) + ".ls", 'w')
            del ls_file
            for phase_file in list_models_windows:
                ls_file = open("megacluster_" + index + "_" + str((mid + size_window) - 1) + ".ls", 'a')
                ls_file.write(phase_file + ".phs" + "\n")
                del ls_file
    elif overlapping == False:
        # Now we are ready to iterate over the dictionary in windows
        for mid in range(int(first_id), int(last_id) + 2 - size_window, size_window):
            index = str(mid)
            list_models_windows = []
            ##            print "\n dictio_models[index]   ",dictio_models[index]
            for j in range(size_window):
                list_models_windows = list_models_windows + dictio_models[str(int(index) + j)]
            ##            print "\n list_models_windows   ", list_models_windows
            # Now we can use that list to print an .ls file
            ls_file = open("megacluster_" + index + "_" + str((mid + size_window) - 1) + ".ls", 'w')
            del ls_file
            for phase_file in list_models_windows:
                ls_file = open("megacluster_" + index + "_" + str((mid + size_window) - 1) + ".ls", 'a')
                ls_file.write(phase_file + ".phs" + "\n")
                del ls_file
                # TODO por si hay ventanas resto  MUY IMPORTANTE SI USO NON OVERLAPPING TENGO QUE IMPLEMENTARLO
                ##        if modulus>0:
                ##            for mod in range()

#@timing
def read_cell_from_ins(path_ins):
    """
    Reads the unit cell parameters from a shelxe instruction file

    Keyword arguments:
    path_ins -- path to the shelxe ins file

    Returns:
    float_cell -- list with six floats, a, b, c, alpha, beta, gamma
    wavelength -- float, not always present in ins file so not always returned
    """
    wavelength = None
    file_ins = open(path_ins, 'r')
    lines_ins = file_ins.readlines()
    for line in lines_ins:
        if line.startswith("CELL"):
            items = line.split()
            if len(items) == 8:  # If there are seven items, the first is assumed to be the wavelength
                wavelength = float(items[1])
                cell = [items[2], items[3], items[4], items[5], items[6], items[7]]
                float_cell = [float(i) for i in cell]
            elif len(items) == 7:
                cell = [items[1], items[2], items[3], items[4], items[5], items[6]]
                float_cell = [float(i) for i in cell]
            break
    return float_cell, wavelength

#@timing
def read_cell_and_sg_from_pdb(path_pdb):
    """


    Keyword arguments:
    path_pdb --


    Returns:

    """
    pdb_file = open(path_pdb, 'r')
    pdb_content = pdb_file.read()
    del pdb_file
    pdb_lines = pdb_content.split("\n")
    for linea in pdb_lines:
        if linea.startswith("CRYST1"):
            cryst_card = linea
            space_group = (cryst_card[55:67]).strip()  # SG in characters 56 - 66
            list_values = cryst_card.split()  # Cell elements
            cell = [list_values[1], list_values[2], list_values[3], list_values[4], list_values[5], list_values[6]]
            float_cell = [float(i) for i in cell]
            return float_cell, space_group

#@timing
def read_phstat_clusterization_output(complete_output, cycles):
    """This function, given the string that contains the complete phstat output from a clusterization run
     and the number of cycles given in it, returns the MPE of the second file with respect with the reference one,
     as well as a dictionary dictio_result[counter]={"step":0,"wMPE":0.00,"file":name_of_the_file} """
    # Initializing  variables
    regex_start = re.compile('Cluster analysis cycle\s*1(?![0-9])')
    regex_end = re.compile('Cluster analysis cycle\s*%s' % (str(cycles)))
    lines_output = complete_output.split("\n")
    start_read_elements = False
    end_of_info = False
    MPE_to_ref = None
    dictio_result = {}
    counter = 0
    for i in range(len(lines_output)):
        if bool(regex_start.findall((lines_output[i - 3]).strip())):
            # print "I've found first cycle"
            if lines_output[i + 1] == "":
                no_cluster = True
                list_elements = lines_output[i].split()
                if len(list_elements) == 3:  # There has been an overflow like this 1******** 6.46   2y4t.phs
                    dictio_result[1] = {"wMPE": None, "file": list_elements[2]}
                MPE_to_ref = 0.00
                if len(list_elements) == 4:
                    dictio_result[1] = {"wMPE": list_elements[1], "file": list_elements[3]}
                break
            elif lines_output[i + 1] != "":
                line_MPE_to_ref = lines_output[i + 1]
                MPE_to_ref = (line_MPE_to_ref.split())[1]
        if lines_output[i] == "" and start_read_elements == True:
            end_of_info = True
            start_read_elements = False
        if bool(regex_end.findall((lines_output[i - 3]).strip())):
            ##            print "I've found last cycle"
            start_read_elements = True
        if start_read_elements == True and end_of_info == False:
            no_cluster = False
            list_elements = lines_output[i].split()
            counter = counter + 1
            dictio_result[counter] = {"wMPE": list_elements[1], "file": list_elements[3]}
    return MPE_to_ref, dictio_result

#@timing
def read_phstat_print_clusterization_output(ls_file_content, complete_output, cycles):
    """This function, given the string that contains the complete phstat print output from a clusterization run, the number of cycles and the original ls file
    reads what has been clustered and the origin shift applied to each of the files clustere. Valid for non-polar space groups"""
    # Vamos a dividirlo todo en 2 partes: en una leemos los origin shifts aplicadosy en otra eliminamos la parte del output que es propia de phstat print y lo
    # dejamos normal para poder leerlo con la funcin que ya tenemos. Necesitamos el ls para poder saber el orden que corresponde a los fragmentos.
    # best MPE ---> uno por cada fichero que haba en el ls, pero solo me quedar con los de lo que clusteriza al final
    # MPE ---> Hay n por cada best MPE, siendo n la cantidad de orgenes posibles para ese grupo espacial
    regex_best = re.compile('best MPE')
    # Parte para leer que ha clusterizado
    lines_output = complete_output.split('\n')
    trimmed_output = open("trimmed_output", 'w')
    for i in range(len(lines_output)):
        if lines_output[i].endswith("shelxe."):
            number_phs_in_ls = (lines_output[i + 2].split())[0]
            # print "\n There are "+str(number_phs_in_ls)+"  files in the phstat output"
        elif lines_output[i].endswith("switch."):
            number_phs_in_ls = (lines_output[i + 2].split())[0]
            # print "\n There are "+str(number_phs_in_ls)+"  files in the phstat output"
        if not (lines_output[i].startswith("MPE=") or lines_output[i].startswith("best MPE") or lines_output[
            i].startswith("final shifts")):
            trimmed_output.write(lines_output[i] + "\n")
    del trimmed_output  # Con este ya podemos usar nuestra funcin normal para leer lo que ha clusterizado
    trimmed_file = open("trimmed_output", 'r')
    trimmed_content = trimmed_file.read()
    MPE_to_ref, dictio_result = read_phstat_clusterization_output(trimmed_content, cycles)
    # print "Dictio result from trimmed output",dictio_result
    os.remove("trimmed_output")
    # Parte para obtener los shifts
    content_cycle3 = (complete_output.split("cycle"))[3]  # split que me deja el contenido del ciclo 1
    # print "\n CONTENT_CYCLE_3",content_cycle3
    lines_cycle3 = content_cycle3.split("\n")
    dictio_best = {}
    list_key_best = []
    # Necesitas los ficheros en orden y los MPE en orden para poder guardar en un diccionario los valores de shift asociados a cada fragmento
    # Tendremos que dejar las lineas de los ficheros limpias para poder leerlas
    ##    print "ls_file_content",ls_file_content
    files_in_ls = ls_file_content.split()
    phs_files = False
    phi_files = False
    # print "files_in_ls",files_in_ls
    for k in range(len(files_in_ls)):
        if files_in_ls[k].endswith(".phs"):
            phs = files_in_ls[k].strip()
            phs_files = True
            list_key_best.append(phs)
        elif files_in_ls[k].endswith(".phi"):
            phi = files_in_ls[k].strip()
            phi_files = True
            list_key_best.append(phi)
        ##    print "\n list_key_best",list_key_best # Lista con los phs en el orden en el que estn en el ls y por tanto en el que se evaluaran sus best
    # Encontramos donde tenemos Best MPE en el primer ciclo
    list_best = []
    for j in range(len(lines_cycle3)):
        if bool(regex_best.findall(lines_cycle3[j])):
            ##            print "Best MPE found! ", lines_cycle1[j] # Los MPE en el mismo orden en el que estan los ficheros en el ls, los podemos guardar ya.
            list_best.append(lines_cycle3[
                                 j])  # de momento toda la linea, luego el valor del shift y el MPE: example best MPE 34.714  0.00000  0.50000  0.50000
    # print 'complete_output',complete_output
    # print "Checking consistency and number of best_MPEs"
    # print "\t len(list_best)",len(list_best)
    # print "\t len(files_in_ls)",len(files_in_ls)
    if len(list_best) != len(files_in_ls):
        print "Something wrong happened. There are more best MPE than files in the ls"
        sys.exit(0)
    for x, y in zip(list_key_best, list_best):
        if y.split()[2] == '******':
            dictio_best[x] = {'wMPE': None, 'shift': [float(y.split()[3]), float(y.split()[4]), float(y.split()[5])],
                              'diff_wMPE': None, 'mapcc': None}
            print "There has been an overflow in the MPE calculation, saving a value of None in wMPE"
        else:
            dictio_best[x] = {'wMPE': float(y.split()[2]),
                              'shift': [float(y.split()[3]), float(y.split()[4]), float(y.split()[5])],
                              'diff_wMPE': None, 'mapcc': None}
    list_in_clu = []
    # print "Dictio_best before", dictio_best
    for s in range(1, len(dictio_result) + 1):
        if phs_files == True:
            phs = dictio_result[s]['file']
            # Los que no estn en dictio_result los quiero borrar
            list_in_clu.append(phs)
        elif phi_files == True:
            phi = dictio_result[s]['file']
            list_in_clu.append(phi)
    # Haremos la interseccion de sets
    set_clu = set(list_in_clu)
    ##    print "set_clu",set_clu
    set_best = set(list_key_best)
    ##    print "set_best",set_best
    list_to_remove = list(
        set_best.difference(set_clu))  # Tiene que ser en este orden pq siempre el set mayor ser el del best
    ##    print "list_to_remove",list_to_remove
    if number_phs_in_ls == 1:
        print "There was no clustering"
        return None
    else:
        for n in range(len(list_to_remove)):
            dictio_best = removeKeyDict(dictio_best, list_to_remove[n])
        # print "Dictio_best after", dictio_best
        # Ahora ya devolvemos resultados
        return dictio_best

# NOTE CM duplicated from read_phstat_isa_clusterization_output
def read_phstat_isa_multiseed_clusterization_output(complete_output,cycles,n_files):
    """ Reads and returns the information from both the first and the last cycle of a phstat run

    :param complete_output: string that contains the complete phstat output
    :type complete_output: str
    :param cycles: number of cycles phstat run
    :type cycles: int
    :param n_files: number of input files phstat run
    :type n_files: int
    :return: dictionary with the results and float with total running time
    :rtype:
    """

    regex_start = re.compile('Cluster analysis cycle\s*1(?![0-9])')
    regex_end = re.compile('Cluster analysis cycle\s*%s' % (str(cycles)))
    regex_time = re.compile('Total time')
    regex_files = re.compile('phase files found in')
    lines_output = complete_output.split("\n")
    any_cluster = True
    seed_tested = False


    # NOTE CM: for the multiseed, we need to find how many instances of the cycle 1 are
    ncycle_one=len(re.findall(regex_start, complete_output))
    ncycle_three = len(re.findall(regex_end, complete_output))
    if ncycle_one==n_files-1 and ncycle_three==0:
        any_cluster = False
        not_clustered_refs = ncycle_one + 1
        seed_tested = True
    else:
        any_cluster = True
        if ncycle_one>1:
            not_clustered_refs = ncycle_one - 1
            seed_tested = True
        else: # Then there was a cluster with the first reference
            not_clustered_refs=0
            seed_tested=False
    count_no_clu=0


    dictio_result = {}
    sorted_input_files = []

    for i in range(len(lines_output)):

        # Reading how many phs were read by chescat
        if bool(regex_files.findall(lines_output[i])):
            for pepi in xrange(i+2,i+n_files+2,1):
                sorted_input_files.append(lines_output[pepi].strip())
            assert len(sorted_input_files) == n_files

        if bool(regex_time.findall(lines_output[i])):
            total_time=float(lines_output[i].split()[0])

        if bool(regex_start.findall((lines_output[i - 3]).strip())):
            if lines_output[i + 1] == "":
                no_cluster = True
                list_elements = lines_output[i].split()
                count_no_clu=count_no_clu+1
                if len(list_elements) == 9:
                    namefile = list_elements[8]
                    shiftx = float(list_elements[5])
                    shifty = float(list_elements[6])
                    shiftz = float(list_elements[7])
                    shift = [shiftx, shifty, shiftz]
                    mapcc = float(list_elements[4])
                    if list_elements[2]!='********':
                        wmpd = float(list_elements[2])
                        diff_wmpd = float(list_elements[3])
                        dictio_result[namefile] = {"wMPE_first": wmpd,
                                                           "shift_first": shift,'mapcc_first':mapcc,
                                                           'diff_wMPE_first': diff_wmpd,
                                                           "wMPE_last": wmpd,
                                                           "shift_last": shift,'mapcc_last':mapcc,
                                                           'diff_wMPE_last': diff_wmpd}
                    else:
                        dictio_result[namefile] = {"wMPE_first": -1.0,
                                                            "shift_first": shift,
                                                            'mapcc_first': mapcc,
                                                            'diff_wMPE_first': -1.0,
                                                            "wMPE_last": -1.0,
                                                            "shift_last": shift,
                                                            'mapcc_last': mapcc,
                                                            'diff_wMPE_last': -1.0}
                # NOTE CM: only if this is not the last cycle 1 we have, save that this was a not clustered reference
                if count_no_clu <= not_clustered_refs:
                    dictio_result[namefile]['ref_no_cluster']=True

            elif lines_output[i + 1] != "":
                # something has clustered and I need to save this information from first cycle somehow
                no_cluster = False
                for k in range(0,n_files):
                    line_MPE_to_ref = lines_output[i + k]
                    list_elements = line_MPE_to_ref.split()
                    if len(list_elements) == 9:
                        namefile = list_elements[8]
                        shiftx = float(list_elements[5])
                        shifty = float(list_elements[6])
                        shiftz = float(list_elements[7])
                        shift = [shiftx, shifty, shiftz]
                        mapcc = float(list_elements[4])
                        if list_elements[2] != '********':
                            wmpd = float(list_elements[2])
                            diff_wmpd = float(list_elements[3])
                            dictio_result[namefile] = {"wMPE_first": wmpd, "shift_first": shift,
                                                               'mapcc_first': mapcc, 'diff_wMPE_first':diff_wmpd}
                        else:
                            dictio_result[namefile] = {"wMPE_first": -1.0, "shift_first": shift,
                                                               'mapcc_first': mapcc, 'diff_wMPE_first': -1.0}
                        if wmpd == 0.0:
                            dictio_result[namefile]['ref_no_cluster'] = False
                        else:
                            dictio_result[namefile]['ref_no_cluster'] = 'cluster'
                    if line_MPE_to_ref == "":
                        break

        if bool(regex_end.findall((lines_output[i - 3]).strip())):
            for l in range(0, n_files):
                line_MPE_to_ref = lines_output[i + l]
                list_elements = line_MPE_to_ref.split()
                if len(list_elements) == 9:
                    namefile=list_elements[8]
                    shiftx = float(list_elements[5])
                    shifty = float(list_elements[6])
                    shiftz = float(list_elements[7])
                    shift = [shiftx, shifty, shiftz]
                    mapcc = float(list_elements[4])
                    if list_elements[2] != '********':
                        if dictio_result.has_key(list_elements[8]):
                            wmpd = float(list_elements[2])
                            diff_wmpd = float(list_elements[3])
                            dictio_result[namefile]["wMPE_last"]=wmpd
                            dictio_result[namefile]["diff_wMPE_last"] = diff_wmpd
                            dictio_result[namefile]["shift_last"]=shift
                            dictio_result[namefile]['mapcc_last']=mapcc
                        else:
                            #print 'There are more files in the last cycle than in the first, handling now'
                            dictio_result[namefile]={"wMPE_first":-1.0,"shift_first":[-1.0,-1.0,-1.0],
                                                     'mapcc_first':-1.0,'diff_wMPE_first': -1.0,
                                                     "wMPE_last":wmpd,"shift_last":shift,
                                                     'mapcc_last':mapcc,"diff_wMPE_last":diff_wmpd}
                    else:
                        if dictio_result.has_key(namefile):
                            dictio_result[namefile]["wMPE_last"]=-1.0
                            dictio_result[namefile]["shift_last"]=shift
                            dictio_result[namefile]['mapcc_last']=mapcc
                        else:
                            #print 'There are more files in the last cycle than in the first, handling now'
                            wmpd = float(list_elements[2])
                            diff_wmpd = float(list_elements[3])
                            dictio_result[namefile]={"wMPE_first":-1.0,"shift_first":[-1.0,-1.0,-1.0],
                                                     'mapcc_first':-1.0,'diff_wMPE_first': -1.0,
                                                     'wMPE_last':wmpd,"shift_last":shift,
                                                     'mapcc_last':mapcc,"diff_wMPE_last":diff_wmpd}

                    if 'ref_no_cluster' not in dictio_result[namefile].keys():
                        dictio_result[namefile]['ref_no_cluster']='cluster'
                if line_MPE_to_ref == "":
                    break

    for j in range(i,len(lines_output)):
        if bool(regex_time.findall(lines_output[j])):
            total_time=float(lines_output[j].split()[0])

    for key in dictio_result.keys():
        if not dictio_result[key].has_key('wMPE_last'):
            dictio_result[key]["wMPE_last"] = -1.0
            dictio_result[key]["shift_last"] = [-1.0, -1.0, -1.0]
            dictio_result[key]["mapcc_last"] = -1.0
            dictio_result[key]['diff_wMPE_last']= -1.0

    if not any_cluster:
        for fichi in sorted_input_files:
            if fichi not in dictio_result.keys():
                dictio_result[fichi]={'wMPE_last': 0.0, 'diff_wMPE_first': 0.0,
                                                       'ref_no_cluster': True, 'wMPE_first': 0.0,
                                                       'mapcc_first': -1.0, 'shift_first': [0.0, 0.0, 0.0],
                                                       'shift_last': [0.0, 0.0, 0.0], 'diff_wMPE_last': 0.0,
                                                       'mapcc_last': -1.0}
    return dictio_result,total_time,seed_tested


def read_phstat_isa_clusterization_output(complete_output,cycles,n_files):
    """ Reads and returns the information from both the first and the last cycle of a phstat run

    :param complete_output: string that contains the complete phstat output
    :type complete_output: str
    :param cycles: number of cycles phstat run
    :type cycles: int
    :param n_files: number of input files phstat run
    :type n_files: int
    :return: dictionary with the results and float with total running time
    :rtype:
    """

    regex_start = re.compile('Cluster analysis cycle\s*1(?![0-9])')
    regex_end = re.compile('Cluster analysis cycle\s*%s' % (str(cycles)))
    regex_time = re.compile('Total time')
    lines_output = complete_output.split("\n")

    dictio_result = {}

    for i in range(len(lines_output)):

        if bool(regex_time.findall(lines_output[i])):
            total_time=float(lines_output[i].split()[0])

        if bool(regex_start.findall((lines_output[i - 3]).strip())):
            if lines_output[i + 1] == "":
                no_cluster = True
                list_elements = lines_output[i].split()
                if len(list_elements) == 9:
                    namefile = list_elements[8]
                    shiftx = float(list_elements[5])
                    shifty = float(list_elements[6])
                    shiftz = float(list_elements[7])
                    shift = [shiftx, shifty, shiftz]
                    mapcc = float(list_elements[4])
                    if list_elements[2]!='********':
                        wmpd = float(list_elements[2])
                        diff_wmpd = float(list_elements[3])
                        dictio_result[namefile] = {"wMPE_first": wmpd,
                                                           "shift_first": shift,'mapcc_first':mapcc,
                                                           'diff_wMPE_first': diff_wmpd,
                                                           "wMPE_last": wmpd,
                                                           "shift_last": shift,'mapcc_last':mapcc,
                                                           'diff_wMPE_last': diff_wmpd}
                    else:
                        dictio_result[namefile] = {"wMPE_first": -1.0,
                                                            "shift_first": shift,
                                                            'mapcc_first': mapcc,
                                                            'diff_wMPE_first': -1.0,
                                                            "wMPE_last": -1.0,
                                                            "shift_last": shift,
                                                            'mapcc_last': mapcc,
                                                            'diff_wMPE_last': -1.0}
                break
            elif lines_output[i + 1] != "":
                no_cluster = False
                for k in range(0,n_files):
                    line_MPE_to_ref = lines_output[i + k]
                    list_elements = line_MPE_to_ref.split()
                    if len(list_elements) == 9:
                        namefile = list_elements[8]
                        shiftx = float(list_elements[5])
                        shifty = float(list_elements[6])
                        shiftz = float(list_elements[7])
                        shift = [shiftx, shifty, shiftz]
                        mapcc = float(list_elements[4])
                        if list_elements[2] != '********':
                            wmpd = float(list_elements[2])
                            diff_wmpd = float(list_elements[3])
                            dictio_result[namefile] = {"wMPE_first": wmpd, "shift_first": shift,
                                                               'mapcc_first': mapcc, 'diff_wMPE_first':diff_wmpd}
                        else:
                            dictio_result[namefile] = {"wMPE_first": -1.0, "shift_first": shift,
                                                               'mapcc_first': mapcc, 'diff_wMPE_first': -1.0}
                    if line_MPE_to_ref == "":
                        break

        if bool(regex_end.findall((lines_output[i - 3]).strip())):
            for l in range(0, n_files):
                line_MPE_to_ref = lines_output[i + l]
                list_elements = line_MPE_to_ref.split()
                if len(list_elements) == 9:
                    namefile=list_elements[8]
                    shiftx = float(list_elements[5])
                    shifty = float(list_elements[6])
                    shiftz = float(list_elements[7])
                    shift = [shiftx, shifty, shiftz]
                    mapcc = float(list_elements[4])
                    if list_elements[2] != '********':
                        if dictio_result.has_key(list_elements[8]):
                            wmpd = float(list_elements[2])
                            diff_wmpd = float(list_elements[3])
                            dictio_result[namefile]["wMPE_last"]=wmpd
                            dictio_result[namefile]["diff_wMPE_last"] = diff_wmpd
                            dictio_result[namefile]["shift_last"]=shift
                            dictio_result[namefile]['mapcc_last']=mapcc
                        else:
                            #print 'There are more files in the last cycle than in the first, handling now'
                            dictio_result[namefile]={"wMPE_first":-1.0,"shift_first":[-1.0,-1.0,-1.0],
                                                     'mapcc_first':-1.0,'diff_wMPE_first': -1.0,
                                                     "wMPE_last":wmpd,"shift_last":shift,
                                                     'mapcc_last':mapcc,"diff_wMPE_last":diff_wmpd}
                    else:
                        if dictio_result.has_key(namefile):
                            dictio_result[namefile]["wMPE_last"]=-1.0
                            dictio_result[namefile]["shift_last"]=shift
                            dictio_result[namefile]['mapcc_last']=mapcc
                        else:
                            #print 'There are more files in the last cycle than in the first, handling now'
                            wmpd = float(list_elements[2])
                            diff_wmpd = float(list_elements[3])
                            dictio_result[namefile]={"wMPE_first":-1.0,"shift_first":[-1.0,-1.0,-1.0],
                                                     'mapcc_first':-1.0,'diff_wMPE_first': -1.0,
                                                     'wMPE_last':wmpd,"shift_last":shift,
                                                     'mapcc_last':mapcc,"diff_wMPE_last":diff_wmpd}
                if line_MPE_to_ref == "":
                    break

    for j in range(i,len(lines_output)):
        if bool(regex_time.findall(lines_output[j])):
            #print '**** SHERLOCK lines_output[j]',lines_output[j]
            total_time=float(lines_output[j].split()[0])
        else:
            #print 'SHERLOCK lines_output[j]',lines_output[j]
            total_time=-1

    for key in dictio_result.keys():
        if not dictio_result[key].has_key('wMPE_last'):
            dictio_result[key]["wMPE_last"] = -1.0
            dictio_result[key]["shift_last"] = [-1.0, -1.0, -1.0]
            dictio_result[key]["mapcc_last"] = -1.0
            dictio_result[key]['diff_wMPE_last']= -1.0

    return dictio_result,total_time


#timing
def read_hkl_file(path_hkl):
    '''Reads a phs file and saves it as a list of lists'''
    array_phs = []
    file_hkl = open(path_hkl, 'r')
    reflections = file_hkl.readlines()
    for i, refle in enumerate(reflections):
        list_values = refle.split()  # format: H K L F sigF or H K L I sigI
        h = int(list_values[0])
        k = int(list_values[1])
        l = int(list_values[2])
        f = float(list_values[3])
        sigF = float(list_values[4])
        array_phs.append([h, k, l, f, sigF])
    return array_phs

#@timing
def read_phs_file_numpy(path_phs):
    """ Reads a phs file and saves data into array

    :param path_phs: path to the phases file to be read
    :type path_phs: str
    :return: array with the processed information
    :rtype: numpy array
    """
    #file_phs = open(path_phs, 'r')
    #reflections = file_phs.readlines()
    # format of reflections lines: H K L F FOM PHI sigF

    dfrm = pandas.read_table(path_phs,header=None,delim_whitespace=True,dtype=float)
    array_phs_np = dfrm.values
    return array_phs_np

#@timing
def read_phs_file(path_phs):
    """ Reads a phs file and saves data into array

    :param path_phs: path to the phases file to be read
    :type path_phs: str
    :return: array with the processed information
    :rtype: list of lists
    """
    file_phs = open(path_phs, 'r')
    reflections = file_phs.readlines()
    # format of reflections lines: H K L F FOM PHI sigF
    array_phs = [ [ float(ele) for _,ele in enumerate(refleline.split()) ]  for refleline in reflections ]
    return array_phs

#@timing
def read_phi_file(path_phi):
    '''Reads a phi file and saves it as a list of lists'''
    # array_phs = []
    file_phi = open(path_phi, 'r')
    reflections = file_phi.readlines()
    # for i, refleline in enumerate(reflections):
    #     list_values = refleline.split()  # format: H K L F FOM PHI
    #     h = int(list_values[0])
    #     k = int(list_values[1])
    #     l = int(list_values[2])
    #     f = float(list_values[3])
    #     fom = float(list_values[4])
    #     phi = float(list_values[5])
    #     array_phs.append([h, k, l, f, fom, phi])
    array_phs = [[float(ele) for _, ele in enumerate(refleline.split())] for refleline in reflections]
    return array_phs

#@timing
def reduce_array_phs_to_PHI_and_FOM(array_phs):
    """
    :param array_phs:
    :type array_phs:
    :return:
    :rtype:
    """
    reduced_array = [[refle[4], refle[5]] for _, refle in enumerate(array_phs)]
    return reduced_array

#@timing
def reduce_array_phs_to_PHI_and_FOM_numpy(array_phs):
    """
    :param array_phs:
    :type array_phs:
    :return:
    :rtype:
    """
    reduced_array = array_phs[:,4:6]
    return reduced_array



# TODO: Darle tambien como input la cryst card y asegurarme de que luego la tiene
def rewrite_pdb(path_pdb, cryst_card):
    # Save the remarks to put them back again
    pdb_file = open(path_pdb, "r")
    pdb_lines = pdb_file.readlines()
    del pdb_file
    list_line_remarks = []
    for line in pdb_lines:
        if line.startswith("REMARK"):
            list_line_remarks.append(line)
    parser = PDBParser()
    structure = parser.get_structure(path_pdb[:-4], path_pdb)
    last_chain_i = 0
    # TODO: check if there is more than one model, but this is not expected
    for chain in Selection.unfold_entities(structure, 'C'):
        chain.id = "A"
        for i, residue in enumerate(Selection.unfold_entities(chain, 'R')):
            ##            print "RESIDUE ID BEFORE", residue.get_full_id()
            i = last_chain_i + i + 1  # Primero porque queremos que empiece en 1
            residue.id = (' ', i, ' ')
        last_chain_i = i
    w = PDBIO()
    w.set_structure(structure)
    w.save(path_pdb)
    pdb_file = open(path_pdb, "r")
    pdb_lines = pdb_file.readlines()
    del pdb_file
    pdb_file = open(path_pdb, "w")
    pdb_file.write(cryst_card + "\n")
    for line in list_line_remarks:
        pdb_file.write(line)
    for i in range(len(pdb_lines)):
        pdb_file.write(pdb_lines[i])
    del pdb_file

#@timing
def rename_models_simple(name_model, list_models):
    f = open("traceback_names_solutions", 'w')
    del f
    for i in range(len(list_models)):
        os.rename(list_models[i] + ".pda", "m_" + name_model + "_sol_" + str(i) + ".pda")
        os.rename(list_models[i] + ".lst", "m_" + name_model + "_sol_" + str(i) + ".lst")
        os.rename(list_models[i] + ".phs", "m_" + name_model + "_sol_" + str(i) + ".phs")
        f = open("traceback_names_solutions", 'a')
        f.write(list_models[i] + " ------> m" + name_model + "sol" + str(i) + "\n")
        del f


def removeKeyDict(d, key):
    r = dict(d)
    del r[key]
    return r


def sort_list_phs_rotclu_by_FOM(list_phs_full, fom_sorting,dictio_fragments):
    # Sort the phase sets according to established FOM
    list_tuple_sort = []
    for phs in list_phs_full:
        phs_key = phs[:-4]
        list_tuple_sort.append((phs, dictio_fragments[phs_key]['zscore'], dictio_fragments[phs_key]['llg'],
                                dictio_fragments[phs_key]['initcc']))
    if fom_sorting == 'CC':
        list_tuple_sort.sort(key=lambda x: x[3], reverse=True)
    elif fom_sorting == 'LLG':
        list_tuple_sort.sort(key=lambda x: x[2], reverse=True)
    elif fom_sorting == 'ZSCORE':
        list_tuple_sort.sort(key=lambda x: x[1], reverse=True)
    list_phs_rotclu = [list_tuple_sort[i][0] for i in range(len(list_tuple_sort))]
    return list_phs_rotclu

#@timing
def sort_ls_file_by_CC(name_ls):
    """ This function reorders a given .ls file according to the CC of the phase files it contains. For that, it need to have on the same directory the .lst files output from
    SHELXE when obtaining the phases. It will overwrite the previous file """
    # Leer el ls para ver cuantos .phs hay
    fichero_ls = open(name_ls, "r")
    lineas_fichero_ls = fichero_ls.readlines()
    del fichero_ls
    numero_phs = len(lineas_fichero_ls)
    print "\nHay " + str(numero_phs) + " ficheros .phs en " + name_ls
    dictio_CC = {}
    for j in range(numero_phs):
        name_file = (lineas_fichero_ls[j].split())[0]
        # Guardar el dato del CC con su nombre de fichero en un diccionario declarado fuera del bucle
        # Leer correspondiente fichero lst y tomar el CC
        # TODO: Check all lst files are there and if not, print an error message and exit
        lst = open(name_file[:-4] + ".lst", 'r')
        lineas_lst = lst.readlines()
        for k in range(len(lineas_lst)):
            if lineas_lst[k].startswith(" Overall CC between native Eobs and Ecalc (from fragment) = "):
                CC = float(((lineas_lst[k].split())[10])[:-1])
                dictio_CC[name_file] = CC
                break
    # Obtener una lista ordenada con los ficheros y sus CC
    sorted_dict_CC = sorted(dictio_CC.iteritems(), key=operator.itemgetter(1), reverse=True)
    # Escribir un nuevo ls
    ls = open(name_ls, "w")
    del ls
    for index in range(len(sorted_dict_CC)):
        ls = open(name_ls, "a")
        ls.write(sorted_dict_CC[index][0] + "\n")
        del ls

#@timing
def sort_reflections_phs(array_refle):
    '''Sorts an array of reflections in ascending order of first h, then k, and then l'''
    array_refle.sort(key=operator.itemgetter(2, 1, 0))
    return array_refle

#@timing
def sort_reflections_phs_numpy(array_refle):
    '''Sorts an array of reflections in ascending order of first h, then k, and then l'''
    #array_refle.sort(key=operator.itemgetter(2, 1, 0))
    array_refle = array_refle[array_refle[:, 2].argsort()]  # First sort doesn't need to be stable.
    array_refle = array_refle[array_refle[:, 1].argsort(kind='mergesort')]
    array_refle = array_refle[array_refle[:, 0].argsort(kind='mergesort')]
    return array_refle



# TODO: test that it actually works and applies the shift as expected (for example, test in coot)
# TODO: do it using the BioPython.PDB to work with the files
# TODO: either change this function or create a new one in which instead of converting twice, what you do
# is changing the vector for the shift from crystalline to orthogonal, and apply it directly to the pdb
# ATOM_FORMAT_STRING="%s%6i %-4s%c%3s %c%4i%c   %8.3f%8.3f%8.3f%6.2f%6.2f      %4s%2s%2s\n"
# parser=PDBParser()
# structure=parser.get_structure(pdb_model[:-4],pdb_model)
def shifting_coordinates(shift, pdbfile):
    """Applies a shift to the x,y,z coordinates of a given pdb.
    IT NEEDS TO HAVE THE CRYST CARD
    IT IS USED FOR PHSTAT SHIFTS"""
    # We need the CRYST card
    print "Reading ", pdbfile[:-4] + ".pda", " in order to apply a shift"
    pda = open(pdbfile[:-4] + ".pda")
    lineaspda = pda.readlines()
    pda.close()
    cell_dim = [0, 0, 0, 0, 0, 0]
    parameters = {}
    for i in range(len(lineaspda)):
        if lineaspda[i].startswith("CRYST1"):
            cryst_card = lineaspda[i]
            cell_dim[0] = float((lineaspda[i].split())[1])
            cell_dim[1] = float((lineaspda[i].split())[2])
            cell_dim[2] = float((lineaspda[i].split())[3])
            cell_dim[3] = float((lineaspda[i].split())[4])
            cell_dim[4] = float((lineaspda[i].split())[5])
            cell_dim[5] = float((lineaspda[i].split())[6])
    parser = PDBParser()
    structure = parser.get_structure(pdbfile[:-4], pdbfile)
    list_all_atoms = Selection.unfold_entities(structure, 'A')  # lista con todos los tomos de ese pdb
    for atom in list_all_atoms:
        ##        print "Before:",atom.get_coord()
        coord_before = atom.get_coord()
        x = coord_before[0]
        y = coord_before[1]
        z = coord_before[2]
        x, y, z, parameters = SELSLIB2.convertFromOrthToFrac(x, y, z, cell_dim, parameters)
        crist_coord = [x, y, z]
        new_coord = [0, 0, 0]
        # Luego aplicamos el shift
        new_coord[0] = crist_coord[0] + float(shift[0])
        new_coord[1] = crist_coord[1] + float(shift[1])
        new_coord[2] = crist_coord[2] + float(shift[2])
        # Reconvertimos a ortogonales para escribirlas
        ort_x, ort_y, ort_z, parameters = SELSLIB2.convertFromFracToOrth(new_coord[0], new_coord[1], new_coord[2], cell_dim,
                                                                parameters)
        atom.set_coord([ort_x, ort_y, ort_z])
    ##        print "After: ",atom.get_coord()
    io = PDBIO()
    io.set_structure(structure)
    io.save(pdbfile[:-4] + "_shifted.pda")
    pdb_file = open(pdbfile[:-4] + "_shifted.pda", "r")
    pdb_lines = pdb_file.readlines()
    del pdb_file
    pdb_file = open(pdbfile[:-4] + "_shifted.pda", "w")
    pdb_file.write(cryst_card + "\n")
    for i in range(len(pdb_lines)):
        pdb_file.write(pdb_lines[i])
    del pdb_file


def shifting_coordinates_inverse(shift, pdbfile, outputfile=""):
    """Applies the inverse shift to one given to all the x,y,z coordinates of a given pdb.
    IT NEEDS TO HAVE THE CRYST CARD
    IT IS USED FOR SHELXE SHIFTS"""
    # We need the CRYST card
    print "Reading ", pdbfile[:-4] + ".pda", " in order to apply a shift"
    # NOTE: Here I changed the following line for using the original extension of the pdbfile
    # pda=open(pdbfile[:-4]+".pda")
    pda = open(pdbfile, "r")

    lineaspda = pda.readlines()
    pda.close()
    cell_dim = [0, 0, 0, 0, 0, 0]
    parameters = {}
    for i in range(len(lineaspda)):
        if lineaspda[i].startswith("CRYST1"):
            cryst_card = lineaspda[i]
            cell_dim[0] = float((lineaspda[i].split())[1])
            cell_dim[1] = float((lineaspda[i].split())[2])
            cell_dim[2] = float((lineaspda[i].split())[3])
            cell_dim[3] = float((lineaspda[i].split())[4])
            cell_dim[4] = float((lineaspda[i].split())[5])
            cell_dim[5] = float((lineaspda[i].split())[6])
    parser = PDBParser()
    structure = parser.get_structure(pdbfile[:-4], pdbfile)
    list_all_atoms = Selection.unfold_entities(structure, 'A')  # lista con todos los tomos de ese pdb
    for atom in list_all_atoms:
        ##        print "Before:",atom.get_coord()
        coord_before = atom.get_coord()
        x = coord_before[0]
        y = coord_before[1]
        z = coord_before[2]
        x, y, z, parameters = SELSLIB2.convertFromOrthToFrac(x, y, z, cell_dim, parameters)
        crist_coord = [x, y, z]
        new_coord = [0, 0, 0]
        ##        print "crist_coord before",crist_coord
        # Luego aplicamos el shift, pero restando en vez de sumando
        new_coord[0] = crist_coord[0] - float(shift[0])
        new_coord[1] = crist_coord[1] - float(shift[1])
        new_coord[2] = crist_coord[2] - float(shift[2])
        # Reconvertimos a ortogonales para escribirlas
        ##        print "shift",shift
        ##        print "crist_coord after",new_coord
        ort_x, ort_y, ort_z, parameters = SELSLIB2.convertFromFracToOrth(new_coord[0], new_coord[1], new_coord[2], cell_dim,
                                                                parameters)
        atom.set_coord([ort_x, ort_y, ort_z])
    ##        print "After: ",atom.get_coord()
    io = PDBIO()
    io.set_structure(structure)
    if outputfile == "":
        outputfile = pdbfile[:-4] + "_shifted.pda"
    io.save(outputfile)
    pdb_file = open(outputfile, "r")
    pdb_lines = pdb_file.readlines()
    del pdb_file
    pdb_file = open(outputfile, "w")
    pdb_file.write(cryst_card + "\n")
    for i in range(len(pdb_lines)):
        pdb_file.write(pdb_lines[i])
    del pdb_file
    return outputfile

#@timing
def trimByContinuityLimit(pdb_file, min_size):
    """

    :param pdb_file:
    :type pdb_file:
    :param min_size:
    :type min_size:
    :return:
    :rtype:
    """
    parser = PDBParser()
    structure = parser.get_structure(pdb_file[:-4], pdb_file)
    residues = Selection.unfold_entities(structure, 'R')
    list_id = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890"
    dictio_chainid = {}
    residues_to_remove = []
    current_listres = []
    index = 0
    for i in range(len(residues) - 1):
        res1 = residues[i]
        res2 = residues[i + 1]
        id1 = res1.id
        id2 = res2.id
        # print 'id1',id1
        check = Bioinformatics.checkContinuity(res1, res2)
        # print 'check',check
        # print 'list_id[index]',list_id[index]
        if check == True:
            # print "These two residues are consecutive",res1,res2
            if id1 not in current_listres:
                current_listres.append(id1)
            dictio_chainid[id1] = list_id[index]
            if id2 not in current_listres:
                current_listres.append(id2)
            dictio_chainid[id2] = list_id[index]
            # print 'list_id[index]',list_id[index]
            # print 'id1,dictio_chainid[id1]',dictio_chainid[id1],id1
            # print 'id2,dictio_chainid[id2]',dictio_chainid[id2],id2
        elif check == False:
            # print "current_listres beginning check",current_listres
            # print "These two residues are not consecutive",id1,id2
            if id1 not in current_listres:
                current_listres.append(id1)
                dictio_chainid[id1] = list_id[index]
            if len(current_listres) < min_size:
                # print "      The removal condition is fullfilled"
                # print "      residues_to_remove before",residues_to_remove
                residues_to_remove.extend(copy.deepcopy(current_listres))
                # print "      residues_to_remove after",residues_to_remove
            if i == len(
                    residues) - 2 and min_size > 1:  # If we reach this point, then the last residue is not continuos so it is single
                residues_to_remove.append(id2)
            else:
                current_listres = []
                current_listres.append(id2)
                index = index + 1
                dictio_chainid[id2] = list_id[index]
    # Remove the residues and write the pdb
    for model in list(structure):
        for chain in list(model):
            for residue in list(chain):
                id_res = residue.id
                if id_res in residues_to_remove:
                    chain.detach_child(id_res)
    io = PDBIO()
    io.set_structure(structure)
    io.save(pdb_file[:-4] + '_trimmed.pdb', write_end=False)

def write_info_frag_from_dictio_frag(dictio_fragments,clust_fold,ent_present):
    file_fragments = open(clust_fold + "info_frag", 'w')
    if ent_present:
        file_fragments.write( '%-40s %-10s %-10s %-10s %-10s %-10s %-10s %-10s\n' % ('Name','LLG','Z-score','Rotcluster','InitCC','Efom','PseudoCC','wMPE'))
        for key in dictio_fragments.keys():
            file_fragments.write( '%-40s %-10s %-10s %-10s %-10s %-10s %-10s %-10s\n' % (os.path.basename(key),
                                                                                       dictio_fragments[key]['llg'],
                                                                                       dictio_fragments[key]['zscore'],
                                                                                       dictio_fragments[key]['rot_cluster'],
                                                                                       dictio_fragments[key]['initcc'],
                                                                                       dictio_fragments[key]['efom'],
                                                                                       dictio_fragments[key]['pseudocc'],
                                                                                       dictio_fragments[key]['list_MPE'][2]))
    else:
        file_fragments.write( '%-40s %-10s %-10s %-10s %-10s %-10s %-10s \n' % ('Name','LLG','Z-score','Rotcluster','InitCC','Efom','PseudoCC'))
        for key in dictio_fragments.keys():
            file_fragments.write( '%-40s %-10s %-10s %-10s %-10s %-10s %-10s \n' % (os.path.basename(key),
                                                                                       dictio_fragments[key]['llg'],
                                                                                       dictio_fragments[key]['zscore'],
                                                                                       dictio_fragments[key]['rot_cluster'],
                                                                                       dictio_fragments[key]['initcc'],
                                                                                       dictio_fragments[key]['efom'],
                                                                                       dictio_fragments[key]['pseudocc']))
    file_fragments.close()

def write_sum_file_from_dictio_result(path_sum,dictio_result):
    fileforclu = open(path_sum, 'w')
    fileforclu.write(
        '%-40s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s\n' % (
        'Name', 'wMPD_first', 'wMPD_last', 'diff_wMPD', 'mapcc_first',
        'mapcc_last', 'shift_first_x', 'shift_first_y', 'shift_first_z', 'shift_last_x', 'shift_last_y',
        'shift_last_z'))
    for phaseset in dictio_result.keys():
        name = os.path.basename(phaseset)
        wmpe_first = round(dictio_result[phaseset]['wMPE_first'], 2)
        wmpe_last = round(dictio_result[phaseset]['wMPE_last'], 2)
        diffwmpe = -1
        if dictio_result[phaseset]['mapcc_first'] != None:
            mapcc_first = round(dictio_result[phaseset]['mapcc_first'], 2)
        else:
            mapcc_first = -1
        if dictio_result[phaseset]['mapcc_last'] != None:
            mapcc_last = round(dictio_result[phaseset]['mapcc_last'], 2)
        else:
            mapcc_last = -1
        shift_first = dictio_result[phaseset]['shift_first']
        shift_last = dictio_result[phaseset]['shift_last']
        fileforclu.write(
            '%-40s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s\n' % (name, wmpe_first, wmpe_last,
                                                                                           diffwmpe, mapcc_first,
                                                                                           mapcc_last,
                                                                                           shift_first[0],
                                                                                           shift_first[1],
                                                                                           shift_first[2],
                                                                                           shift_last[0],
                                                                                           shift_last[1],
                                                                                           shift_last[2]))
    del (fileforclu)


if __name__ == "__main__":  # A set of tests to check everything works as expected

    print "Run to check syntax errors"

    # Test new function
    # name_job=sys.argv[1]
    # print get_topexp_from_html_output(name_job,os.getcwd())
