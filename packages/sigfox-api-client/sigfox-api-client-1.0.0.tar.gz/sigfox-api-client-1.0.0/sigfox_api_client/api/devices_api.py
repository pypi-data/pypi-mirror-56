# coding: utf-8

"""
    Sigfox API

     # API overview Sigfox API is used to integrate with the Sigfox platform.  The API uses the HTTP protocol, following the REST principles (POST, GET, DELETE, PUT requests). The API endpoints accept and return data in the JSON format, with the corresponding \"application/json\" content type header.  The Sigfox API access differs for every API User based on their profile. If you already have a Sigfox account, you can retrieve the API Documentation customized for your API User directly in json or yaml format. The “how to” procedure is detailed in the [API Documentation](https://support.sigfox.com/docs/api-documentation) article.  The PUT request is the only request used to edit an existing entity. You don't need to specify each value. If a property is not present in the request, it won't be processed and updated. To remove an optional property, it must be filled in the request with the explicit value NULL. If a property has no value, it won't appear in the result of a GET request.  # Authentication and security Sigfox API is only accessible using HTTPS, and all API endpoints require authentication credentials (API user login and password). An API User is associated to a group with given profiles. You can view and manage your API User in the [Sigfox Portal](https://backend.sigfox.com/auth/login).  If you need an API User, follow the [API credential creation](https://support.sigfox.com/docs/api-credential-creation) procedure.  Your API User must remain private. Should the API credentials be compromised, new ones can be generated at any moment, invalidating the previous ones. CORS and JSONP are intentionally unsupported. CORS and JSONP JavaScript techniques tends to expose your credentials to your users. If you really need to call Sigfox API from JavaScript in the browser, you must set a reverse proxy on your website. Be careful not to use proxy for all requests to Sigfox OSS but to only select the relevant ones.  <!-- ReDoc-Inject: <security-definitions> -->  # Usage limits All Sigfox API endpoints are using the same underlying technology that powers the core Sigfox Platform. For Cloud efficiency and security reasons, Sigfox is moving a step forward on API rate limiting, by setting upper bounds for some API endpoints. Please note that a new HTTP response will be returned in case of rate exceeded : “HTTP 429: too many requests”.  For more information check [API Rate limiting](https://support.sigfox.com/docs/api-rate-limiting) policy. Sigfox reserves the right to modify these limits without notice.  # Versioning  Sigfox API supports versioning of its endpoints through a version suffix in the endpoint URL. This suffix has the following format: \"vX\", where X is the version number. For example: v2/device.  All requests must include the version suffix in the endpoint URL.  Any new backwards-incompatible change will be released in a new version.   Read the [API versioning management](https://storage.sbg1.cloud.ovh.net/v1/AUTH_669d7dfced0b44518cb186841d7cbd75/prod_docs/55746591-API_Versioning_management.pdf) to learn more about it.  # Paging  Some API requests will return a list of data. If the list is longer than the set limit, the items will be retrieved via multiple requests. The paging section in the response will specify a URL for the next request.  Keep in mind rate limiting policy to manage your requests.  You can use the limit parameter to limit the number of items to be returned, between 1 and 100 (default). The offset parameter is used to specify a number of items to skip.  # Errors  Sigfox API uses conventional HTTP response codes to indicate the success or failure of an API request.  Codes in the 2xx range indicate success.  Codes in the 4xx range indicate an error that failed given the information provided (e.g. a required parameter missing, a resource was not found, etc.). Often the response will also include a message explaining the error.  Codes in the 5xx range indicate an error with servers.   For more information please refer to the [Response code article](https://support.sigfox.com/docs/api-response-code-references).   # noqa: E501

    OpenAPI spec version: 2.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from sigfox_api_client.api_client import ApiClient


class DevicesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_bulk_device(self, body, **kwargs):  # noqa: E501
        """Create multiple devices  # noqa: E501

        Create multiple new devices with asynchronous job   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bulk_device(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AsynchronousDeviceCreationJob body: The devices to create (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_bulk_device_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_bulk_device_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_bulk_device_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create multiple devices  # noqa: E501

        Create multiple new devices with asynchronous job   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_bulk_device_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AsynchronousDeviceCreationJob body: The devices to create (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bulk_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_bulk_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_device(self, body, **kwargs):  # noqa: E501
        """Create a device  # noqa: E501

        Create a new device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_device(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceCreationJob body: The device to create (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_device_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_device_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_device_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a device  # noqa: E501

        Create a new device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_device_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceCreationJob body: The device to create (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_device(self, id, **kwargs):  # noqa: E501
        """Delete a device  # noqa: E501

        Delete a given device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_device_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_device_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_device_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a device  # noqa: E501

        Delete a given device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_device_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def device_bulk_edit_async(self, body, **kwargs):  # noqa: E501
        """Update multiple devices  # noqa: E501

        Update or edit multiple devices with asynchronous job.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_bulk_edit_async(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AsynchronousDeviceEditionJob body: The devices to edit (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.device_bulk_edit_async_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.device_bulk_edit_async_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def device_bulk_edit_async_with_http_info(self, body, **kwargs):  # noqa: E501
        """Update multiple devices  # noqa: E501

        Update or edit multiple devices with asynchronous job.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_bulk_edit_async_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AsynchronousDeviceEditionJob body: The devices to edit (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_bulk_edit_async" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `device_bulk_edit_async`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/bulk', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def device_bulk_transfer(self, body, **kwargs):  # noqa: E501
        """Transfer multiple devices to another device type  # noqa: E501

        Transfer multiple devices to another device type with asynchronous job   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_bulk_transfer(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AsynchronousDeviceTransferJob body: The devices to move (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.device_bulk_transfer_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.device_bulk_transfer_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def device_bulk_transfer_with_http_info(self, body, **kwargs):  # noqa: E501
        """Transfer multiple devices to another device type  # noqa: E501

        Transfer multiple devices to another device type with asynchronous job   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_bulk_transfer_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AsynchronousDeviceTransferJob body: The devices to move (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_bulk_transfer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `device_bulk_transfer`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/bulk/transfer', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def device_bulk_unsubscribe(self, body, **kwargs):  # noqa: E501
        """Unsubscribe multiple devices  # noqa: E501

        Unsubscribe multiple devices with asynchronous job.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_bulk_unsubscribe(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BulkUnsubscribe body: array of device's identifier (hexadecimal format) with unsubscribtion time (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.device_bulk_unsubscribe_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.device_bulk_unsubscribe_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def device_bulk_unsubscribe_with_http_info(self, body, **kwargs):  # noqa: E501
        """Unsubscribe multiple devices  # noqa: E501

        Unsubscribe multiple devices with asynchronous job.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_bulk_unsubscribe_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BulkUnsubscribe body: array of device's identifier (hexadecimal format) with unsubscribtion time (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_bulk_unsubscribe" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `device_bulk_unsubscribe`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/bulk/unsubscribe', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def device_seq_number_disengage(self, id, **kwargs):  # noqa: E501
        """Disengage sequence number check for the next message  # noqa: E501

        Disable sequence number check for the next message.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_seq_number_disengage(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.device_seq_number_disengage_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.device_seq_number_disengage_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def device_seq_number_disengage_with_http_info(self, id, **kwargs):  # noqa: E501
        """Disengage sequence number check for the next message  # noqa: E501

        Disable sequence number check for the next message.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_seq_number_disengage_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_seq_number_disengage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `device_seq_number_disengage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/{id}/disengage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_bulk_replace(self, **kwargs):  # noqa: E501
        """Replace multiple devices  # noqa: E501

        Replace multiple devices (moving tokens from one device to another) with synchronous job   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_bulk_replace(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AsynchronousDeviceReplacementJob body: Pairs of source and target devices
        :return: ReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_bulk_replace_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.devices_bulk_replace_with_http_info(**kwargs)  # noqa: E501
            return data

    def devices_bulk_replace_with_http_info(self, **kwargs):  # noqa: E501
        """Replace multiple devices  # noqa: E501

        Replace multiple devices (moving tokens from one device to another) with synchronous job   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_bulk_replace_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AsynchronousDeviceReplacementJob body: Pairs of source and target devices
        :return: ReplaceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_bulk_replace" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/bulk/replace', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReplaceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_bulk_restart(self, body, **kwargs):  # noqa: E501
        """Restart multiple devices  # noqa: E501

        Restart multiple devices with asynchronous job.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_bulk_restart(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceActionJob body: list of device's identifier (hexadecimal format) (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_bulk_restart_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_bulk_restart_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def devices_bulk_restart_with_http_info(self, body, **kwargs):  # noqa: E501
        """Restart multiple devices  # noqa: E501

        Restart multiple devices with asynchronous job.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_bulk_restart_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceActionJob body: list of device's identifier (hexadecimal format) (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_bulk_restart" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `devices_bulk_restart`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/bulk/restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_bulk_resume(self, body, **kwargs):  # noqa: E501
        """Resume multiple devices  # noqa: E501

        Resume multiple devices with asynchronous job.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_bulk_resume(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceActionJob body: list of device's identifier (hexadecimal format) (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_bulk_resume_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_bulk_resume_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def devices_bulk_resume_with_http_info(self, body, **kwargs):  # noqa: E501
        """Resume multiple devices  # noqa: E501

        Resume multiple devices with asynchronous job.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_bulk_resume_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceActionJob body: list of device's identifier (hexadecimal format) (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_bulk_resume" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `devices_bulk_resume`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/bulk/resume', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_bulk_suspend(self, body, **kwargs):  # noqa: E501
        """Suspend multiple devices  # noqa: E501

        Suspend multiple devices with asynchronous job   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_bulk_suspend(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceActionJob body: list of device's identifier (hexadecimal format) (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_bulk_suspend_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_bulk_suspend_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def devices_bulk_suspend_with_http_info(self, body, **kwargs):  # noqa: E501
        """Suspend multiple devices  # noqa: E501

        Suspend multiple devices with asynchronous job   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_bulk_suspend_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceActionJob body: list of device's identifier (hexadecimal format) (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_bulk_suspend" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `devices_bulk_suspend`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/bulk/suspend', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_id_consumption_year_get(self, id, year, **kwargs):  # noqa: E501
        """Retrieve a device's consumption for a year  # noqa: E501

        Retrieve a device's consumption for a given year.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_id_consumption_year_get(id, year, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param int year: The year of consumption (required)
        :return: DeviceConsumption
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_id_consumption_year_get_with_http_info(id, year, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_id_consumption_year_get_with_http_info(id, year, **kwargs)  # noqa: E501
            return data

    def devices_id_consumption_year_get_with_http_info(self, id, year, **kwargs):  # noqa: E501
        """Retrieve a device's consumption for a year  # noqa: E501

        Retrieve a device's consumption for a given year.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_id_consumption_year_get_with_http_info(id, year, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param int year: The year of consumption (required)
        :return: DeviceConsumption
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'year']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_id_consumption_year_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `devices_id_consumption_year_get`")  # noqa: E501
        # verify the required parameter 'year' is set
        if ('year' not in params or
                params['year'] is None):
            raise ValueError("Missing the required parameter `year` when calling `devices_id_consumption_year_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'year' in params:
            path_params['year'] = params['year']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/{id}/consumption/{year}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceConsumption',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_id_consumption_year_month_get(self, id, year, month, **kwargs):  # noqa: E501
        """Get a Device's consumption for a given month  # noqa: E501

        Retrieve a device's consumption for a given month during a given year.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_id_consumption_year_month_get(id, year, month, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param int year: The year of consumption (required)
        :param int month: The month of consumption (required)
        :return: DeviceConsumption
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_id_consumption_year_month_get_with_http_info(id, year, month, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_id_consumption_year_month_get_with_http_info(id, year, month, **kwargs)  # noqa: E501
            return data

    def devices_id_consumption_year_month_get_with_http_info(self, id, year, month, **kwargs):  # noqa: E501
        """Get a Device's consumption for a given month  # noqa: E501

        Retrieve a device's consumption for a given month during a given year.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_id_consumption_year_month_get_with_http_info(id, year, month, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param int year: The year of consumption (required)
        :param int month: The month of consumption (required)
        :return: DeviceConsumption
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'year', 'month']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_id_consumption_year_month_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `devices_id_consumption_year_month_get`")  # noqa: E501
        # verify the required parameter 'year' is set
        if ('year' not in params or
                params['year'] is None):
            raise ValueError("Missing the required parameter `year` when calling `devices_id_consumption_year_month_get`")  # noqa: E501
        # verify the required parameter 'month' is set
        if ('month' not in params or
                params['month'] is None):
            raise ValueError("Missing the required parameter `month` when calling `devices_id_consumption_year_month_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'year' in params:
            path_params['year'] = params['year']  # noqa: E501
        if 'month' in params:
            path_params['month'] = params['month']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/{id}/consumption/{year}/{month}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceConsumption',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_id_messages_metric_get(self, id, **kwargs):  # noqa: E501
        """Retreive the number of messages  # noqa: E501

        Return the number of messages for a given device, for the last day, last week and last month.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_id_messages_metric_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_id_messages_metric_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_id_messages_metric_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def devices_id_messages_metric_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retreive the number of messages  # noqa: E501

        Return the number of messages for a given device, for the last day, last week and last month.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_id_messages_metric_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_id_messages_metric_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `devices_id_messages_metric_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/{id}/messages/metric', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bulk_job_for_device(self, job_id, **kwargs):  # noqa: E501
        """Retrieve the status of a job  # noqa: E501

        Retrieve the status of an asynchronous job for devices.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bulk_job_for_device(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_id: The job identidier (hexademical format) (required)
        :return: RegistrationJobStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bulk_job_for_device_with_http_info(job_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bulk_job_for_device_with_http_info(job_id, **kwargs)  # noqa: E501
            return data

    def get_bulk_job_for_device_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Retrieve the status of a job  # noqa: E501

        Retrieve the status of an asynchronous job for devices.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bulk_job_for_device_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_id: The job identidier (hexademical format) (required)
        :return: RegistrationJobStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['job_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bulk_job_for_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'job_id' is set
        if ('job_id' not in params or
                params['job_id'] is None):
            raise ValueError("Missing the required parameter `job_id` when calling `get_bulk_job_for_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in params:
            path_params['jobId'] = params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/bulk/{jobId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RegistrationJobStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bulk_restart_job(self, job_id, **kwargs):  # noqa: E501
        """Retrieve the async job status for a restart action.  # noqa: E501

        Retrieve the async job status for a restart devices action.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bulk_restart_job(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_id: The job identidier (hexademical format) (required)
        :return: ActionJob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bulk_restart_job_with_http_info(job_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bulk_restart_job_with_http_info(job_id, **kwargs)  # noqa: E501
            return data

    def get_bulk_restart_job_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Retrieve the async job status for a restart action.  # noqa: E501

        Retrieve the async job status for a restart devices action.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bulk_restart_job_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_id: The job identidier (hexademical format) (required)
        :return: ActionJob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['job_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bulk_restart_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'job_id' is set
        if ('job_id' not in params or
                params['job_id'] is None):
            raise ValueError("Missing the required parameter `job_id` when calling `get_bulk_restart_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in params:
            path_params['jobId'] = params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/bulk/restart/{jobId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActionJob',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bulk_resume_job(self, job_id, **kwargs):  # noqa: E501
        """Retrieve the status of a resume job  # noqa: E501

        Retrieve the async job status for a resume devices action.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bulk_resume_job(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_id: The job identidier (hexademical format) (required)
        :return: ActionJob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bulk_resume_job_with_http_info(job_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bulk_resume_job_with_http_info(job_id, **kwargs)  # noqa: E501
            return data

    def get_bulk_resume_job_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Retrieve the status of a resume job  # noqa: E501

        Retrieve the async job status for a resume devices action.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bulk_resume_job_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_id: The job identidier (hexademical format) (required)
        :return: ActionJob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['job_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bulk_resume_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'job_id' is set
        if ('job_id' not in params or
                params['job_id'] is None):
            raise ValueError("Missing the required parameter `job_id` when calling `get_bulk_resume_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in params:
            path_params['jobId'] = params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/bulk/resume/{jobId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActionJob',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bulk_suspend_job(self, job_id, **kwargs):  # noqa: E501
        """Retrieve the status of a suspend job  # noqa: E501

        Retrieve the async job status for a suspend devices action.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bulk_suspend_job(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_id: The job identidier (hexademical format) (required)
        :return: ActionJob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bulk_suspend_job_with_http_info(job_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bulk_suspend_job_with_http_info(job_id, **kwargs)  # noqa: E501
            return data

    def get_bulk_suspend_job_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Retrieve the status of a suspend job  # noqa: E501

        Retrieve the async job status for a suspend devices action.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bulk_suspend_job_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_id: The job identidier (hexademical format) (required)
        :return: ActionJob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['job_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bulk_suspend_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'job_id' is set
        if ('job_id' not in params or
                params['job_id'] is None):
            raise ValueError("Missing the required parameter `job_id` when calling `get_bulk_suspend_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in params:
            path_params['jobId'] = params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/bulk/suspend/{jobId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActionJob',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_callback_messages_error_list_for_device(self, id, **kwargs):  # noqa: E501
        """Retrieve a list of undelivered callbacks  # noqa: E501

        Retrieve a list of undelivered callbacks and errors for a given device, in reverse chronological order (most recent message first).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_callback_messages_error_list_for_device(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param int since: Starting timestamp (in milliseconds since the Unix Epoch)
        :param int before: Ending timestamp (in milliseconds since the Unix Epoch)
        :param int limit: The maximum number of items to return
        :param int offset: The number of items to skip
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_callback_messages_error_list_for_device_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_callback_messages_error_list_for_device_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_callback_messages_error_list_for_device_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retrieve a list of undelivered callbacks  # noqa: E501

        Retrieve a list of undelivered callbacks and errors for a given device, in reverse chronological order (most recent message first).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_callback_messages_error_list_for_device_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param int since: Starting timestamp (in milliseconds since the Unix Epoch)
        :param int before: Ending timestamp (in milliseconds since the Unix Epoch)
        :param int limit: The maximum number of items to return
        :param int offset: The number of items to skip
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'since', 'before', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_callback_messages_error_list_for_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_callback_messages_error_list_for_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'before' in params:
            query_params.append(('before', params['before']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/{id}/callbacks-not-delivered', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device(self, id, **kwargs):  # noqa: E501
        """Retrieve information about a device  # noqa: E501

        Retrieve information about a given device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param str fields: Defines the other available fields to be returned in the response. 
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_device_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retrieve information about a device  # noqa: E501

        Retrieve information about a given device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param str fields: Defines the other available fields to be returned in the response. 
        :return: Device
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Device',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_locations_list(self, id, **kwargs):  # noqa: E501
        """Retrieve the locations of a device  # noqa: E501

        Retrieve a list of location data of a device according to request filters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_locations_list(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param bool oob: if true, the method return also the location from out of band Messages
        :param int since: Starting timestamp (in milliseconds since the Unix Epoch)
        :param int before: Ending timestamp (in milliseconds since the Unix Epoch)
        :param int limit: The maximum number of items to return
        :param int offset: The number of items to skip
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_locations_list_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_locations_list_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_device_locations_list_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retrieve the locations of a device  # noqa: E501

        Retrieve a list of location data of a device according to request filters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_locations_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param bool oob: if true, the method return also the location from out of band Messages
        :param int since: Starting timestamp (in milliseconds since the Unix Epoch)
        :param int before: Ending timestamp (in milliseconds since the Unix Epoch)
        :param int limit: The maximum number of items to return
        :param int offset: The number of items to skip
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'oob', 'since', 'before', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_locations_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_locations_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'oob' in params:
            query_params.append(('oob', params['oob']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'before' in params:
            query_params.append(('before', params['before']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/{id}/locations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_messages_list_for_device(self, id, **kwargs):  # noqa: E501
        """Retrieve a list of messages  # noqa: E501

        Retrieve a list of messages for a given device according to request filters, with a 3-day history.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_messages_list_for_device(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param str fields: Defines the other available fields to be returned in the response. 
        :param int since: Starting timestamp (in milliseconds since the Unix Epoch)
        :param int before: Ending timestamp (in milliseconds since the Unix Epoch)
        :param int limit: The maximum number of items to return
        :param int offset: The number of items to skip
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_messages_list_for_device_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_messages_list_for_device_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_device_messages_list_for_device_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retrieve a list of messages  # noqa: E501

        Retrieve a list of messages for a given device according to request filters, with a 3-day history.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_messages_list_for_device_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param str fields: Defines the other available fields to be returned in the response. 
        :param int since: Starting timestamp (in milliseconds since the Unix Epoch)
        :param int before: Ending timestamp (in milliseconds since the Unix Epoch)
        :param int limit: The maximum number of items to return
        :param int offset: The number of items to skip
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'since', 'before', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_messages_list_for_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_messages_list_for_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'before' in params:
            query_params.append(('before', params['before']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/{id}/messages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_unsubscribe_job(self, job_id, **kwargs):  # noqa: E501
        """Retrieve the async job status for an unsubscribe action.  # noqa: E501

        Retrieve the async job status for an unsubscribe devices action.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_unsubscribe_job(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_id: The job identidier (hexademical format) (required)
        :return: ActionJob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_unsubscribe_job_with_http_info(job_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_unsubscribe_job_with_http_info(job_id, **kwargs)  # noqa: E501
            return data

    def get_device_unsubscribe_job_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Retrieve the async job status for an unsubscribe action.  # noqa: E501

        Retrieve the async job status for an unsubscribe devices action.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_unsubscribe_job_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_id: The job identidier (hexademical format) (required)
        :return: ActionJob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['job_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_unsubscribe_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'job_id' is set
        if ('job_id' not in params or
                params['job_id'] is None):
            raise ValueError("Missing the required parameter `job_id` when calling `get_device_unsubscribe_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in params:
            path_params['jobId'] = params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/bulk/unsubscribe/{jobId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActionJob',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_modem_certificate_info(self, id, **kwargs):  # noqa: E501
        """Retrieve the modem certificate associated with a device  # noqa: E501

        Retrieve the modem certificate associated with a device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_modem_certificate_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param str fields: Defines the other available fields to be returned in the response. 
        :return: ModemCertificate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_modem_certificate_info_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_modem_certificate_info_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_modem_certificate_info_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retrieve the modem certificate associated with a device  # noqa: E501

        Retrieve the modem certificate associated with a device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_modem_certificate_info_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param str fields: Defines the other available fields to be returned in the response. 
        :return: ModemCertificate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_modem_certificate_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_modem_certificate_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/{id}/certificate/modem', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModemCertificate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_certificate_info(self, id, **kwargs):  # noqa: E501
        """Retrieve the product certificate associated with a device  # noqa: E501

        Retrieve the product certificate associated with a device already registered.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_certificate_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param str fields: Defines the other available fields to be returned in the response. 
        :return: ProductCertificate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_product_certificate_info_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_product_certificate_info_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_product_certificate_info_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retrieve the product certificate associated with a device  # noqa: E501

        Retrieve the product certificate associated with a device already registered.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_certificate_info_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param str fields: Defines the other available fields to be returned in the response. 
        :return: ProductCertificate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_certificate_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_product_certificate_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/{id}/certificate/product', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProductCertificate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_certificate_info_with_pac(self, id, pac, **kwargs):  # noqa: E501
        """Retrieve the product certificate associated with a device ID and PAC  # noqa: E501

        Retrieve the product certificate associated with a given device ID and PAC, when the device has not already been created on the portal, only in CRA   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_certificate_info_with_pac(id, pac, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param str pac: The device's PAC (hexadecimal format) (required)
        :return: ProductCertificateWithPacResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_product_certificate_info_with_pac_with_http_info(id, pac, **kwargs)  # noqa: E501
        else:
            (data) = self.get_product_certificate_info_with_pac_with_http_info(id, pac, **kwargs)  # noqa: E501
            return data

    def get_product_certificate_info_with_pac_with_http_info(self, id, pac, **kwargs):  # noqa: E501
        """Retrieve the product certificate associated with a device ID and PAC  # noqa: E501

        Retrieve the product certificate associated with a given device ID and PAC, when the device has not already been created on the portal, only in CRA   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_certificate_info_with_pac_with_http_info(id, pac, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device identifier (hexadecimal format) (required)
        :param str pac: The device's PAC (hexadecimal format) (required)
        :return: ProductCertificateWithPacResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'pac']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_certificate_info_with_pac" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_product_certificate_info_with_pac`")  # noqa: E501
        # verify the required parameter 'pac' is set
        if ('pac' not in params or
                params['pac'] is None):
            raise ValueError("Missing the required parameter `pac` when calling `get_product_certificate_info_with_pac`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'pac' in params:
            query_params.append(('pac', params['pac']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/{id}/product-certificate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProductCertificateWithPacResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_devices(self, **kwargs):  # noqa: E501
        """Retrieve a list of devices  # noqa: E501

        Retrieve a list of devices according to visibility permissions and request filters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_devices(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The device's identifier (hexadecimal format)
        :param list[str] group_ids: Returns all devices under the given groups (included sub-groups if the parameter deep is equals to true)
        :param bool deep: if true, we search by groups and subgroups through the parameter 'groupIds'
        :param str device_type_id: Returns all devices of the given device type
        :param str operator_id: Returns all devices under the given operator
        :param str sort: The field on which the list will be sorted. (field to sort ascending or -field to sort descending)
        :param str min_id: The minimal id of the filtered range, only availble when sort parameter is set to \"id\" or \"-id\"
        :param str max_id: The maximal id of the filtered range, only availble when sort parameter is set to \"id\" or \"-id\"
        :param str fields: Defines the other available fields to be returned in the response. 
        :param int limit: The maximum number of items to return
        :param int offset: The number of items to skip
        :param str page_id: Token representing the page to retrieve
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_devices_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_devices_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_devices_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a list of devices  # noqa: E501

        Retrieve a list of devices according to visibility permissions and request filters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_devices_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The device's identifier (hexadecimal format)
        :param list[str] group_ids: Returns all devices under the given groups (included sub-groups if the parameter deep is equals to true)
        :param bool deep: if true, we search by groups and subgroups through the parameter 'groupIds'
        :param str device_type_id: Returns all devices of the given device type
        :param str operator_id: Returns all devices under the given operator
        :param str sort: The field on which the list will be sorted. (field to sort ascending or -field to sort descending)
        :param str min_id: The minimal id of the filtered range, only availble when sort parameter is set to \"id\" or \"-id\"
        :param str max_id: The maximal id of the filtered range, only availble when sort parameter is set to \"id\" or \"-id\"
        :param str fields: Defines the other available fields to be returned in the response. 
        :param int limit: The maximum number of items to return
        :param int offset: The number of items to skip
        :param str page_id: Token representing the page to retrieve
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'group_ids', 'deep', 'device_type_id', 'operator_id', 'sort', 'min_id', 'max_id', 'fields', 'limit', 'offset', 'page_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_devices" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'group_ids' in params:
            query_params.append(('groupIds', params['group_ids']))  # noqa: E501
            collection_formats['groupIds'] = 'csv'  # noqa: E501
        if 'deep' in params:
            query_params.append(('deep', params['deep']))  # noqa: E501
        if 'device_type_id' in params:
            query_params.append(('deviceTypeId', params['device_type_id']))  # noqa: E501
        if 'operator_id' in params:
            query_params.append(('operatorId', params['operator_id']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'min_id' in params:
            query_params.append(('minId', params['min_id']))  # noqa: E501
        if 'max_id' in params:
            query_params.append(('maxId', params['max_id']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'page_id' in params:
            query_params.append(('pageId', params['page_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unsubscribe(self, body, id, **kwargs):  # noqa: E501
        """Unsubscribe a device  # noqa: E501

        Set an unsubscription date for the device's token.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unsubscribe(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TokenUnsubscribe body: the unsubscription time (in milliseconds since the Unix Epoch) (required)
        :param str id: The Device identifier (hexadecimal format) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unsubscribe_with_http_info(body, id, **kwargs)  # noqa: E501
        else:
            (data) = self.unsubscribe_with_http_info(body, id, **kwargs)  # noqa: E501
            return data

    def unsubscribe_with_http_info(self, body, id, **kwargs):  # noqa: E501
        """Unsubscribe a device  # noqa: E501

        Set an unsubscription date for the device's token.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unsubscribe_with_http_info(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TokenUnsubscribe body: the unsubscription time (in milliseconds since the Unix Epoch) (required)
        :param str id: The Device identifier (hexadecimal format) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unsubscribe" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `unsubscribe`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `unsubscribe`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/{id}/unsubscribe', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device(self, body, id, **kwargs):  # noqa: E501
        """Update a device  # noqa: E501

        Update a given device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceUpdateJob body: The device to update (required)
        :param str id: The Device identifier (hexadecimal format) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_with_http_info(body, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_with_http_info(body, id, **kwargs)  # noqa: E501
            return data

    def update_device_with_http_info(self, body, id, **kwargs):  # noqa: E501
        """Update a device  # noqa: E501

        Update a given device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_with_http_info(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceUpdateJob body: The device to update (required)
        :param str id: The Device identifier (hexadecimal format) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
