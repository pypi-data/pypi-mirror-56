# coding: utf-8

"""
    Sigfox API

     # API overview Sigfox API is used to integrate with the Sigfox platform.  The API uses the HTTP protocol, following the REST principles (POST, GET, DELETE, PUT requests). The API endpoints accept and return data in the JSON format, with the corresponding \"application/json\" content type header.  The Sigfox API access differs for every API User based on their profile. If you already have a Sigfox account, you can retrieve the API Documentation customized for your API User directly in json or yaml format. The “how to” procedure is detailed in the [API Documentation](https://support.sigfox.com/docs/api-documentation) article.  The PUT request is the only request used to edit an existing entity. You don't need to specify each value. If a property is not present in the request, it won't be processed and updated. To remove an optional property, it must be filled in the request with the explicit value NULL. If a property has no value, it won't appear in the result of a GET request.  # Authentication and security Sigfox API is only accessible using HTTPS, and all API endpoints require authentication credentials (API user login and password). An API User is associated to a group with given profiles. You can view and manage your API User in the [Sigfox Portal](https://backend.sigfox.com/auth/login).  If you need an API User, follow the [API credential creation](https://support.sigfox.com/docs/api-credential-creation) procedure.  Your API User must remain private. Should the API credentials be compromised, new ones can be generated at any moment, invalidating the previous ones. CORS and JSONP are intentionally unsupported. CORS and JSONP JavaScript techniques tends to expose your credentials to your users. If you really need to call Sigfox API from JavaScript in the browser, you must set a reverse proxy on your website. Be careful not to use proxy for all requests to Sigfox OSS but to only select the relevant ones.  <!-- ReDoc-Inject: <security-definitions> -->  # Usage limits All Sigfox API endpoints are using the same underlying technology that powers the core Sigfox Platform. For Cloud efficiency and security reasons, Sigfox is moving a step forward on API rate limiting, by setting upper bounds for some API endpoints. Please note that a new HTTP response will be returned in case of rate exceeded : “HTTP 429: too many requests”.  For more information check [API Rate limiting](https://support.sigfox.com/docs/api-rate-limiting) policy. Sigfox reserves the right to modify these limits without notice.  # Versioning  Sigfox API supports versioning of its endpoints through a version suffix in the endpoint URL. This suffix has the following format: \"vX\", where X is the version number. For example: v2/device.  All requests must include the version suffix in the endpoint URL.  Any new backwards-incompatible change will be released in a new version.   Read the [API versioning management](https://storage.sbg1.cloud.ovh.net/v1/AUTH_669d7dfced0b44518cb186841d7cbd75/prod_docs/55746591-API_Versioning_management.pdf) to learn more about it.  # Paging  Some API requests will return a list of data. If the list is longer than the set limit, the items will be retrieved via multiple requests. The paging section in the response will specify a URL for the next request.  Keep in mind rate limiting policy to manage your requests.  You can use the limit parameter to limit the number of items to be returned, between 1 and 100 (default). The offset parameter is used to specify a number of items to skip.  # Errors  Sigfox API uses conventional HTTP response codes to indicate the success or failure of an API request.  Codes in the 2xx range indicate success.  Codes in the 4xx range indicate an error that failed given the information provided (e.g. a required parameter missing, a resource was not found, etc.). Often the response will also include a message explaining the error.  Codes in the 5xx range indicate an error with servers.   For more information please refer to the [Response code article](https://support.sigfox.com/docs/api-response-code-references).   # noqa: E501

    OpenAPI spec version: 2.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from sigfox_api_client.api_client import ApiClient


class DeviceTypesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_callback(self, body, id, **kwargs):  # noqa: E501
        """Create a callback  # noqa: E501

        Create a new callback for a given device type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_callback(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateCallback body: (required)
        :param str id: The Device Type identifier from which callbacks will be retrieve (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_callback_with_http_info(body, id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_callback_with_http_info(body, id, **kwargs)  # noqa: E501
            return data

    def create_callback_with_http_info(self, body, id, **kwargs):  # noqa: E501
        """Create a callback  # noqa: E501

        Create a new callback for a given device type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_callback_with_http_info(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateCallback body: (required)
        :param str id: The Device Type identifier from which callbacks will be retrieve (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_callback" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_callback`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_callback`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/{id}/callbacks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_device_type(self, body, **kwargs):  # noqa: E501
        """Create a device type  # noqa: E501

        Create a new device type   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_device_type(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceTypeCreate body: The device type to create (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_device_type_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_device_type_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_device_type_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a device type  # noqa: E501

        Create a new device type   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_device_type_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceTypeCreate body: The device type to create (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_device_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_device_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_callback(self, id, callback_id, **kwargs):  # noqa: E501
        """Delete a callback  # noqa: E501

        Delete a callback for a given device type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_callback(id, callback_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier from which callbacks will be retrieve (required)
        :param str callback_id: The Callback identifier (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_callback_with_http_info(id, callback_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_callback_with_http_info(id, callback_id, **kwargs)  # noqa: E501
            return data

    def delete_callback_with_http_info(self, id, callback_id, **kwargs):  # noqa: E501
        """Delete a callback  # noqa: E501

        Delete a callback for a given device type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_callback_with_http_info(id, callback_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier from which callbacks will be retrieve (required)
        :param str callback_id: The Callback identifier (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'callback_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_callback" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_callback`")  # noqa: E501
        # verify the required parameter 'callback_id' is set
        if ('callback_id' not in params or
                params['callback_id'] is None):
            raise ValueError("Missing the required parameter `callback_id` when calling `delete_callback`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'callback_id' in params:
            path_params['callbackId'] = params['callback_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/{id}/callbacks/{callbackId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def device_type_bulk_restart(self, id, **kwargs):  # noqa: E501
        """Restart the devices of a device type  # noqa: E501

        Restart the devices of a device type with a asynchronous job.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_type_bulk_restart(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.device_type_bulk_restart_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.device_type_bulk_restart_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def device_type_bulk_restart_with_http_info(self, id, **kwargs):  # noqa: E501
        """Restart the devices of a device type  # noqa: E501

        Restart the devices of a device type with a asynchronous job.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_type_bulk_restart_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_type_bulk_restart" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `device_type_bulk_restart`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/{id}/bulk/restart', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def device_types_delete(self, id, **kwargs):  # noqa: E501
        """Delete a device type  # noqa: E501

        Delete a given device type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_types_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier (hexademical format) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.device_types_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.device_types_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def device_types_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a device type  # noqa: E501

        Delete a given device type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_types_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier (hexademical format) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_types_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `device_types_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def device_types_seq_number_disengage(self, id, **kwargs):  # noqa: E501
        """Disengage sequence number check for the next message  # noqa: E501

        Disable the sequence number check for the next message of each device of a device type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_types_seq_number_disengage(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.device_types_seq_number_disengage_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.device_types_seq_number_disengage_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def device_types_seq_number_disengage_with_http_info(self, id, **kwargs):  # noqa: E501
        """Disengage sequence number check for the next message  # noqa: E501

        Disable the sequence number check for the next message of each device of a device type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.device_types_seq_number_disengage_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method device_types_seq_number_disengage" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `device_types_seq_number_disengage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/{id}/disengage', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_callback(self, id, callback_id, enabled, **kwargs):  # noqa: E501
        """Enable or disable a callback  # noqa: E501

        Enable or disable a callback for a given device type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_callback(id, callback_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier from which callbacks will be retrieve (required)
        :param str callback_id: The Callback identifier (required)
        :param bool enabled: True to enable the callback, false to disable it (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_callback_with_http_info(id, callback_id, enabled, **kwargs)  # noqa: E501
        else:
            (data) = self.enable_callback_with_http_info(id, callback_id, enabled, **kwargs)  # noqa: E501
            return data

    def enable_callback_with_http_info(self, id, callback_id, enabled, **kwargs):  # noqa: E501
        """Enable or disable a callback  # noqa: E501

        Enable or disable a callback for a given device type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_callback_with_http_info(id, callback_id, enabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier from which callbacks will be retrieve (required)
        :param str callback_id: The Callback identifier (required)
        :param bool enabled: True to enable the callback, false to disable it (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'callback_id', 'enabled']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_callback" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `enable_callback`")  # noqa: E501
        # verify the required parameter 'callback_id' is set
        if ('callback_id' not in params or
                params['callback_id'] is None):
            raise ValueError("Missing the required parameter `callback_id` when calling `enable_callback`")  # noqa: E501
        # verify the required parameter 'enabled' is set
        if ('enabled' not in params or
                params['enabled'] is None):
            raise ValueError("Missing the required parameter `enabled` when calling `enable_callback`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'callback_id' in params:
            path_params['callbackId'] = params['callback_id']  # noqa: E501

        query_params = []
        if 'enabled' in params:
            query_params.append(('enabled', params['enabled']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/{id}/callbacks/{callbackId}/enable', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def enable_downlink_callback(self, id, callback_id, **kwargs):  # noqa: E501
        """Selects a downlink callback  # noqa: E501

        Selects a downlink callback for a device type. The callback will be selected as the downlink one, the one that was previously selected will no longer be used for downlink.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_downlink_callback(id, callback_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier from which callbacks will be retrieve (required)
        :param str callback_id: The Callback identifier (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.enable_downlink_callback_with_http_info(id, callback_id, **kwargs)  # noqa: E501
        else:
            (data) = self.enable_downlink_callback_with_http_info(id, callback_id, **kwargs)  # noqa: E501
            return data

    def enable_downlink_callback_with_http_info(self, id, callback_id, **kwargs):  # noqa: E501
        """Selects a downlink callback  # noqa: E501

        Selects a downlink callback for a device type. The callback will be selected as the downlink one, the one that was previously selected will no longer be used for downlink.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.enable_downlink_callback_with_http_info(id, callback_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier from which callbacks will be retrieve (required)
        :param str callback_id: The Callback identifier (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'callback_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method enable_downlink_callback" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `enable_downlink_callback`")  # noqa: E501
        # verify the required parameter 'callback_id' is set
        if ('callback_id' not in params or
                params['callback_id'] is None):
            raise ValueError("Missing the required parameter `callback_id` when calling `enable_downlink_callback`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'callback_id' in params:
            path_params['callbackId'] = params['callback_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/{id}/callbacks/{callbackId}/downlink', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_callback_messages_error_list_for_device_type(self, id, **kwargs):  # noqa: E501
        """Retrieve a list of callback errors  # noqa: E501

        Retrieve a list of undelivered callback messages for a given device types.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_callback_messages_error_list_for_device_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier (required)
        :param int since: Starting timestamp (in milliseconds since Unix Epoch).
        :param int before: Ending timestamp (in milliseconds since Unix Epoch).
        :param int limit: Defines the maximum number of items to return
        :param int offset: Defines the number of items to skip
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_callback_messages_error_list_for_device_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_callback_messages_error_list_for_device_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_callback_messages_error_list_for_device_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retrieve a list of callback errors  # noqa: E501

        Retrieve a list of undelivered callback messages for a given device types.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_callback_messages_error_list_for_device_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier (required)
        :param int since: Starting timestamp (in milliseconds since Unix Epoch).
        :param int before: Ending timestamp (in milliseconds since Unix Epoch).
        :param int limit: Defines the maximum number of items to return
        :param int offset: Defines the number of items to skip
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'since', 'before', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_callback_messages_error_list_for_device_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_callback_messages_error_list_for_device_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'before' in params:
            query_params.append(('before', params['before']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/{id}/callbacks-not-delivered', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_messages_list_for_device_type(self, id, **kwargs):  # noqa: E501
        """Retrieve a list of messages  # noqa: E501

        Retrieve a list of messages for a given device types with a 3-day history.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_messages_list_for_device_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier (required)
        :param str fields: Defines the other available API user's fields to be returned in the response. 
        :param int since: Starting timestamp (in milliseconds since Unix Epoch).
        :param int before: Ending timestamp (in milliseconds since Unix Epoch).
        :param int limit: Defines the maximum number of items to return
        :param int offset: Defines the number of items to skip
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_messages_list_for_device_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_messages_list_for_device_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_device_messages_list_for_device_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retrieve a list of messages  # noqa: E501

        Retrieve a list of messages for a given device types with a 3-day history.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_messages_list_for_device_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier (required)
        :param str fields: Defines the other available API user's fields to be returned in the response. 
        :param int since: Starting timestamp (in milliseconds since Unix Epoch).
        :param int before: Ending timestamp (in milliseconds since Unix Epoch).
        :param int limit: Defines the maximum number of items to return
        :param int offset: Defines the number of items to skip
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields', 'since', 'before', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_messages_list_for_device_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_messages_list_for_device_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'since' in params:
            query_params.append(('since', params['since']))  # noqa: E501
        if 'before' in params:
            query_params.append(('before', params['before']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/{id}/messages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_type(self, id, **kwargs):  # noqa: E501
        """Retrieve information about a device type  # noqa: E501

        Retrieve information about a device type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier (hexademical format) (required)
        :param str fields: Defines the other available API user's fields to be returned in the response. 
        :return: DeviceType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_device_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retrieve information about a device type  # noqa: E501

        Retrieve information about a device type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier (hexademical format) (required)
        :param str fields: Defines the other available API user's fields to be returned in the response. 
        :return: DeviceType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_device_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_device_type_bulk_restart_job(self, job_id, **kwargs):  # noqa: E501
        """Retrieve the device type async job status for restart action  # noqa: E501

        Retrieve the async job status of a device type's asynchronous job for a restart devices action.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_type_bulk_restart_job(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_id: The job's identidier (hexademical format) (required)
        :return: ActionJob
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_device_type_bulk_restart_job_with_http_info(job_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_device_type_bulk_restart_job_with_http_info(job_id, **kwargs)  # noqa: E501
            return data

    def get_device_type_bulk_restart_job_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Retrieve the device type async job status for restart action  # noqa: E501

        Retrieve the async job status of a device type's asynchronous job for a restart devices action.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_device_type_bulk_restart_job_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str job_id: The job's identidier (hexademical format) (required)
        :return: ActionJob
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['job_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device_type_bulk_restart_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'job_id' is set
        if ('job_id' not in params or
                params['job_id'] is None):
            raise ValueError("Missing the required parameter `job_id` when calling `get_device_type_bulk_restart_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in params:
            path_params['jobId'] = params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/bulk/restart/{jobId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActionJob',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_callbacks(self, id, **kwargs):  # noqa: E501
        """Retrieve a list of callbacks  # noqa: E501

        Retrieve a list of callbacks for a given device type according to visibility permissions and request filters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_callbacks(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier from which callbacks will be retrieve (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_callbacks_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_callbacks_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def list_callbacks_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retrieve a list of callbacks  # noqa: E501

        Retrieve a list of callbacks for a given device type according to visibility permissions and request filters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_callbacks_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The Device Type identifier from which callbacks will be retrieve (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_callbacks" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `list_callbacks`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/{id}/callbacks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_device_types(self, **kwargs):  # noqa: E501
        """Retrieve a list of device types  # noqa: E501

        Retrieve a list of device types according to visibility permissions and request filters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_device_types(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Search returns all Device Type names containing the value. Example: ?name=sig 
        :param list[str] group_ids: Search for device types which are attached to a Group. Example: ?groupIds=57309674171c857460043087,57309674171c857460043088 
        :param bool deep: If a group identifier is specified, also includes its subgroups.
        :param str contract_id: Searches for device types which are attached to the given contract.
        :param int payload_type: Searches device types by payload type   - 2 -> Regular (raw payload)   - 3 -> Custom grammar   - 4 -> Geolocation   - 5 -> Display in ASCII   - 6 -> Radio planning frame   - 9 -> Sensitv2 
        :param str sort: The field on which the list will be sorted. (field to sort ascending or -field to sort descending).
        :param str fields: Defines the other available API user's fields to be returned in the response. 
        :param int limit: Defines the maximum number of items to return
        :param int offset: Defines the number of items to skip
        :param str page_id: Token representing the page to retrieve
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_device_types_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_device_types_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_device_types_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve a list of device types  # noqa: E501

        Retrieve a list of device types according to visibility permissions and request filters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_device_types_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Search returns all Device Type names containing the value. Example: ?name=sig 
        :param list[str] group_ids: Search for device types which are attached to a Group. Example: ?groupIds=57309674171c857460043087,57309674171c857460043088 
        :param bool deep: If a group identifier is specified, also includes its subgroups.
        :param str contract_id: Searches for device types which are attached to the given contract.
        :param int payload_type: Searches device types by payload type   - 2 -> Regular (raw payload)   - 3 -> Custom grammar   - 4 -> Geolocation   - 5 -> Display in ASCII   - 6 -> Radio planning frame   - 9 -> Sensitv2 
        :param str sort: The field on which the list will be sorted. (field to sort ascending or -field to sort descending).
        :param str fields: Defines the other available API user's fields to be returned in the response. 
        :param int limit: Defines the maximum number of items to return
        :param int offset: Defines the number of items to skip
        :param str page_id: Token representing the page to retrieve
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'group_ids', 'deep', 'contract_id', 'payload_type', 'sort', 'fields', 'limit', 'offset', 'page_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_device_types" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'group_ids' in params:
            query_params.append(('groupIds', params['group_ids']))  # noqa: E501
            collection_formats['groupIds'] = 'csv'  # noqa: E501
        if 'deep' in params:
            query_params.append(('deep', params['deep']))  # noqa: E501
        if 'contract_id' in params:
            query_params.append(('contractId', params['contract_id']))  # noqa: E501
        if 'payload_type' in params:
            query_params.append(('payloadType', params['payload_type']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'page_id' in params:
            query_params.append(('pageId', params['page_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_callback(self, body, id, callback_id, **kwargs):  # noqa: E501
        """Update a callback  # noqa: E501

        Update a callback for a given device type   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_callback(body, id, callback_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateCallback body: The callback to update (required)
        :param str id: The Device Type identifier from which callbacks will be retrieve (required)
        :param str callback_id: The Callback identifier (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_callback_with_http_info(body, id, callback_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_callback_with_http_info(body, id, callback_id, **kwargs)  # noqa: E501
            return data

    def update_callback_with_http_info(self, body, id, callback_id, **kwargs):  # noqa: E501
        """Update a callback  # noqa: E501

        Update a callback for a given device type   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_callback_with_http_info(body, id, callback_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateCallback body: The callback to update (required)
        :param str id: The Device Type identifier from which callbacks will be retrieve (required)
        :param str callback_id: The Callback identifier (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id', 'callback_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_callback" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_callback`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_callback`")  # noqa: E501
        # verify the required parameter 'callback_id' is set
        if ('callback_id' not in params or
                params['callback_id'] is None):
            raise ValueError("Missing the required parameter `callback_id` when calling `update_callback`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'callback_id' in params:
            path_params['callbackId'] = params['callback_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/{id}/callbacks/{callbackId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_device_type(self, body, id, **kwargs):  # noqa: E501
        """Update a device type  # noqa: E501

        Update a given device type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_type(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceTypeUpdate body: The device type to update (required)
        :param str id: The Device Type identifier (hexademical format) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_device_type_with_http_info(body, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_device_type_with_http_info(body, id, **kwargs)  # noqa: E501
            return data

    def update_device_type_with_http_info(self, body, id, **kwargs):  # noqa: E501
        """Update a device type  # noqa: E501

        Update a given device type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_device_type_with_http_info(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceTypeUpdate body: The device type to update (required)
        :param str id: The Device Type identifier (hexademical format) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_device_type`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_device_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/device-types/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
