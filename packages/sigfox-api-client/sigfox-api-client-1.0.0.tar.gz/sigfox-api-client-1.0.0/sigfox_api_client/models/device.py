# coding: utf-8

"""
    Sigfox API

     # API overview Sigfox API is used to integrate with the Sigfox platform.  The API uses the HTTP protocol, following the REST principles (POST, GET, DELETE, PUT requests). The API endpoints accept and return data in the JSON format, with the corresponding \"application/json\" content type header.  The Sigfox API access differs for every API User based on their profile. If you already have a Sigfox account, you can retrieve the API Documentation customized for your API User directly in json or yaml format. The “how to” procedure is detailed in the [API Documentation](https://support.sigfox.com/docs/api-documentation) article.  The PUT request is the only request used to edit an existing entity. You don't need to specify each value. If a property is not present in the request, it won't be processed and updated. To remove an optional property, it must be filled in the request with the explicit value NULL. If a property has no value, it won't appear in the result of a GET request.  # Authentication and security Sigfox API is only accessible using HTTPS, and all API endpoints require authentication credentials (API user login and password). An API User is associated to a group with given profiles. You can view and manage your API User in the [Sigfox Portal](https://backend.sigfox.com/auth/login).  If you need an API User, follow the [API credential creation](https://support.sigfox.com/docs/api-credential-creation) procedure.  Your API User must remain private. Should the API credentials be compromised, new ones can be generated at any moment, invalidating the previous ones. CORS and JSONP are intentionally unsupported. CORS and JSONP JavaScript techniques tends to expose your credentials to your users. If you really need to call Sigfox API from JavaScript in the browser, you must set a reverse proxy on your website. Be careful not to use proxy for all requests to Sigfox OSS but to only select the relevant ones.  <!-- ReDoc-Inject: <security-definitions> -->  # Usage limits All Sigfox API endpoints are using the same underlying technology that powers the core Sigfox Platform. For Cloud efficiency and security reasons, Sigfox is moving a step forward on API rate limiting, by setting upper bounds for some API endpoints. Please note that a new HTTP response will be returned in case of rate exceeded : “HTTP 429: too many requests”.  For more information check [API Rate limiting](https://support.sigfox.com/docs/api-rate-limiting) policy. Sigfox reserves the right to modify these limits without notice.  # Versioning  Sigfox API supports versioning of its endpoints through a version suffix in the endpoint URL. This suffix has the following format: \"vX\", where X is the version number. For example: v2/device.  All requests must include the version suffix in the endpoint URL.  Any new backwards-incompatible change will be released in a new version.   Read the [API versioning management](https://storage.sbg1.cloud.ovh.net/v1/AUTH_669d7dfced0b44518cb186841d7cbd75/prod_docs/55746591-API_Versioning_management.pdf) to learn more about it.  # Paging  Some API requests will return a list of data. If the list is longer than the set limit, the items will be retrieved via multiple requests. The paging section in the response will specify a URL for the next request.  Keep in mind rate limiting policy to manage your requests.  You can use the limit parameter to limit the number of items to be returned, between 1 and 100 (default). The offset parameter is used to specify a number of items to skip.  # Errors  Sigfox API uses conventional HTTP response codes to indicate the success or failure of an API request.  Codes in the 2xx range indicate success.  Codes in the 4xx range indicate an error that failed given the information provided (e.g. a required parameter missing, a resource was not found, etc.). Often the response will also include a message explaining the error.  Codes in the 5xx range indicate an error with servers.   For more information please refer to the [Response code article](https://support.sigfox.com/docs/api-response-code-references).   # noqa: E501

    OpenAPI spec version: 2.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six
from sigfox_api_client.models.common_device import CommonDevice


class Device(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'device_type': 'MinDeviceType',
        'contract': 'MinContractInfo',
        'group': 'MinGroup',
        'modem_certificate': 'Certificate',
        'prototype': 'bool',
        'product_certificate': 'Certificate',
        'location': 'Location',
        'last_computed_location': 'ComputedLocation',
        'pac': 'str',
        'sequence_number': 'int',
        'trash_sequence_number': 'int',
        'last_com': 'int',
        'lqi': 'int',
        'activation_time': 'int',
        'creation_time': 'int',
        'state': 'int',
        'com_state': 'int',
        'token': 'Token',
        'unsubscription_time': 'int',
        'created_by': 'str',
        'last_edition_time': 'int',
        'last_edited_by': 'str',
        'automatic_renewal': 'bool',
        'automatic_renewal_status': 'int',
        'activable': 'bool'
    }
    if hasattr(CommonDevice, "swagger_types"):
        swagger_types.update(CommonDevice.swagger_types)

    attribute_map = {
        'device_type': 'deviceType',
        'contract': 'contract',
        'group': 'group',
        'modem_certificate': 'modemCertificate',
        'prototype': 'prototype',
        'product_certificate': 'productCertificate',
        'location': 'location',
        'last_computed_location': 'lastComputedLocation',
        'pac': 'pac',
        'sequence_number': 'sequenceNumber',
        'trash_sequence_number': 'trashSequenceNumber',
        'last_com': 'lastCom',
        'lqi': 'lqi',
        'activation_time': 'activationTime',
        'creation_time': 'creationTime',
        'state': 'state',
        'com_state': 'comState',
        'token': 'token',
        'unsubscription_time': 'unsubscriptionTime',
        'created_by': 'createdBy',
        'last_edition_time': 'lastEditionTime',
        'last_edited_by': 'lastEditedBy',
        'automatic_renewal': 'automaticRenewal',
        'automatic_renewal_status': 'automaticRenewalStatus',
        'activable': 'activable'
    }
    if hasattr(CommonDevice, "attribute_map"):
        attribute_map.update(CommonDevice.attribute_map)

    def __init__(self, device_type=None, contract=None, group=None, modem_certificate=None, prototype=None, product_certificate=None, location=None, last_computed_location=None, pac=None, sequence_number=None, trash_sequence_number=None, last_com=None, lqi=None, activation_time=None, creation_time=None, state=None, com_state=None, token=None, unsubscription_time=None, created_by=None, last_edition_time=None, last_edited_by=None, automatic_renewal=None, automatic_renewal_status=None, activable=None, *args, **kwargs):  # noqa: E501
        """Device - a model defined in Swagger"""  # noqa: E501
        self._device_type = None
        self._contract = None
        self._group = None
        self._modem_certificate = None
        self._prototype = None
        self._product_certificate = None
        self._location = None
        self._last_computed_location = None
        self._pac = None
        self._sequence_number = None
        self._trash_sequence_number = None
        self._last_com = None
        self._lqi = None
        self._activation_time = None
        self._creation_time = None
        self._state = None
        self._com_state = None
        self._token = None
        self._unsubscription_time = None
        self._created_by = None
        self._last_edition_time = None
        self._last_edited_by = None
        self._automatic_renewal = None
        self._automatic_renewal_status = None
        self._activable = None
        self.discriminator = None
        if device_type is not None:
            self.device_type = device_type
        if contract is not None:
            self.contract = contract
        if group is not None:
            self.group = group
        if modem_certificate is not None:
            self.modem_certificate = modem_certificate
        if prototype is not None:
            self.prototype = prototype
        if product_certificate is not None:
            self.product_certificate = product_certificate
        if location is not None:
            self.location = location
        if last_computed_location is not None:
            self.last_computed_location = last_computed_location
        self.pac = pac
        if sequence_number is not None:
            self.sequence_number = sequence_number
        if trash_sequence_number is not None:
            self.trash_sequence_number = trash_sequence_number
        if last_com is not None:
            self.last_com = last_com
        if lqi is not None:
            self.lqi = lqi
        if activation_time is not None:
            self.activation_time = activation_time
        self.creation_time = creation_time
        self.state = state
        self.com_state = com_state
        if token is not None:
            self.token = token
        if unsubscription_time is not None:
            self.unsubscription_time = unsubscription_time
        if created_by is not None:
            self.created_by = created_by
        if last_edition_time is not None:
            self.last_edition_time = last_edition_time
        if last_edited_by is not None:
            self.last_edited_by = last_edited_by
        self.automatic_renewal = automatic_renewal
        if automatic_renewal_status is not None:
            self.automatic_renewal_status = automatic_renewal_status
        if activable is not None:
            self.activable = activable
        CommonDevice.__init__(self, *args, **kwargs)

    @property
    def device_type(self):
        """Gets the device_type of this Device.  # noqa: E501


        :return: The device_type of this Device.  # noqa: E501
        :rtype: MinDeviceType
        """
        return self._device_type

    @device_type.setter
    def device_type(self, device_type):
        """Sets the device_type of this Device.


        :param device_type: The device_type of this Device.  # noqa: E501
        :type: MinDeviceType
        """

        self._device_type = device_type

    @property
    def contract(self):
        """Gets the contract of this Device.  # noqa: E501


        :return: The contract of this Device.  # noqa: E501
        :rtype: MinContractInfo
        """
        return self._contract

    @contract.setter
    def contract(self, contract):
        """Sets the contract of this Device.


        :param contract: The contract of this Device.  # noqa: E501
        :type: MinContractInfo
        """

        self._contract = contract

    @property
    def group(self):
        """Gets the group of this Device.  # noqa: E501


        :return: The group of this Device.  # noqa: E501
        :rtype: MinGroup
        """
        return self._group

    @group.setter
    def group(self, group):
        """Sets the group of this Device.


        :param group: The group of this Device.  # noqa: E501
        :type: MinGroup
        """

        self._group = group

    @property
    def modem_certificate(self):
        """Gets the modem_certificate of this Device.  # noqa: E501


        :return: The modem_certificate of this Device.  # noqa: E501
        :rtype: Certificate
        """
        return self._modem_certificate

    @modem_certificate.setter
    def modem_certificate(self, modem_certificate):
        """Sets the modem_certificate of this Device.


        :param modem_certificate: The modem_certificate of this Device.  # noqa: E501
        :type: Certificate
        """

        self._modem_certificate = modem_certificate

    @property
    def prototype(self):
        """Gets the prototype of this Device.  # noqa: E501

        The device is a prototype  # noqa: E501

        :return: The prototype of this Device.  # noqa: E501
        :rtype: bool
        """
        return self._prototype

    @prototype.setter
    def prototype(self, prototype):
        """Sets the prototype of this Device.

        The device is a prototype  # noqa: E501

        :param prototype: The prototype of this Device.  # noqa: E501
        :type: bool
        """

        self._prototype = prototype

    @property
    def product_certificate(self):
        """Gets the product_certificate of this Device.  # noqa: E501


        :return: The product_certificate of this Device.  # noqa: E501
        :rtype: Certificate
        """
        return self._product_certificate

    @product_certificate.setter
    def product_certificate(self, product_certificate):
        """Sets the product_certificate of this Device.


        :param product_certificate: The product_certificate of this Device.  # noqa: E501
        :type: Certificate
        """

        self._product_certificate = product_certificate

    @property
    def location(self):
        """Gets the location of this Device.  # noqa: E501


        :return: The location of this Device.  # noqa: E501
        :rtype: Location
        """
        return self._location

    @location.setter
    def location(self, location):
        """Sets the location of this Device.


        :param location: The location of this Device.  # noqa: E501
        :type: Location
        """

        self._location = location

    @property
    def last_computed_location(self):
        """Gets the last_computed_location of this Device.  # noqa: E501


        :return: The last_computed_location of this Device.  # noqa: E501
        :rtype: ComputedLocation
        """
        return self._last_computed_location

    @last_computed_location.setter
    def last_computed_location(self, last_computed_location):
        """Sets the last_computed_location of this Device.


        :param last_computed_location: The last_computed_location of this Device.  # noqa: E501
        :type: ComputedLocation
        """

        self._last_computed_location = last_computed_location

    @property
    def pac(self):
        """Gets the pac of this Device.  # noqa: E501

        The device's PAC (Porting Access Code)  # noqa: E501

        :return: The pac of this Device.  # noqa: E501
        :rtype: str
        """
        return self._pac

    @pac.setter
    def pac(self, pac):
        """Sets the pac of this Device.

        The device's PAC (Porting Access Code)  # noqa: E501

        :param pac: The pac of this Device.  # noqa: E501
        :type: str
        """
        if pac is None:
            raise ValueError("Invalid value for `pac`, must not be `None`")  # noqa: E501

        self._pac = pac

    @property
    def sequence_number(self):
        """Gets the sequence_number of this Device.  # noqa: E501

        The last device's sequence number. Absent if the device has never communicated or if the SIGFOX message protocol is V0   # noqa: E501

        :return: The sequence_number of this Device.  # noqa: E501
        :rtype: int
        """
        return self._sequence_number

    @sequence_number.setter
    def sequence_number(self, sequence_number):
        """Sets the sequence_number of this Device.

        The last device's sequence number. Absent if the device has never communicated or if the SIGFOX message protocol is V0   # noqa: E501

        :param sequence_number: The sequence_number of this Device.  # noqa: E501
        :type: int
        """

        self._sequence_number = sequence_number

    @property
    def trash_sequence_number(self):
        """Gets the trash_sequence_number of this Device.  # noqa: E501

        The last trashed device's sequence number. Absent if there is no message trashed or if the SIGFOX message protocol is V0   # noqa: E501

        :return: The trash_sequence_number of this Device.  # noqa: E501
        :rtype: int
        """
        return self._trash_sequence_number

    @trash_sequence_number.setter
    def trash_sequence_number(self, trash_sequence_number):
        """Sets the trash_sequence_number of this Device.

        The last trashed device's sequence number. Absent if there is no message trashed or if the SIGFOX message protocol is V0   # noqa: E501

        :param trash_sequence_number: The trash_sequence_number of this Device.  # noqa: E501
        :type: int
        """

        self._trash_sequence_number = trash_sequence_number

    @property
    def last_com(self):
        """Gets the last_com of this Device.  # noqa: E501

        The last time (in milliseconds since the Unix Epoch) the device has communicated  # noqa: E501

        :return: The last_com of this Device.  # noqa: E501
        :rtype: int
        """
        return self._last_com

    @last_com.setter
    def last_com(self, last_com):
        """Sets the last_com of this Device.

        The last time (in milliseconds since the Unix Epoch) the device has communicated  # noqa: E501

        :param last_com: The last_com of this Device.  # noqa: E501
        :type: int
        """

        self._last_com = last_com

    @property
    def lqi(self):
        """Gets the lqi of this Device.  # noqa: E501

        Link Quality Indicator 0 -> LIMIT 1 -> AVERAGE 2 -> GOOD 3 -> EXCELLENT 4 -> NA   # noqa: E501

        :return: The lqi of this Device.  # noqa: E501
        :rtype: int
        """
        return self._lqi

    @lqi.setter
    def lqi(self, lqi):
        """Sets the lqi of this Device.

        Link Quality Indicator 0 -> LIMIT 1 -> AVERAGE 2 -> GOOD 3 -> EXCELLENT 4 -> NA   # noqa: E501

        :param lqi: The lqi of this Device.  # noqa: E501
        :type: int
        """

        self._lqi = lqi

    @property
    def activation_time(self):
        """Gets the activation_time of this Device.  # noqa: E501

        The device's activation time (in milliseconds since the Unix Epoch)  # noqa: E501

        :return: The activation_time of this Device.  # noqa: E501
        :rtype: int
        """
        return self._activation_time

    @activation_time.setter
    def activation_time(self, activation_time):
        """Sets the activation_time of this Device.

        The device's activation time (in milliseconds since the Unix Epoch)  # noqa: E501

        :param activation_time: The activation_time of this Device.  # noqa: E501
        :type: int
        """

        self._activation_time = activation_time

    @property
    def creation_time(self):
        """Gets the creation_time of this Device.  # noqa: E501

        The device's provisionning time (in milliseconds since the Unix Epoch)  # noqa: E501

        :return: The creation_time of this Device.  # noqa: E501
        :rtype: int
        """
        return self._creation_time

    @creation_time.setter
    def creation_time(self, creation_time):
        """Sets the creation_time of this Device.

        The device's provisionning time (in milliseconds since the Unix Epoch)  # noqa: E501

        :param creation_time: The creation_time of this Device.  # noqa: E501
        :type: int
        """
        if creation_time is None:
            raise ValueError("Invalid value for `creation_time`, must not be `None`")  # noqa: E501

        self._creation_time = creation_time

    @property
    def state(self):
        """Gets the state of this Device.  # noqa: E501

        State of this device. 0 -> OK 1 -> DEAD 2 -> OFF_CONTRACT 3 -> DISABLED 4 -> WARN 5 -> DELETED 6 -> SUSPENDED 7 -> NOT_ACTIVABLE   # noqa: E501

        :return: The state of this Device.  # noqa: E501
        :rtype: int
        """
        return self._state

    @state.setter
    def state(self, state):
        """Sets the state of this Device.

        State of this device. 0 -> OK 1 -> DEAD 2 -> OFF_CONTRACT 3 -> DISABLED 4 -> WARN 5 -> DELETED 6 -> SUSPENDED 7 -> NOT_ACTIVABLE   # noqa: E501

        :param state: The state of this Device.  # noqa: E501
        :type: int
        """
        if state is None:
            raise ValueError("Invalid value for `state`, must not be `None`")  # noqa: E501

        self._state = state

    @property
    def com_state(self):
        """Gets the com_state of this Device.  # noqa: E501

        Communication state of this device. 0 -> NO 1 -> OK 2 -> WARN 3 -> KO 4 -> (na) 5 -> NOT_SEEN   # noqa: E501

        :return: The com_state of this Device.  # noqa: E501
        :rtype: int
        """
        return self._com_state

    @com_state.setter
    def com_state(self, com_state):
        """Sets the com_state of this Device.

        Communication state of this device. 0 -> NO 1 -> OK 2 -> WARN 3 -> KO 4 -> (na) 5 -> NOT_SEEN   # noqa: E501

        :param com_state: The com_state of this Device.  # noqa: E501
        :type: int
        """
        if com_state is None:
            raise ValueError("Invalid value for `com_state`, must not be `None`")  # noqa: E501

        self._com_state = com_state

    @property
    def token(self):
        """Gets the token of this Device.  # noqa: E501


        :return: The token of this Device.  # noqa: E501
        :rtype: Token
        """
        return self._token

    @token.setter
    def token(self, token):
        """Sets the token of this Device.


        :param token: The token of this Device.  # noqa: E501
        :type: Token
        """

        self._token = token

    @property
    def unsubscription_time(self):
        """Gets the unsubscription_time of this Device.  # noqa: E501

        The device's unsubscription time (in milliseconds since the Unix Epoch)  # noqa: E501

        :return: The unsubscription_time of this Device.  # noqa: E501
        :rtype: int
        """
        return self._unsubscription_time

    @unsubscription_time.setter
    def unsubscription_time(self, unsubscription_time):
        """Sets the unsubscription_time of this Device.

        The device's unsubscription time (in milliseconds since the Unix Epoch)  # noqa: E501

        :param unsubscription_time: The unsubscription_time of this Device.  # noqa: E501
        :type: int
        """

        self._unsubscription_time = unsubscription_time

    @property
    def created_by(self):
        """Gets the created_by of this Device.  # noqa: E501

        The id of device's creator user  # noqa: E501

        :return: The created_by of this Device.  # noqa: E501
        :rtype: str
        """
        return self._created_by

    @created_by.setter
    def created_by(self, created_by):
        """Sets the created_by of this Device.

        The id of device's creator user  # noqa: E501

        :param created_by: The created_by of this Device.  # noqa: E501
        :type: str
        """

        self._created_by = created_by

    @property
    def last_edition_time(self):
        """Gets the last_edition_time of this Device.  # noqa: E501

        Date of the last edition of this device (in milliseconds since the Unix Epoch)  # noqa: E501

        :return: The last_edition_time of this Device.  # noqa: E501
        :rtype: int
        """
        return self._last_edition_time

    @last_edition_time.setter
    def last_edition_time(self, last_edition_time):
        """Sets the last_edition_time of this Device.

        Date of the last edition of this device (in milliseconds since the Unix Epoch)  # noqa: E501

        :param last_edition_time: The last_edition_time of this Device.  # noqa: E501
        :type: int
        """

        self._last_edition_time = last_edition_time

    @property
    def last_edited_by(self):
        """Gets the last_edited_by of this Device.  # noqa: E501

        The id of device's last editor user  # noqa: E501

        :return: The last_edited_by of this Device.  # noqa: E501
        :rtype: str
        """
        return self._last_edited_by

    @last_edited_by.setter
    def last_edited_by(self, last_edited_by):
        """Sets the last_edited_by of this Device.

        The id of device's last editor user  # noqa: E501

        :param last_edited_by: The last_edited_by of this Device.  # noqa: E501
        :type: str
        """

        self._last_edited_by = last_edited_by

    @property
    def automatic_renewal(self):
        """Gets the automatic_renewal of this Device.  # noqa: E501

        Allow token renewal ?  # noqa: E501

        :return: The automatic_renewal of this Device.  # noqa: E501
        :rtype: bool
        """
        return self._automatic_renewal

    @automatic_renewal.setter
    def automatic_renewal(self, automatic_renewal):
        """Sets the automatic_renewal of this Device.

        Allow token renewal ?  # noqa: E501

        :param automatic_renewal: The automatic_renewal of this Device.  # noqa: E501
        :type: bool
        """
        if automatic_renewal is None:
            raise ValueError("Invalid value for `automatic_renewal`, must not be `None`")  # noqa: E501

        self._automatic_renewal = automatic_renewal

    @property
    def automatic_renewal_status(self):
        """Gets the automatic_renewal_status of this Device.  # noqa: E501

        Computed automatic renewal status. 0 -> ALLOWED 1 -> NOT_ALLOWED 2 -> RENEWED 3 -> ENDED   # noqa: E501

        :return: The automatic_renewal_status of this Device.  # noqa: E501
        :rtype: int
        """
        return self._automatic_renewal_status

    @automatic_renewal_status.setter
    def automatic_renewal_status(self, automatic_renewal_status):
        """Sets the automatic_renewal_status of this Device.

        Computed automatic renewal status. 0 -> ALLOWED 1 -> NOT_ALLOWED 2 -> RENEWED 3 -> ENDED   # noqa: E501

        :param automatic_renewal_status: The automatic_renewal_status of this Device.  # noqa: E501
        :type: int
        """

        self._automatic_renewal_status = automatic_renewal_status

    @property
    def activable(self):
        """Gets the activable of this Device.  # noqa: E501

        true if the device is activable and can take a token  # noqa: E501

        :return: The activable of this Device.  # noqa: E501
        :rtype: bool
        """
        return self._activable

    @activable.setter
    def activable(self, activable):
        """Sets the activable of this Device.

        true if the device is activable and can take a token  # noqa: E501

        :param activable: The activable of this Device.  # noqa: E501
        :type: bool
        """

        self._activable = activable

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Device, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Device):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
