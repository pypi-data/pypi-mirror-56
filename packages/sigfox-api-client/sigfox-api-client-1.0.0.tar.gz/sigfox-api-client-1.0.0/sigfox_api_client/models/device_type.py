# coding: utf-8

"""
    Sigfox API

     # API overview Sigfox API is used to integrate with the Sigfox platform.  The API uses the HTTP protocol, following the REST principles (POST, GET, DELETE, PUT requests). The API endpoints accept and return data in the JSON format, with the corresponding \"application/json\" content type header.  The Sigfox API access differs for every API User based on their profile. If you already have a Sigfox account, you can retrieve the API Documentation customized for your API User directly in json or yaml format. The “how to” procedure is detailed in the [API Documentation](https://support.sigfox.com/docs/api-documentation) article.  The PUT request is the only request used to edit an existing entity. You don't need to specify each value. If a property is not present in the request, it won't be processed and updated. To remove an optional property, it must be filled in the request with the explicit value NULL. If a property has no value, it won't appear in the result of a GET request.  # Authentication and security Sigfox API is only accessible using HTTPS, and all API endpoints require authentication credentials (API user login and password). An API User is associated to a group with given profiles. You can view and manage your API User in the [Sigfox Portal](https://backend.sigfox.com/auth/login).  If you need an API User, follow the [API credential creation](https://support.sigfox.com/docs/api-credential-creation) procedure.  Your API User must remain private. Should the API credentials be compromised, new ones can be generated at any moment, invalidating the previous ones. CORS and JSONP are intentionally unsupported. CORS and JSONP JavaScript techniques tends to expose your credentials to your users. If you really need to call Sigfox API from JavaScript in the browser, you must set a reverse proxy on your website. Be careful not to use proxy for all requests to Sigfox OSS but to only select the relevant ones.  <!-- ReDoc-Inject: <security-definitions> -->  # Usage limits All Sigfox API endpoints are using the same underlying technology that powers the core Sigfox Platform. For Cloud efficiency and security reasons, Sigfox is moving a step forward on API rate limiting, by setting upper bounds for some API endpoints. Please note that a new HTTP response will be returned in case of rate exceeded : “HTTP 429: too many requests”.  For more information check [API Rate limiting](https://support.sigfox.com/docs/api-rate-limiting) policy. Sigfox reserves the right to modify these limits without notice.  # Versioning  Sigfox API supports versioning of its endpoints through a version suffix in the endpoint URL. This suffix has the following format: \"vX\", where X is the version number. For example: v2/device.  All requests must include the version suffix in the endpoint URL.  Any new backwards-incompatible change will be released in a new version.   Read the [API versioning management](https://storage.sbg1.cloud.ovh.net/v1/AUTH_669d7dfced0b44518cb186841d7cbd75/prod_docs/55746591-API_Versioning_management.pdf) to learn more about it.  # Paging  Some API requests will return a list of data. If the list is longer than the set limit, the items will be retrieved via multiple requests. The paging section in the response will specify a URL for the next request.  Keep in mind rate limiting policy to manage your requests.  You can use the limit parameter to limit the number of items to be returned, between 1 and 100 (default). The offset parameter is used to specify a number of items to skip.  # Errors  Sigfox API uses conventional HTTP response codes to indicate the success or failure of an API request.  Codes in the 2xx range indicate success.  Codes in the 4xx range indicate an error that failed given the information provided (e.g. a required parameter missing, a resource was not found, etc.). Often the response will also include a message explaining the error.  Codes in the 5xx range indicate an error with servers.   For more information please refer to the [Response code article](https://support.sigfox.com/docs/api-response-code-references).   # noqa: E501

    OpenAPI spec version: 2.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six
from sigfox_api_client.models.base_device_type import BaseDeviceType


class DeviceType(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'id': 'str',
        'description': 'str',
        'downlink_mode': 'int',
        'downlink_data_string': 'str',
        'payload_type': 'int',
        'payload_config': 'str',
        'group': 'MinGroup',
        'contract': 'MinContractInfo',
        'contracts': 'list[MinContractInfo]',
        'detached_contracts': 'list[MinContractInfo]',
        'geoloc_payload_config': 'GeolocPayloadConfig',
        'creation_time': 'int',
        'created_by': 'str',
        'last_edition_time': 'int',
        'last_edited_by': 'str',
        'automatic_renewal': 'bool'
    }
    if hasattr(BaseDeviceType, "swagger_types"):
        swagger_types.update(BaseDeviceType.swagger_types)

    attribute_map = {
        'id': 'id',
        'description': 'description',
        'downlink_mode': 'downlinkMode',
        'downlink_data_string': 'downlinkDataString',
        'payload_type': 'payloadType',
        'payload_config': 'payloadConfig',
        'group': 'group',
        'contract': 'contract',
        'contracts': 'contracts',
        'detached_contracts': 'detachedContracts',
        'geoloc_payload_config': 'geolocPayloadConfig',
        'creation_time': 'creationTime',
        'created_by': 'createdBy',
        'last_edition_time': 'lastEditionTime',
        'last_edited_by': 'lastEditedBy',
        'automatic_renewal': 'automaticRenewal'
    }
    if hasattr(BaseDeviceType, "attribute_map"):
        attribute_map.update(BaseDeviceType.attribute_map)

    def __init__(self, id=None, description=None, downlink_mode=None, downlink_data_string=None, payload_type=None, payload_config=None, group=None, contract=None, contracts=None, detached_contracts=None, geoloc_payload_config=None, creation_time=None, created_by=None, last_edition_time=None, last_edited_by=None, automatic_renewal=None, *args, **kwargs):  # noqa: E501
        """DeviceType - a model defined in Swagger"""  # noqa: E501
        self._id = None
        self._description = None
        self._downlink_mode = None
        self._downlink_data_string = None
        self._payload_type = None
        self._payload_config = None
        self._group = None
        self._contract = None
        self._contracts = None
        self._detached_contracts = None
        self._geoloc_payload_config = None
        self._creation_time = None
        self._created_by = None
        self._last_edition_time = None
        self._last_edited_by = None
        self._automatic_renewal = None
        self.discriminator = None
        if id is not None:
            self.id = id
        if description is not None:
            self.description = description
        if downlink_mode is not None:
            self.downlink_mode = downlink_mode
        if downlink_data_string is not None:
            self.downlink_data_string = downlink_data_string
        if payload_type is not None:
            self.payload_type = payload_type
        if payload_config is not None:
            self.payload_config = payload_config
        if group is not None:
            self.group = group
        if contract is not None:
            self.contract = contract
        if contracts is not None:
            self.contracts = contracts
        if detached_contracts is not None:
            self.detached_contracts = detached_contracts
        if geoloc_payload_config is not None:
            self.geoloc_payload_config = geoloc_payload_config
        if creation_time is not None:
            self.creation_time = creation_time
        if created_by is not None:
            self.created_by = created_by
        if last_edition_time is not None:
            self.last_edition_time = last_edition_time
        if last_edited_by is not None:
            self.last_edited_by = last_edited_by
        if automatic_renewal is not None:
            self.automatic_renewal = automatic_renewal
        BaseDeviceType.__init__(self, *args, **kwargs)

    @property
    def id(self):
        """Gets the id of this DeviceType.  # noqa: E501

        The device type's identifier  # noqa: E501

        :return: The id of this DeviceType.  # noqa: E501
        :rtype: str
        """
        return self._id

    @id.setter
    def id(self, id):
        """Sets the id of this DeviceType.

        The device type's identifier  # noqa: E501

        :param id: The id of this DeviceType.  # noqa: E501
        :type: str
        """

        self._id = id

    @property
    def description(self):
        """Gets the description of this DeviceType.  # noqa: E501

        The device type's description  # noqa: E501

        :return: The description of this DeviceType.  # noqa: E501
        :rtype: str
        """
        return self._description

    @description.setter
    def description(self, description):
        """Sets the description of this DeviceType.

        The device type's description  # noqa: E501

        :param description: The description of this DeviceType.  # noqa: E501
        :type: str
        """

        self._description = description

    @property
    def downlink_mode(self):
        """Gets the downlink_mode of this DeviceType.  # noqa: E501

        The downlink mode to use for the devices of this device type. 0 -> DIRECT 1 -> CALLBACK 2 -> NONE 3 -> MANAGED   # noqa: E501

        :return: The downlink_mode of this DeviceType.  # noqa: E501
        :rtype: int
        """
        return self._downlink_mode

    @downlink_mode.setter
    def downlink_mode(self, downlink_mode):
        """Sets the downlink_mode of this DeviceType.

        The downlink mode to use for the devices of this device type. 0 -> DIRECT 1 -> CALLBACK 2 -> NONE 3 -> MANAGED   # noqa: E501

        :param downlink_mode: The downlink_mode of this DeviceType.  # noqa: E501
        :type: int
        """

        self._downlink_mode = downlink_mode

    @property
    def downlink_data_string(self):
        """Gets the downlink_data_string of this DeviceType.  # noqa: E501

        Downlink data to be sent to the devices of this device type if downlinkMode is equal to 0. It must be an 8 byte length message given in hexadecimal string format.   # noqa: E501

        :return: The downlink_data_string of this DeviceType.  # noqa: E501
        :rtype: str
        """
        return self._downlink_data_string

    @downlink_data_string.setter
    def downlink_data_string(self, downlink_data_string):
        """Sets the downlink_data_string of this DeviceType.

        Downlink data to be sent to the devices of this device type if downlinkMode is equal to 0. It must be an 8 byte length message given in hexadecimal string format.   # noqa: E501

        :param downlink_data_string: The downlink_data_string of this DeviceType.  # noqa: E501
        :type: str
        """

        self._downlink_data_string = downlink_data_string

    @property
    def payload_type(self):
        """Gets the payload_type of this DeviceType.  # noqa: E501

        The payload type 2 -> Regular (raw payload) 3 -> Custom grammar 4 -> Geolocation 5 -> Display in ASCII 6 -> Radio planning frame 9 -> Sensitv2   # noqa: E501

        :return: The payload_type of this DeviceType.  # noqa: E501
        :rtype: int
        """
        return self._payload_type

    @payload_type.setter
    def payload_type(self, payload_type):
        """Sets the payload_type of this DeviceType.

        The payload type 2 -> Regular (raw payload) 3 -> Custom grammar 4 -> Geolocation 5 -> Display in ASCII 6 -> Radio planning frame 9 -> Sensitv2   # noqa: E501

        :param payload_type: The payload_type of this DeviceType.  # noqa: E501
        :type: int
        """

        self._payload_type = payload_type

    @property
    def payload_config(self):
        """Gets the payload_config of this DeviceType.  # noqa: E501

        The payload configuration. Required if the payload type is Custom, else ignored.  # noqa: E501

        :return: The payload_config of this DeviceType.  # noqa: E501
        :rtype: str
        """
        return self._payload_config

    @payload_config.setter
    def payload_config(self, payload_config):
        """Sets the payload_config of this DeviceType.

        The payload configuration. Required if the payload type is Custom, else ignored.  # noqa: E501

        :param payload_config: The payload_config of this DeviceType.  # noqa: E501
        :type: str
        """

        self._payload_config = payload_config

    @property
    def group(self):
        """Gets the group of this DeviceType.  # noqa: E501


        :return: The group of this DeviceType.  # noqa: E501
        :rtype: MinGroup
        """
        return self._group

    @group.setter
    def group(self, group):
        """Sets the group of this DeviceType.


        :param group: The group of this DeviceType.  # noqa: E501
        :type: MinGroup
        """

        self._group = group

    @property
    def contract(self):
        """Gets the contract of this DeviceType.  # noqa: E501


        :return: The contract of this DeviceType.  # noqa: E501
        :rtype: MinContractInfo
        """
        return self._contract

    @contract.setter
    def contract(self, contract):
        """Sets the contract of this DeviceType.


        :param contract: The contract of this DeviceType.  # noqa: E501
        :type: MinContractInfo
        """

        self._contract = contract

    @property
    def contracts(self):
        """Gets the contracts of this DeviceType.  # noqa: E501

        The list of the contracts associated with the device type  # noqa: E501

        :return: The contracts of this DeviceType.  # noqa: E501
        :rtype: list[MinContractInfo]
        """
        return self._contracts

    @contracts.setter
    def contracts(self, contracts):
        """Sets the contracts of this DeviceType.

        The list of the contracts associated with the device type  # noqa: E501

        :param contracts: The contracts of this DeviceType.  # noqa: E501
        :type: list[MinContractInfo]
        """

        self._contracts = contracts

    @property
    def detached_contracts(self):
        """Gets the detached_contracts of this DeviceType.  # noqa: E501

        The list of the contracts that were associated with the device type at some point, but are not anymore.  # noqa: E501

        :return: The detached_contracts of this DeviceType.  # noqa: E501
        :rtype: list[MinContractInfo]
        """
        return self._detached_contracts

    @detached_contracts.setter
    def detached_contracts(self, detached_contracts):
        """Sets the detached_contracts of this DeviceType.

        The list of the contracts that were associated with the device type at some point, but are not anymore.  # noqa: E501

        :param detached_contracts: The detached_contracts of this DeviceType.  # noqa: E501
        :type: list[MinContractInfo]
        """

        self._detached_contracts = detached_contracts

    @property
    def geoloc_payload_config(self):
        """Gets the geoloc_payload_config of this DeviceType.  # noqa: E501


        :return: The geoloc_payload_config of this DeviceType.  # noqa: E501
        :rtype: GeolocPayloadConfig
        """
        return self._geoloc_payload_config

    @geoloc_payload_config.setter
    def geoloc_payload_config(self, geoloc_payload_config):
        """Sets the geoloc_payload_config of this DeviceType.


        :param geoloc_payload_config: The geoloc_payload_config of this DeviceType.  # noqa: E501
        :type: GeolocPayloadConfig
        """

        self._geoloc_payload_config = geoloc_payload_config

    @property
    def creation_time(self):
        """Gets the creation_time of this DeviceType.  # noqa: E501

        Date of the creation of this device type (in milliseconds)  # noqa: E501

        :return: The creation_time of this DeviceType.  # noqa: E501
        :rtype: int
        """
        return self._creation_time

    @creation_time.setter
    def creation_time(self, creation_time):
        """Sets the creation_time of this DeviceType.

        Date of the creation of this device type (in milliseconds)  # noqa: E501

        :param creation_time: The creation_time of this DeviceType.  # noqa: E501
        :type: int
        """

        self._creation_time = creation_time

    @property
    def created_by(self):
        """Gets the created_by of this DeviceType.  # noqa: E501

        Identifier of the user who created this device type  # noqa: E501

        :return: The created_by of this DeviceType.  # noqa: E501
        :rtype: str
        """
        return self._created_by

    @created_by.setter
    def created_by(self, created_by):
        """Sets the created_by of this DeviceType.

        Identifier of the user who created this device type  # noqa: E501

        :param created_by: The created_by of this DeviceType.  # noqa: E501
        :type: str
        """

        self._created_by = created_by

    @property
    def last_edition_time(self):
        """Gets the last_edition_time of this DeviceType.  # noqa: E501

        Date of the last edition of this device type (in milliseconds)  # noqa: E501

        :return: The last_edition_time of this DeviceType.  # noqa: E501
        :rtype: int
        """
        return self._last_edition_time

    @last_edition_time.setter
    def last_edition_time(self, last_edition_time):
        """Sets the last_edition_time of this DeviceType.

        Date of the last edition of this device type (in milliseconds)  # noqa: E501

        :param last_edition_time: The last_edition_time of this DeviceType.  # noqa: E501
        :type: int
        """

        self._last_edition_time = last_edition_time

    @property
    def last_edited_by(self):
        """Gets the last_edited_by of this DeviceType.  # noqa: E501

        Identifier of the user who last edited this device type  # noqa: E501

        :return: The last_edited_by of this DeviceType.  # noqa: E501
        :rtype: str
        """
        return self._last_edited_by

    @last_edited_by.setter
    def last_edited_by(self, last_edited_by):
        """Sets the last_edited_by of this DeviceType.

        Identifier of the user who last edited this device type  # noqa: E501

        :param last_edited_by: The last_edited_by of this DeviceType.  # noqa: E501
        :type: str
        """

        self._last_edited_by = last_edited_by

    @property
    def automatic_renewal(self):
        """Gets the automatic_renewal of this DeviceType.  # noqa: E501

        Allows the automatic renewal of devices attached to this device type  # noqa: E501

        :return: The automatic_renewal of this DeviceType.  # noqa: E501
        :rtype: bool
        """
        return self._automatic_renewal

    @automatic_renewal.setter
    def automatic_renewal(self, automatic_renewal):
        """Sets the automatic_renewal of this DeviceType.

        Allows the automatic renewal of devices attached to this device type  # noqa: E501

        :param automatic_renewal: The automatic_renewal of this DeviceType.  # noqa: E501
        :type: bool
        """

        self._automatic_renewal = automatic_renewal

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(DeviceType, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, DeviceType):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
