# coding: utf-8

"""
    Sigfox API

     # API overview Sigfox API is used to integrate with the Sigfox platform.  The API uses the HTTP protocol, following the REST principles (POST, GET, DELETE, PUT requests). The API endpoints accept and return data in the JSON format, with the corresponding \"application/json\" content type header.  The Sigfox API access differs for every API User based on their profile. If you already have a Sigfox account, you can retrieve the API Documentation customized for your API User directly in json or yaml format. The “how to” procedure is detailed in the [API Documentation](https://support.sigfox.com/docs/api-documentation) article.  The PUT request is the only request used to edit an existing entity. You don't need to specify each value. If a property is not present in the request, it won't be processed and updated. To remove an optional property, it must be filled in the request with the explicit value NULL. If a property has no value, it won't appear in the result of a GET request.  # Authentication and security Sigfox API is only accessible using HTTPS, and all API endpoints require authentication credentials (API user login and password). An API User is associated to a group with given profiles. You can view and manage your API User in the [Sigfox Portal](https://backend.sigfox.com/auth/login).  If you need an API User, follow the [API credential creation](https://support.sigfox.com/docs/api-credential-creation) procedure.  Your API User must remain private. Should the API credentials be compromised, new ones can be generated at any moment, invalidating the previous ones. CORS and JSONP are intentionally unsupported. CORS and JSONP JavaScript techniques tends to expose your credentials to your users. If you really need to call Sigfox API from JavaScript in the browser, you must set a reverse proxy on your website. Be careful not to use proxy for all requests to Sigfox OSS but to only select the relevant ones.  <!-- ReDoc-Inject: <security-definitions> -->  # Usage limits All Sigfox API endpoints are using the same underlying technology that powers the core Sigfox Platform. For Cloud efficiency and security reasons, Sigfox is moving a step forward on API rate limiting, by setting upper bounds for some API endpoints. Please note that a new HTTP response will be returned in case of rate exceeded : “HTTP 429: too many requests”.  For more information check [API Rate limiting](https://support.sigfox.com/docs/api-rate-limiting) policy. Sigfox reserves the right to modify these limits without notice.  # Versioning  Sigfox API supports versioning of its endpoints through a version suffix in the endpoint URL. This suffix has the following format: \"vX\", where X is the version number. For example: v2/device.  All requests must include the version suffix in the endpoint URL.  Any new backwards-incompatible change will be released in a new version.   Read the [API versioning management](https://storage.sbg1.cloud.ovh.net/v1/AUTH_669d7dfced0b44518cb186841d7cbd75/prod_docs/55746591-API_Versioning_management.pdf) to learn more about it.  # Paging  Some API requests will return a list of data. If the list is longer than the set limit, the items will be retrieved via multiple requests. The paging section in the response will specify a URL for the next request.  Keep in mind rate limiting policy to manage your requests.  You can use the limit parameter to limit the number of items to be returned, between 1 and 100 (default). The offset parameter is used to specify a number of items to skip.  # Errors  Sigfox API uses conventional HTTP response codes to indicate the success or failure of an API request.  Codes in the 2xx range indicate success.  Codes in the 4xx range indicate an error that failed given the information provided (e.g. a required parameter missing, a resource was not found, etc.). Often the response will also include a message explaining the error.  Codes in the 5xx range indicate an error with servers.   For more information please refer to the [Response code article](https://support.sigfox.com/docs/api-response-code-references).   # noqa: E501

    OpenAPI spec version: 2.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six


class DeviceMessage(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'device': 'object',
        'time': 'int',
        'data': 'str',
        'ack_required': 'bool',
        'lqi': 'int',
        'lqi_repeaters': 'int',
        'seq_number': 'int',
        'nb_frames': 'int',
        'computed_location': 'list[ComputedLocation]',
        'rinfos': 'list[Rinfo]',
        'downlink_answer_status': 'object'
    }

    attribute_map = {
        'device': 'device',
        'time': 'time',
        'data': 'data',
        'ack_required': 'ackRequired',
        'lqi': 'lqi',
        'lqi_repeaters': 'lqiRepeaters',
        'seq_number': 'seqNumber',
        'nb_frames': 'nbFrames',
        'computed_location': 'computedLocation',
        'rinfos': 'rinfos',
        'downlink_answer_status': 'downlinkAnswerStatus'
    }

    def __init__(self, device=None, time=None, data=None, ack_required=None, lqi=None, lqi_repeaters=None, seq_number=None, nb_frames=None, computed_location=None, rinfos=None, downlink_answer_status=None):  # noqa: E501
        """DeviceMessage - a model defined in Swagger"""  # noqa: E501
        self._device = None
        self._time = None
        self._data = None
        self._ack_required = None
        self._lqi = None
        self._lqi_repeaters = None
        self._seq_number = None
        self._nb_frames = None
        self._computed_location = None
        self._rinfos = None
        self._downlink_answer_status = None
        self.discriminator = None
        if device is not None:
            self.device = device
        if time is not None:
            self.time = time
        if data is not None:
            self.data = data
        if ack_required is not None:
            self.ack_required = ack_required
        if lqi is not None:
            self.lqi = lqi
        if lqi_repeaters is not None:
            self.lqi_repeaters = lqi_repeaters
        if seq_number is not None:
            self.seq_number = seq_number
        if nb_frames is not None:
            self.nb_frames = nb_frames
        if computed_location is not None:
            self.computed_location = computed_location
        if rinfos is not None:
            self.rinfos = rinfos
        if downlink_answer_status is not None:
            self.downlink_answer_status = downlink_answer_status

    @property
    def device(self):
        """Gets the device of this DeviceMessage.  # noqa: E501

        Defines a device message  # noqa: E501

        :return: The device of this DeviceMessage.  # noqa: E501
        :rtype: object
        """
        return self._device

    @device.setter
    def device(self, device):
        """Sets the device of this DeviceMessage.

        Defines a device message  # noqa: E501

        :param device: The device of this DeviceMessage.  # noqa: E501
        :type: object
        """

        self._device = device

    @property
    def time(self):
        """Gets the time of this DeviceMessage.  # noqa: E501

        Timestamp of the message (in milliseconds since the Unix Epoch)  # noqa: E501

        :return: The time of this DeviceMessage.  # noqa: E501
        :rtype: int
        """
        return self._time

    @time.setter
    def time(self, time):
        """Sets the time of this DeviceMessage.

        Timestamp of the message (in milliseconds since the Unix Epoch)  # noqa: E501

        :param time: The time of this DeviceMessage.  # noqa: E501
        :type: int
        """

        self._time = time

    @property
    def data(self):
        """Gets the data of this DeviceMessage.  # noqa: E501

        message content, hex encoded  # noqa: E501

        :return: The data of this DeviceMessage.  # noqa: E501
        :rtype: str
        """
        return self._data

    @data.setter
    def data(self, data):
        """Sets the data of this DeviceMessage.

        message content, hex encoded  # noqa: E501

        :param data: The data of this DeviceMessage.  # noqa: E501
        :type: str
        """

        self._data = data

    @property
    def ack_required(self):
        """Gets the ack_required of this DeviceMessage.  # noqa: E501

        true if an acknowledge is required  # noqa: E501

        :return: The ack_required of this DeviceMessage.  # noqa: E501
        :rtype: bool
        """
        return self._ack_required

    @ack_required.setter
    def ack_required(self, ack_required):
        """Sets the ack_required of this DeviceMessage.

        true if an acknowledge is required  # noqa: E501

        :param ack_required: The ack_required of this DeviceMessage.  # noqa: E501
        :type: bool
        """

        self._ack_required = ack_required

    @property
    def lqi(self):
        """Gets the lqi of this DeviceMessage.  # noqa: E501

        link quality indicator 0 -> LIMIT 1 -> AVERAGE 2 -> GOOD 3 -> EXCELLENT 4 -> NA   # noqa: E501

        :return: The lqi of this DeviceMessage.  # noqa: E501
        :rtype: int
        """
        return self._lqi

    @lqi.setter
    def lqi(self, lqi):
        """Sets the lqi of this DeviceMessage.

        link quality indicator 0 -> LIMIT 1 -> AVERAGE 2 -> GOOD 3 -> EXCELLENT 4 -> NA   # noqa: E501

        :param lqi: The lqi of this DeviceMessage.  # noqa: E501
        :type: int
        """

        self._lqi = lqi

    @property
    def lqi_repeaters(self):
        """Gets the lqi_repeaters of this DeviceMessage.  # noqa: E501

        link quality indicator for repeated message 0 -> LIMIT 1 -> AVERAGE 2 -> GOOD 3 -> EXCELLENT 4 -> NA   # noqa: E501

        :return: The lqi_repeaters of this DeviceMessage.  # noqa: E501
        :rtype: int
        """
        return self._lqi_repeaters

    @lqi_repeaters.setter
    def lqi_repeaters(self, lqi_repeaters):
        """Sets the lqi_repeaters of this DeviceMessage.

        link quality indicator for repeated message 0 -> LIMIT 1 -> AVERAGE 2 -> GOOD 3 -> EXCELLENT 4 -> NA   # noqa: E501

        :param lqi_repeaters: The lqi_repeaters of this DeviceMessage.  # noqa: E501
        :type: int
        """

        self._lqi_repeaters = lqi_repeaters

    @property
    def seq_number(self):
        """Gets the seq_number of this DeviceMessage.  # noqa: E501

        the sequence number for this message, may not be present when device uses VO protocol  # noqa: E501

        :return: The seq_number of this DeviceMessage.  # noqa: E501
        :rtype: int
        """
        return self._seq_number

    @seq_number.setter
    def seq_number(self, seq_number):
        """Sets the seq_number of this DeviceMessage.

        the sequence number for this message, may not be present when device uses VO protocol  # noqa: E501

        :param seq_number: The seq_number of this DeviceMessage.  # noqa: E501
        :type: int
        """

        self._seq_number = seq_number

    @property
    def nb_frames(self):
        """Gets the nb_frames of this DeviceMessage.  # noqa: E501

        nbFrames can be 1 or 3. This value represents an expected number of frames sent by the device.  # noqa: E501

        :return: The nb_frames of this DeviceMessage.  # noqa: E501
        :rtype: int
        """
        return self._nb_frames

    @nb_frames.setter
    def nb_frames(self, nb_frames):
        """Sets the nb_frames of this DeviceMessage.

        nbFrames can be 1 or 3. This value represents an expected number of frames sent by the device.  # noqa: E501

        :param nb_frames: The nb_frames of this DeviceMessage.  # noqa: E501
        :type: int
        """

        self._nb_frames = nb_frames

    @property
    def computed_location(self):
        """Gets the computed_location of this DeviceMessage.  # noqa: E501


        :return: The computed_location of this DeviceMessage.  # noqa: E501
        :rtype: list[ComputedLocation]
        """
        return self._computed_location

    @computed_location.setter
    def computed_location(self, computed_location):
        """Sets the computed_location of this DeviceMessage.


        :param computed_location: The computed_location of this DeviceMessage.  # noqa: E501
        :type: list[ComputedLocation]
        """

        self._computed_location = computed_location

    @property
    def rinfos(self):
        """Gets the rinfos of this DeviceMessage.  # noqa: E501


        :return: The rinfos of this DeviceMessage.  # noqa: E501
        :rtype: list[Rinfo]
        """
        return self._rinfos

    @rinfos.setter
    def rinfos(self, rinfos):
        """Sets the rinfos of this DeviceMessage.


        :param rinfos: The rinfos of this DeviceMessage.  # noqa: E501
        :type: list[Rinfo]
        """

        self._rinfos = rinfos

    @property
    def downlink_answer_status(self):
        """Gets the downlink_answer_status of this DeviceMessage.  # noqa: E501

        the last callback status for this reception  # noqa: E501

        :return: The downlink_answer_status of this DeviceMessage.  # noqa: E501
        :rtype: object
        """
        return self._downlink_answer_status

    @downlink_answer_status.setter
    def downlink_answer_status(self, downlink_answer_status):
        """Sets the downlink_answer_status of this DeviceMessage.

        the last callback status for this reception  # noqa: E501

        :param downlink_answer_status: The downlink_answer_status of this DeviceMessage.  # noqa: E501
        :type: object
        """

        self._downlink_answer_status = downlink_answer_status

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(DeviceMessage, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, DeviceMessage):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
