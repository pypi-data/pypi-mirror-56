{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["params","URLSearchParams","document","location","search","host","get","port","parseInt","ConnectionContext","React","createContext","MessageContext","Header","state","useContext","connected","react_default","a","createElement","className","selectedGroup","Navigation","cxt","Array","from","groups","sort","map","group","key","href","onClick","dispatch","type","NEW_SELECTION","data","unread","Controls","id","htmlFor","checked","autoScroll","onChange","e","TOGGLE_AUTOSCROLL","target","Log","listEl","useRef","mainEl","messages","useEffect","current","scrollToItem","length","ref","index_esm","height","clientHeight","itemCount","itemSize","width","overscanCount","_ref","index","style","row","concat","std","message","useWebsocket","_ref2","setConnected","onMessage","ws","queue","setInterval","splice","interval","readyState","WebSocket","onmessage","JSON","parse","push","onclose","clearInterval","reducer","action","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","value","groupMessages","alias","shift","Set","add","err","return","Object","assign","objectSpread","defineProperty","App","_React$useState","useState","_React$useState2","slicedToArray","_React$useReducer","useReducer","_React$useReducer2","Provider","App_Header","App_Navigation","App_Controls","App_Log","Boolean","window","hostname","match","ReactDOM","render","src_App_0","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.59cfe229.chunk.js","sourcesContent":["import React from 'react';\nimport './App.css';\nimport {FixedSizeList as List} from 'react-window';\n\n\nconst params = new URLSearchParams(document.location.search);\nconst host = params.get('host');\nconst port = parseInt(params.get('port'));\nconst MAX_MESSAGES = 10000;\n\n\nconst ConnectionContext = React.createContext(false);\nconst MessageContext = React.createContext({});\n\n\nconst Header = () => {\n    const {state} = React.useContext(MessageContext);\n    const connected = React.useContext(ConnectionContext);\n\n    return (\n        <header>\n            <h1 className={connected ? \"\" : \"offline\"}>Hoist <span>{state.selectedGroup || ''}</span>\n            </h1>\n            <span>{connected ? \"Connected\" : \"Connecting\"} to ws://{host}:{port}</span>\n        </header>\n    )\n};\n\n\nconst Navigation = () => {\n    const cxt = React.useContext(MessageContext);\n    return (\n        <nav>\n            {Array.from(cxt.state.groups).sort().map(group => (\n                <div key={group}>\n                    <a href=\"#\" onClick={() => cxt.dispatch({type: NEW_SELECTION, data: group})}>\n                        {group}\n                        {cxt.state.unread[group] ? <span className=\"unread\">{cxt.state.unread[group]}</span> : null}\n                    </a>\n                </div>\n            ))}\n        </nav>\n    )\n};\n\nconst Controls = () => {\n    const cxt = React.useContext(MessageContext);\n\n    return (\n        <div id=\"controls\">\n            <div className=\"item\">\n                <label htmlFor=\"auto-scroll\">\n                    <input id=\"auto-scroll\" type=\"checkbox\" checked={cxt.state.autoScroll} onChange={\n                        e => cxt.dispatch({type: TOGGLE_AUTOSCROLL, data: e.target.checked})\n                    }/> Auto-scroll\n                </label>\n            </div>\n        </div>\n    );\n};\n\nconst Log = () => {\n    const cxt = React.useContext(MessageContext);\n    const listEl = React.useRef(null);\n    const mainEl = React.useRef(null);\n\n    let messages = (cxt.state.messages[cxt.state.selectedGroup] || []);\n    React.useEffect(() => {\n        if (listEl.current && cxt.state.autoScroll) {\n            listEl.current.scrollToItem(messages.length - 1);\n        }\n    });\n\n\n    const Row = ({index, style}) => {\n        const row = messages[index];\n        return (\n            <div key={row.id} className={`std ${row.std}`} style={style}>\n                <div className=\"index\">{row.index}</div>\n                {row.message}</div>\n        );\n    };\n\n    return (\n        <main ref={mainEl}>\n            <List\n                ref={listEl}\n                height={mainEl.current ? mainEl.current.clientHeight : 16}\n                itemCount={messages.length}\n                itemSize={16}\n                width={'100%'}\n                overscanCount={24}\n            >\n                {Row}\n            </List>\n        </main>\n    );\n};\n\n\nconst useWebsocket = ({host, port, setConnected, onMessage}) => {\n    React.useEffect(() => {\n        let ws = null;\n        const queue = [];\n\n        setInterval(() => {\n            if (queue.length) {\n                onMessage(queue);\n                queue.splice(0, queue.length);\n            }\n        }, 1000 / 12);\n\n        const start = () => {\n            ws = new WebSocket(`ws://${host}:${port}`);\n\n            ws.onmessage = e => {\n                const data = JSON.parse(e.data);\n                // onMessage([data]);\n                queue.push(data);\n            };\n            ws.onclose = () => {\n                setConnected(false);\n            }\n        };\n\n        let interval = setInterval(() => {\n            if (!ws || ws.readyState === 3) {\n                start();\n            } else if (ws.readyState === 1) {\n                setConnected(true);\n            }\n\n        }, 500);\n\n        return () => clearInterval(interval);\n    }, []);\n};\n\n\nconst NEW_MESSAGE = 'NEW_MESSAGE';\nconst NEW_SELECTION = 'NEW_SELECTION';\nconst TOGGLE_AUTOSCROLL = 'TOGGLE_AUTOSCROLL';\n\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case NEW_MESSAGE:\n            for (let message of action.data) {\n                let groupMessages = (state.messages[message.alias] || []);\n                if (groupMessages.length) {\n                    message.index = groupMessages[groupMessages.length - 1].index + 1;\n                } else {\n                    state.unread[message.alias] = 0;\n                    message.index = 1\n                }\n                groupMessages = groupMessages.concat(message);\n                while (groupMessages.length >= MAX_MESSAGES) {\n                    groupMessages.shift();\n                }\n                state.messages[message.alias] = groupMessages;\n                state.groups = new Set(state.groups).add(message.alias);\n\n                if (!state.selectedGroup) {\n                    state.selectedGroup = message.alias;\n                }\n                if (state.selectedGroup !== message.alias) {\n                    state.unread[message.alias] += 1;\n                }\n\n            }\n            return Object.assign({}, state);\n\n        case NEW_SELECTION:\n            const unread = {...state.unread, ...{[action.data]: 0}};\n            return {...state, ...{selectedGroup: action.data, unread}};\n\n        case TOGGLE_AUTOSCROLL:\n            return {...state, ...{autoScroll: action.data}};\n    }\n};\n\n\nconst App = () => {\n\n    const [connected, setConnected] = React.useState(false);\n    const [state, dispatch] = React.useReducer(reducer, {\n        groups: new Set(),\n        messages: {},\n        selectedGroup: null,\n        autoScroll: true,\n        unread: {},\n    });\n    useWebsocket({\n        host,\n        port,\n        setConnected,\n        onMessage: (message) => {\n            dispatch({type: NEW_MESSAGE, data: message});\n        },\n    });\n\n\n    return (\n        <ConnectionContext.Provider value={connected}>\n            <MessageContext.Provider value={{state, dispatch}}>\n                <div className=\"App\">\n                    <Header/>\n                    <div className=\"grid\">\n                        <Navigation/>\n                        <Controls/>\n                        <Log/>\n                    </div>\n                </div>\n            </MessageContext.Provider>\n        </ConnectionContext.Provider>\n    )\n};\n\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}