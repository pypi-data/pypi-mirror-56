# auto generated by update_py.py
import logging
import logging.config
import pytz
import datetime
import os

from .utility import get_log_default_path


class Logger:

    LogConfig = {
        'version': 1,
        'disable_existing_loggers': False,
        'formatters': {
            'standard': {
                'format': '[%(asctime)s.%(msecs)03d] [%(name)s] [%(levelname)s] [%(filename)s:%(lineno)s] %(message)s',
                'datefmt': '%Y-%m-%d %H:%M:%S'
            }
        },
        'filters': {},
        'handlers': {
            'console': {
                'level': 'DEBUG',
                'class': 'logging.StreamHandler',
                'formatter': 'standard'
            },
            'default': {
                'level': 'DEBUG',
                'class': 'logging.handlers.TimedRotatingFileHandler',
                'filename': None,
                'formatter': 'standard',
                'encoding': 'utf-8',
                'when': 'D',
                'interval': 1
            }
        },
        'loggers': {
            '': {
                'handlers': ['default', 'console'],
                'level': None,
                'propagate': True
            }
        }
    }

    @classmethod
    def _get_log_level_from_env(cls, default_level=logging.DEBUG):
        log_level = os.environ.get("TLCLIENT_LOG_LEVEL")
        if log_level:
            log_level = log_level.lower()

        if log_level == "off":
            return logging.CRITICAL
        elif log_level == "critical":
            return logging.CRITICAL
        elif log_level == "err":
            return logging.ERROR
        elif log_level == "warn":
            return logging.WARNING
        elif log_level == "info":
            return logging.INFO
        elif log_level == "debug":
            return logging.DEBUG
        elif log_level == "trace":
            return logging.NOTSET
        else:
            return default_level

    @classmethod
    def _get_log_path_from_env(cls):
        log_path = os.environ.get("TLCLIENT_LOG_PATH") or get_log_default_path()
        if not os.path.exists(log_path):
            os.makedirs(log_path)
        if not os.path.isdir(log_path):
            raise TypeError("The log path '{}' is not a directory.".format(log_path))
        return log_path

    @classmethod
    def get_logger(cls, name):
        curr_date = datetime.datetime.now(pytz.timezone('Asia/Shanghai')).strftime("%Y-%m-%d")
        cls.LogConfig['handlers']['default']['filename'] = os.path.join(cls._get_log_path_from_env(), '{}_{}.txt'.format(name, curr_date))
        if not cls.LogConfig['loggers']['']['level']:
            cls.LogConfig['loggers']['']['level'] = cls._get_log_level_from_env()
        logging.config.dictConfig(cls.LogConfig)
        return logging.getLogger(name)

    @staticmethod
    def redirect_console_handler_to_DEVNULL():
        root_logger = logging.getLogger()
        for hdlr in root_logger.handlers:
            if hdlr.name == 'console':
                hdlr.setStream(open('/dev/null', 'w'))
