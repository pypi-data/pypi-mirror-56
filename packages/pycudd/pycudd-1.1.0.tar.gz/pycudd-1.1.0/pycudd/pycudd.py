# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
PyCUDD 2.0.1
Python interface to Colorado University Decision Diagram package
With BREL support
Compiled on Oct 23 2019, 09:53:24
Bugs to:aravind@engr.ucsb.edu
"""


from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pycudd', [dirname(__file__)])
        except ImportError:
            import _pycudd
            return _pycudd
        if fp is not None:
            try:
                _mod = imp.load_module('_pycudd', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pycudd = swig_import_helper()
    del swig_import_helper
else:
    import _pycudd
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



_pycudd.DOCSTRING_swigconstant(_pycudd)
DOCSTRING = _pycudd.DOCSTRING
class RangeError(_object):
    """Proxy of C++ RangeError class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr_nondynamic(self, RangeError, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RangeError, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(RangeError self) -> RangeError"""
        this = _pycudd.new_RangeError()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _pycudd.delete_RangeError
    __del__ = lambda self: None
RangeError_swigregister = _pycudd.RangeError_swigregister
RangeError_swigregister(RangeError)
cvar = _pycudd.cvar

class IntArray(_object):
    """Proxy of C++ IntArray class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr_nondynamic(self, IntArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntArray, name)
    __repr__ = _swig_repr
    __swig_setmethods__["vec"] = _pycudd.IntArray_vec_set
    __swig_getmethods__["vec"] = _pycudd.IntArray_vec_get
    if _newclass:
        vec = _swig_property(_pycudd.IntArray_vec_get, _pycudd.IntArray_vec_set)

    def __init__(self, size: 'int'):
        """__init__(IntArray self, int size) -> IntArray"""
        this = _pycudd.new_IntArray(size)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _pycudd.delete_IntArray
    __del__ = lambda self: None

    def AssignVect(self, str: 'int *', size: 'int') -> "void":
        """AssignVect(IntArray self, int * str, int size)"""
        return _pycudd.IntArray_AssignVect(self, str, size)


    def AssignComplVect(self, str: 'int *', size: 'int', univ: 'int') -> "void":
        """AssignComplVect(IntArray self, int * str, int size, int univ)"""
        return _pycudd.IntArray_AssignComplVect(self, str, size, univ)


    def ArrayAddress(self) -> "int **":
        """ArrayAddress(IntArray self) -> int **"""
        return _pycudd.IntArray_ArrayAddress(self)


    def __getitem__(self, j: 'int') -> "int":
        """__getitem__(IntArray self, int j) -> int"""
        return _pycudd.IntArray___getitem__(self, j)


    def __setitem__(self, j: 'int', val: 'int') -> "void":
        """__setitem__(IntArray self, int j, int val)"""
        return _pycudd.IntArray___setitem__(self, j, val)


    def __len__(self) -> "int":
        """__len__(IntArray self) -> int"""
        return _pycudd.IntArray___len__(self)


    def Assign(self, list: 'int *', k: 'int') -> "void":
        """Assign(IntArray self, int * list, int k)"""
        return _pycudd.IntArray_Assign(self, list, k)


    def Swap(self, i: 'int', j: 'int') -> "void":
        """Swap(IntArray self, int i, int j)"""
        return _pycudd.IntArray_Swap(self, i, j)

IntArray_swigregister = _pycudd.IntArray_swigregister
IntArray_swigregister(IntArray)

class StringArray(_object):
    """Proxy of C++ StringArray class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr_nondynamic(self, StringArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringArray, name)
    __repr__ = _swig_repr
    __swig_setmethods__["vec"] = _pycudd.StringArray_vec_set
    __swig_getmethods__["vec"] = _pycudd.StringArray_vec_get
    if _newclass:
        vec = _swig_property(_pycudd.StringArray_vec_get, _pycudd.StringArray_vec_set)

    def __init__(self, size: 'int'):
        """__init__(StringArray self, int size) -> StringArray"""
        this = _pycudd.new_StringArray(size)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _pycudd.delete_StringArray
    __del__ = lambda self: None

    def ArrayAddress(self) -> "char ***":
        """ArrayAddress(StringArray self) -> char ***"""
        return _pycudd.StringArray_ArrayAddress(self)


    def __getitem__(self, j: 'int') -> "char *":
        """__getitem__(StringArray self, int j) -> char *"""
        return _pycudd.StringArray___getitem__(self, j)


    def __setitem__(self, j: 'int', val: 'char *') -> "void":
        """__setitem__(StringArray self, int j, char * val)"""
        return _pycudd.StringArray___setitem__(self, j, val)


    def __len__(self) -> "int":
        """__len__(StringArray self) -> int"""
        return _pycudd.StringArray___len__(self)


    def Assign(self, list: 'char **', k: 'int') -> "void":
        """Assign(StringArray self, char ** list, int k)"""
        return _pycudd.StringArray_Assign(self, list, k)


    def Swap(self, i: 'int', j: 'int') -> "void":
        """Swap(StringArray self, int i, int j)"""
        return _pycudd.StringArray_Swap(self, i, j)

StringArray_swigregister = _pycudd.StringArray_swigregister
StringArray_swigregister(StringArray)

class DoubleArray(_object):
    """Proxy of C++ DoubleArray class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr_nondynamic(self, DoubleArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleArray, name)
    __repr__ = _swig_repr
    __swig_setmethods__["vec"] = _pycudd.DoubleArray_vec_set
    __swig_getmethods__["vec"] = _pycudd.DoubleArray_vec_get
    if _newclass:
        vec = _swig_property(_pycudd.DoubleArray_vec_get, _pycudd.DoubleArray_vec_set)

    def __init__(self, size: 'int'):
        """__init__(DoubleArray self, int size) -> DoubleArray"""
        this = _pycudd.new_DoubleArray(size)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _pycudd.delete_DoubleArray
    __del__ = lambda self: None

    def __getitem__(self, j: 'int') -> "double":
        """__getitem__(DoubleArray self, int j) -> double"""
        return _pycudd.DoubleArray___getitem__(self, j)


    def __setitem__(self, j: 'int', val: 'double') -> "void":
        """__setitem__(DoubleArray self, int j, double val)"""
        return _pycudd.DoubleArray___setitem__(self, j, val)


    def Assign(self, list: 'double *', k: 'int') -> "void":
        """Assign(DoubleArray self, double * list, int k)"""
        return _pycudd.DoubleArray_Assign(self, list, k)


    def Swap(self, i: 'int', j: 'int') -> "void":
        """Swap(DoubleArray self, int i, int j)"""
        return _pycudd.DoubleArray_Swap(self, i, j)

DoubleArray_swigregister = _pycudd.DoubleArray_swigregister
DoubleArray_swigregister(DoubleArray)

class DdArray(_object):
    """Proxy of C++ DdArray class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr_nondynamic(self, DdArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DdArray, name)
    __repr__ = _swig_repr

    __doc__ = "This class provides an array of DdNodes. This is an addition to the CUDD package. Create a DdArray by calling the constructor with the length of the array. In terms of Python array-like behaviour, you can index it, assign individual elements and take its length. Typically, these arrays are populated via the Push method. Refer pycudd.h and pycudd.cpp for function details.<br>"

    __swig_setmethods__["sz"] = _pycudd.DdArray_sz_set
    __swig_getmethods__["sz"] = _pycudd.DdArray_sz_get
    if _newclass:
        sz = _swig_property(_pycudd.DdArray_sz_get, _pycudd.DdArray_sz_set)
    __swig_setmethods__["vec"] = _pycudd.DdArray_vec_set
    __swig_getmethods__["vec"] = _pycudd.DdArray_vec_get
    if _newclass:
        vec = _swig_property(_pycudd.DdArray_vec_get, _pycudd.DdArray_vec_set)

    def __init__(self, size: 'int'):
        """__init__(DdArray self, int size) -> DdArray"""
        this = _pycudd.new_DdArray(size)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _pycudd.delete_DdArray
    __del__ = lambda self: None

    def __getitem__(self, j: 'int') -> "DdNode *":
        """__getitem__(DdArray self, int j) -> DdNode"""
        return _pycudd.DdArray___getitem__(self, j)


    def __setitem__(self, j: 'int', val: 'DdNode') -> "void":
        """__setitem__(DdArray self, int j, DdNode val)"""
        return _pycudd.DdArray___setitem__(self, j, val)


    def __len__(self) -> "int":
        """__len__(DdArray self) -> int"""
        return _pycudd.DdArray___len__(self)


    def Swap(self, i: 'int', j: 'int') -> "void":
        """Swap(DdArray self, int i, int j)"""
        return _pycudd.DdArray_Swap(self, i, j)


    def Pop(self) -> "DdNode *":
        """Pop(DdArray self) -> DdNode"""
        return _pycudd.DdArray_Pop(self)


    def And(self) -> "DdNode *":
        """And(DdArray self) -> DdNode"""
        return _pycudd.DdArray_And(self)


    def Or(self) -> "DdNode *":
        """Or(DdArray self) -> DdNode"""
        return _pycudd.DdArray_Or(self)


    def AtLeastN(self, n: 'int') -> "DdNode *":
        """AtLeastN(DdArray self, int n) -> DdNode"""
        return _pycudd.DdArray_AtLeastN(self, n)


    def ExactlyN(self, n: 'int') -> "DdNode *":
        """ExactlyN(DdArray self, int n) -> DdNode"""
        return _pycudd.DdArray_ExactlyN(self, n)


    def UpToN(self, n: 'int') -> "DdNode *":
        """UpToN(DdArray self, int n) -> DdNode"""
        return _pycudd.DdArray_UpToN(self, n)


    def Constraint(self, low: 'int', high: 'int') -> "DdNode *":
        """Constraint(DdArray self, int low, int high) -> DdNode"""
        return _pycudd.DdArray_Constraint(self, low, high)


    def Compose(self, term: 'DdNode') -> "DdNode *":
        """Compose(DdArray self, DdNode term) -> DdNode"""
        return _pycudd.DdArray_Compose(self, term)


    def Assign(self, list: 'DdNode **', k: 'int') -> "void":
        """Assign(DdArray self, DdNode ** list, int k)"""
        return _pycudd.DdArray_Assign(self, list, k)


    def Push(self, val: 'DdNode') -> "void":
        """Push(DdArray self, DdNode val)"""
        return _pycudd.DdArray_Push(self, val)


    def SwapNodes(self, i: 'int', j: 'int') -> "void":
        """SwapNodes(DdArray self, int i, int j)"""
        return _pycudd.DdArray_SwapNodes(self, i, j)


    def Fill(self, offset: 'int', mod: 'int') -> "void":
        """Fill(DdArray self, int offset, int mod)"""
        return _pycudd.DdArray_Fill(self, offset, mod)


    def FillWithIntArray(self, t: 'IntArray') -> "void":
        """FillWithIntArray(DdArray self, IntArray t)"""
        return _pycudd.DdArray_FillWithIntArray(self, t)


    def OrderVector(self, left: 'int', right: 'int') -> "void":
        """OrderVector(DdArray self, int left, int right)"""
        return _pycudd.DdArray_OrderVector(self, left, right)


    def SupportVector(self, term: 'DdNode') -> "void":
        """SupportVector(DdArray self, DdNode term)"""
        return _pycudd.DdArray_SupportVector(self, term)


    def SetVarMap(self, other: 'DdArray') -> "int":
        """SetVarMap(DdArray self, DdArray other) -> int"""
        return _pycudd.DdArray_SetVarMap(self, other)


    def VectorSupport(self) -> "DdNode *":
        """VectorSupport(DdArray self) -> DdNode"""
        return _pycudd.DdArray_VectorSupport(self)


    def VectorSupportIndex(self) -> "int":
        """VectorSupportIndex(DdArray self) -> int"""
        return _pycudd.DdArray_VectorSupportIndex(self)


    def PickOneMinterm(self, term: 'DdNode') -> "DdNode *":
        """PickOneMinterm(DdArray self, DdNode term) -> DdNode"""
        return _pycudd.DdArray_PickOneMinterm(self, term)


    def HoldTR(self, other: 'DdArray') -> "DdNode *":
        """HoldTR(DdArray self, DdArray other) -> DdNode"""
        return _pycudd.DdArray_HoldTR(self, other)


    def Find(self, term: 'DdNode') -> "int":
        """Find(DdArray self, DdNode term) -> int"""
        return _pycudd.DdArray_Find(self, term)


    def Save(self, filename: 'char *') -> "int":
        """Save(DdArray self, char * filename) -> int"""
        return _pycudd.DdArray_Save(self, filename)


    def SaveText(self, filename: 'char *') -> "int":
        """SaveText(DdArray self, char * filename) -> int"""
        return _pycudd.DdArray_SaveText(self, filename)


    def Load(self, filename: 'char *') -> "int":
        """Load(DdArray self, char * filename) -> int"""
        return _pycudd.DdArray_Load(self, filename)


    def LoadText(self, filename: 'char *') -> "int":
        """LoadText(DdArray self, char * filename) -> int"""
        return _pycudd.DdArray_LoadText(self, filename)


    def ArrayLoad(self, rootmatchmode: 'int', rootmatchnames: 'StringArray', varmatchmode: 'int', varmatchnames: 'StringArray', varmatchauxids: 'IntArray', varcomposeids: 'IntArray', mode: 'int', filename: 'char *', fp: 'FILE *'=None) -> "int":
        """
        ArrayLoad(DdArray self, int rootmatchmode, StringArray rootmatchnames, int varmatchmode, StringArray varmatchnames, IntArray varmatchauxids, IntArray varcomposeids, int mode, char * filename, FILE * fp=None) -> int
        ArrayLoad(DdArray self, int rootmatchmode, StringArray rootmatchnames, int varmatchmode, StringArray varmatchnames, IntArray varmatchauxids, IntArray varcomposeids, int mode, char * filename) -> int
        """
        return _pycudd.DdArray_ArrayLoad(self, rootmatchmode, rootmatchnames, varmatchmode, varmatchnames, varmatchauxids, varcomposeids, mode, filename, fp)


    def ArrayStore(self, ddname: 'char *', rootnames: 'StringArray', varnames: 'StringArray', auxids: 'IntArray', mode: 'int', varinfo: 'int', filename: 'char *', fp: 'FILE *'=None) -> "int":
        """
        ArrayStore(DdArray self, char * ddname, StringArray rootnames, StringArray varnames, IntArray auxids, int mode, int varinfo, char * filename, FILE * fp=None) -> int
        ArrayStore(DdArray self, char * ddname, StringArray rootnames, StringArray varnames, IntArray auxids, int mode, int varinfo, char * filename) -> int
        """
        return _pycudd.DdArray_ArrayStore(self, ddname, rootnames, varnames, auxids, mode, varinfo, filename, fp)

DdArray_swigregister = _pycudd.DdArray_swigregister
DdArray_swigregister(DdArray)

class MtrNode(_object):
    """Proxy of C++ MtrNode class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr_nondynamic(self, MtrNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MtrNode, name)
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(MtrNode self) -> MtrNode"""
        this = _pycudd.new_MtrNode()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _pycudd.delete_MtrNode
    __del__ = lambda self: None
MtrNode_swigregister = _pycudd.MtrNode_swigregister
MtrNode_swigregister(MtrNode)

class DdTlcInfo(_object):
    """Proxy of C++ DdTlcInfo class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr_nondynamic(self, DdTlcInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DdTlcInfo, name)
    __repr__ = _swig_repr

    __doc__ = "Helper class for enumeration of two literal clauses. Look at example2.py for usage."


    def __init__(self):
        """__init__(DdTlcInfo self) -> DdTlcInfo"""
        this = _pycudd.new_DdTlcInfo()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _pycudd.delete_DdTlcInfo
    __del__ = lambda self: None

    def ReadIthClause(self, i: 'int') -> "int":
        """ReadIthClause(DdTlcInfo self, int i) -> int"""
        return _pycudd.DdTlcInfo_ReadIthClause(self, i)

DdTlcInfo_swigregister = _pycudd.DdTlcInfo_swigregister
DdTlcInfo_swigregister(DdTlcInfo)

class EpDouble(_object):
    """Proxy of C++ EpDouble class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr_nondynamic(self, EpDouble, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EpDouble, name)
    __repr__ = _swig_repr

    __doc__ = "This provides the functionality of CUDD's extended precision library. In particular, instances of EpDouble may be passed to DdNode.EpdCountMinterm to retrieve the extended counts. Note also that the basic arithmetic operators (+,-,*,/) have been overloaded for use with EpDouble instances"


    def __init__(self, *args):
        """
        __init__(EpDouble self) -> EpDouble
        __init__(EpDouble self, double value) -> EpDouble
        __init__(EpDouble self, EpDouble value) -> EpDouble
        """
        this = _pycudd.new_EpDouble(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _pycudd.delete_EpDouble
    __del__ = lambda self: None

    def EpdConvert(self, value: 'double') -> "void":
        """EpdConvert(EpDouble self, double value)"""
        return _pycudd.EpDouble_EpdConvert(self, value)


    def EpdNormalize(self) -> "void":
        """EpdNormalize(EpDouble self)"""
        return _pycudd.EpDouble_EpdNormalize(self)


    def EpdNormalizeDecimal(self) -> "void":
        """EpdNormalizeDecimal(EpDouble self)"""
        return _pycudd.EpDouble_EpdNormalizeDecimal(self)


    def EpdMakeInf(self, sign: 'int') -> "void":
        """EpdMakeInf(EpDouble self, int sign)"""
        return _pycudd.EpDouble_EpdMakeInf(self, sign)


    def EpdMakeZero(self, sign: 'int') -> "void":
        """EpdMakeZero(EpDouble self, int sign)"""
        return _pycudd.EpDouble_EpdMakeZero(self, sign)


    def EpdMakeNan(self) -> "void":
        """EpdMakeNan(EpDouble self)"""
        return _pycudd.EpDouble_EpdMakeNan(self)


    def EpdCopy(self, to: 'EpDouble') -> "void":
        """EpdCopy(EpDouble self, EpDouble to)"""
        return _pycudd.EpDouble_EpdCopy(self, to)


    def EpdGetValueAndDecimalExponent(self) -> "void":
        """EpdGetValueAndDecimalExponent(EpDouble self)"""
        return _pycudd.EpDouble_EpdGetValueAndDecimalExponent(self)


    def EpdMultiply(self, value: 'double') -> "void":
        """EpdMultiply(EpDouble self, double value)"""
        return _pycudd.EpDouble_EpdMultiply(self, value)


    def EpdMultiply2(self, epd2: 'EpDouble') -> "void":
        """EpdMultiply2(EpDouble self, EpDouble epd2)"""
        return _pycudd.EpDouble_EpdMultiply2(self, epd2)


    def EpdMultiply2Decimal(self, epd2: 'EpDouble') -> "void":
        """EpdMultiply2Decimal(EpDouble self, EpDouble epd2)"""
        return _pycudd.EpDouble_EpdMultiply2Decimal(self, epd2)


    def EpdMultiply3(self, epd2: 'EpDouble', epd3: 'EpDouble') -> "void":
        """EpdMultiply3(EpDouble self, EpDouble epd2, EpDouble epd3)"""
        return _pycudd.EpDouble_EpdMultiply3(self, epd2, epd3)


    def EpdMultiply3Decimal(self, epd2: 'EpDouble', epd3: 'EpDouble') -> "void":
        """EpdMultiply3Decimal(EpDouble self, EpDouble epd2, EpDouble epd3)"""
        return _pycudd.EpDouble_EpdMultiply3Decimal(self, epd2, epd3)


    def EpdDivide(self, value: 'double') -> "void":
        """EpdDivide(EpDouble self, double value)"""
        return _pycudd.EpDouble_EpdDivide(self, value)


    def EpdDivide2(self, epd2: 'EpDouble') -> "void":
        """EpdDivide2(EpDouble self, EpDouble epd2)"""
        return _pycudd.EpDouble_EpdDivide2(self, epd2)


    def EpdDivide3(self, epd2: 'EpDouble', epd3: 'EpDouble') -> "void":
        """EpdDivide3(EpDouble self, EpDouble epd2, EpDouble epd3)"""
        return _pycudd.EpDouble_EpdDivide3(self, epd2, epd3)


    def EpdAdd(self, value: 'double') -> "void":
        """EpdAdd(EpDouble self, double value)"""
        return _pycudd.EpDouble_EpdAdd(self, value)


    def EpdAdd2(self, epd2: 'EpDouble') -> "void":
        """EpdAdd2(EpDouble self, EpDouble epd2)"""
        return _pycudd.EpDouble_EpdAdd2(self, epd2)


    def EpdAdd3(self, epd2: 'EpDouble', epd3: 'EpDouble') -> "void":
        """EpdAdd3(EpDouble self, EpDouble epd2, EpDouble epd3)"""
        return _pycudd.EpDouble_EpdAdd3(self, epd2, epd3)


    def EpdSubtract(self, value: 'double') -> "void":
        """EpdSubtract(EpDouble self, double value)"""
        return _pycudd.EpDouble_EpdSubtract(self, value)


    def EpdSubtract2(self, epd2: 'EpDouble') -> "void":
        """EpdSubtract2(EpDouble self, EpDouble epd2)"""
        return _pycudd.EpDouble_EpdSubtract2(self, epd2)


    def EpdSubtract3(self, epd2: 'EpDouble', epd3: 'EpDouble') -> "void":
        """EpdSubtract3(EpDouble self, EpDouble epd2, EpDouble epd3)"""
        return _pycudd.EpDouble_EpdSubtract3(self, epd2, epd3)


    def EpdPow2(self, n: 'int') -> "void":
        """EpdPow2(EpDouble self, int n)"""
        return _pycudd.EpDouble_EpdPow2(self, n)


    def EpdPow2Decimal(self, n: 'int') -> "void":
        """EpdPow2Decimal(EpDouble self, int n)"""
        return _pycudd.EpDouble_EpdPow2Decimal(self, n)


    def __add__(self, *args) -> "EpDouble *":
        """
        __add__(EpDouble self, EpDouble other) -> EpDouble
        __add__(EpDouble self, double other) -> EpDouble
        """
        return _pycudd.EpDouble___add__(self, *args)


    def __sub__(self, *args) -> "EpDouble *":
        """
        __sub__(EpDouble self, EpDouble other) -> EpDouble
        __sub__(EpDouble self, double other) -> EpDouble
        """
        return _pycudd.EpDouble___sub__(self, *args)


    def __mul__(self, *args) -> "EpDouble *":
        """
        __mul__(EpDouble self, EpDouble other) -> EpDouble
        __mul__(EpDouble self, double other) -> EpDouble
        """
        return _pycudd.EpDouble___mul__(self, *args)


    def __div__(self, *args) -> "EpDouble *":
        """
        __div__(EpDouble self, EpDouble other) -> EpDouble
        __div__(EpDouble self, double other) -> EpDouble
        """
        return _pycudd.EpDouble___div__(self, *args)


    def EpdCmp(self, other: 'EpDouble') -> "bool":
        """EpdCmp(EpDouble self, EpDouble other) -> bool"""
        return _pycudd.EpDouble_EpdCmp(self, other)


    def EpdIsInf(self) -> "bool":
        """EpdIsInf(EpDouble self) -> bool"""
        return _pycudd.EpDouble_EpdIsInf(self)


    def EpdIsZero(self) -> "bool":
        """EpdIsZero(EpDouble self) -> bool"""
        return _pycudd.EpDouble_EpdIsZero(self)


    def EpdIsNan(self) -> "bool":
        """EpdIsNan(EpDouble self) -> bool"""
        return _pycudd.EpDouble_EpdIsNan(self)


    def EpdIsNanOrInf(self) -> "bool":
        """EpdIsNanOrInf(EpDouble self) -> bool"""
        return _pycudd.EpDouble_EpdIsNanOrInf(self)


    def __nonzero__(self) -> "bool":
        """__nonzero__(EpDouble self) -> bool"""
        return _pycudd.EpDouble___nonzero__(self)


    def __eq__(self, other: 'EpDouble') -> "bool":
        """__eq__(EpDouble self, EpDouble other) -> bool"""
        return _pycudd.EpDouble___eq__(self, other)


    def __ne__(self, other: 'EpDouble') -> "bool":
        """__ne__(EpDouble self, EpDouble other) -> bool"""
        return _pycudd.EpDouble___ne__(self, other)

EpDouble_swigregister = _pycudd.EpDouble_swigregister
EpDouble_swigregister(EpDouble)


def EpdGetExponent(value: 'double') -> "int":
    """EpdGetExponent(double value) -> int"""
    return _pycudd.EpdGetExponent(value)

def EpdGetExponentDecimal(value: 'double') -> "int":
    """EpdGetExponentDecimal(double value) -> int"""
    return _pycudd.EpdGetExponentDecimal(value)

def IsInfDouble(value: 'double') -> "bool":
    """IsInfDouble(double value) -> bool"""
    return _pycudd.IsInfDouble(value)

def IsNanDouble(value: 'double') -> "bool":
    """IsNanDouble(double value) -> bool"""
    return _pycudd.IsNanDouble(value)

def IsNanOrInfDouble(value: 'double') -> "bool":
    """IsNanOrInfDouble(double value) -> bool"""
    return _pycudd.IsNanOrInfDouble(value)
class DdManager(_object):
    """Proxy of C++ DdManager class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr_nondynamic(self, DdManager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DdManager, name)
    __repr__ = _swig_repr

    __doc__ = "This class wraps around the DdManager. The methods defined by this class provide themselves as the DdManager option (if needed). To use PyCUDD, you must have at least one DdManager instance and you must set DdManager.SetDefault before using any of the other functions. These functions are provided through ddmanager.i."


    def __init__(self, *args):
        """
        __init__(DdManager self, unsigned int numVars=0, unsigned int numVarsZ=0, unsigned int numSlots, unsigned int cacheSize, unsigned long maxMemory=0) -> DdManager
        __init__(DdManager self, unsigned int numVars=0, unsigned int numVarsZ=0, unsigned int numSlots, unsigned int cacheSize) -> DdManager
        __init__(DdManager self, unsigned int numVars=0, unsigned int numVarsZ=0, unsigned int numSlots) -> DdManager
        __init__(DdManager self, unsigned int numVars=0, unsigned int numVarsZ=0) -> DdManager
        __init__(DdManager self, unsigned int numVars=0) -> DdManager
        __init__(DdManager self) -> DdManager
        """
        this = _pycudd.new_DdManager(*args)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _pycudd.delete_DdManager
    __del__ = lambda self: None

    def KillNode(self, num: 'long') -> "void":
        """KillNode(DdManager self, long num)"""
        return _pycudd.DdManager_KillNode(self, num)


    def IsPsVar(self, index: 'int') -> "int":
        """IsPsVar(DdManager self, int index) -> int"""
        return _pycudd.DdManager_IsPsVar(self, index)


    def IsNsVar(self, index: 'int') -> "int":
        """IsNsVar(DdManager self, int index) -> int"""
        return _pycudd.DdManager_IsNsVar(self, index)


    def SetPsVar(self, index: 'int') -> "int":
        """SetPsVar(DdManager self, int index) -> int"""
        return _pycudd.DdManager_SetPsVar(self, index)


    def SetNsVar(self, index: 'int') -> "int":
        """SetNsVar(DdManager self, int index) -> int"""
        return _pycudd.DdManager_SetNsVar(self, index)


    def SetPairIndex(self, index: 'int', pairIndex: 'int') -> "int":
        """SetPairIndex(DdManager self, int index, int pairIndex) -> int"""
        return _pycudd.DdManager_SetPairIndex(self, index, pairIndex)


    def ReadPairIndex(self, index: 'int') -> "int":
        """ReadPairIndex(DdManager self, int index) -> int"""
        return _pycudd.DdManager_ReadPairIndex(self, index)


    def SetVarToBeGrouped(self, index: 'int') -> "int":
        """SetVarToBeGrouped(DdManager self, int index) -> int"""
        return _pycudd.DdManager_SetVarToBeGrouped(self, index)


    def SetVarHardGroup(self, index: 'int') -> "int":
        """SetVarHardGroup(DdManager self, int index) -> int"""
        return _pycudd.DdManager_SetVarHardGroup(self, index)


    def ResetVarToBeGrouped(self, index: 'int') -> "int":
        """ResetVarToBeGrouped(DdManager self, int index) -> int"""
        return _pycudd.DdManager_ResetVarToBeGrouped(self, index)


    def IsVarToBeGrouped(self, index: 'int') -> "int":
        """IsVarToBeGrouped(DdManager self, int index) -> int"""
        return _pycudd.DdManager_IsVarToBeGrouped(self, index)


    def IsVarHardGroup(self, index: 'int') -> "int":
        """IsVarHardGroup(DdManager self, int index) -> int"""
        return _pycudd.DdManager_IsVarHardGroup(self, index)


    def SetVarToBeUngrouped(self, index: 'int') -> "int":
        """SetVarToBeUngrouped(DdManager self, int index) -> int"""
        return _pycudd.DdManager_SetVarToBeUngrouped(self, index)


    def IsVarToBeUngrouped(self, index: 'int') -> "int":
        """IsVarToBeUngrouped(DdManager self, int index) -> int"""
        return _pycudd.DdManager_IsVarToBeUngrouped(self, index)


    def SetPiVar(self, index: 'int') -> "int":
        """SetPiVar(DdManager self, int index) -> int"""
        return _pycudd.DdManager_SetPiVar(self, index)


    def IsPiVar(self, index: 'int') -> "int":
        """IsPiVar(DdManager self, int index) -> int"""
        return _pycudd.DdManager_IsPiVar(self, index)


    def BindVar(self, index: 'int') -> "int":
        """BindVar(DdManager self, int index) -> int"""
        return _pycudd.DdManager_BindVar(self, index)


    def UnbindVar(self, index: 'int') -> "int":
        """UnbindVar(DdManager self, int index) -> int"""
        return _pycudd.DdManager_UnbindVar(self, index)


    def VarIsBound(self, index: 'int') -> "int":
        """VarIsBound(DdManager self, int index) -> int"""
        return _pycudd.DdManager_VarIsBound(self, index)


    def ReadMaxGrowthAlternate(self) -> "double":
        """ReadMaxGrowthAlternate(DdManager self) -> double"""
        return _pycudd.DdManager_ReadMaxGrowthAlternate(self)


    def SetMaxGrowthAlternate(self, mg: 'double') -> "void":
        """SetMaxGrowthAlternate(DdManager self, double mg)"""
        return _pycudd.DdManager_SetMaxGrowthAlternate(self, mg)


    def ReadReorderingCycle(self) -> "int":
        """ReadReorderingCycle(DdManager self) -> int"""
        return _pycudd.DdManager_ReadReorderingCycle(self)


    def SetReorderingCycle(self, cycle: 'int') -> "void":
        """SetReorderingCycle(DdManager self, int cycle)"""
        return _pycudd.DdManager_SetReorderingCycle(self, cycle)


    def PrintCover(self, l: 'DdNode', u: 'DdNode') -> "int":
        """PrintCover(DdManager self, DdNode l, DdNode u) -> int"""
        return _pycudd.DdManager_PrintCover(self, l, u)


    def Prime(self, p: 'unsigned int') -> "unsigned int":
        """Prime(DdManager self, unsigned int p) -> unsigned int"""
        return _pycudd.DdManager_Prime(self, p)


    def __len__(self) -> "int":
        """__len__(DdManager self) -> int"""
        return _pycudd.DdManager___len__(self)


    def __getitem__(self, i: 'int') -> "DdNode *":
        """__getitem__(DdManager self, int i) -> DdNode"""
        return _pycudd.DdManager___getitem__(self, i)


    def addNewVar(self) -> "DdNode *":
        """addNewVar(DdManager self) -> DdNode"""
        return _pycudd.DdManager_addNewVar(self)


    def addNewVarAtLevel(self, level: 'int') -> "DdNode *":
        """addNewVarAtLevel(DdManager self, int level) -> DdNode"""
        return _pycudd.DdManager_addNewVarAtLevel(self, level)


    def NewVar(self) -> "DdNode *":
        """NewVar(DdManager self) -> DdNode"""
        return _pycudd.DdManager_NewVar(self)


    def NewVarAtLevel(self, level: 'int') -> "DdNode *":
        """NewVarAtLevel(DdManager self, int level) -> DdNode"""
        return _pycudd.DdManager_NewVarAtLevel(self, level)


    def addIthVar(self, i: 'int') -> "DdNode *":
        """addIthVar(DdManager self, int i) -> DdNode"""
        return _pycudd.DdManager_addIthVar(self, i)


    def IthVar(self, i: 'int') -> "DdNode *":
        """IthVar(DdManager self, int i) -> DdNode"""
        return _pycudd.DdManager_IthVar(self, i)


    def zddIthVar(self, i: 'int') -> "DdNode *":
        """zddIthVar(DdManager self, int i) -> DdNode"""
        return _pycudd.DdManager_zddIthVar(self, i)


    def zddVarsFromBddVars(self, multiplicity: 'int') -> "int":
        """zddVarsFromBddVars(DdManager self, int multiplicity) -> int"""
        return _pycudd.DdManager_zddVarsFromBddVars(self, multiplicity)


    def addConst(self, c: 'CUDD_VALUE_TYPE') -> "DdNode *":
        """addConst(DdManager self, CUDD_VALUE_TYPE c) -> DdNode"""
        return _pycudd.DdManager_addConst(self, c)


    def ReadStartTime(self) -> "unsigned long":
        """ReadStartTime(DdManager self) -> unsigned long"""
        return _pycudd.DdManager_ReadStartTime(self)


    def ReadElapsedTime(self) -> "unsigned long":
        """ReadElapsedTime(DdManager self) -> unsigned long"""
        return _pycudd.DdManager_ReadElapsedTime(self)


    def SetStartTime(self, st: 'unsigned long') -> "void":
        """SetStartTime(DdManager self, unsigned long st)"""
        return _pycudd.DdManager_SetStartTime(self, st)


    def ResetStartTime(self) -> "void":
        """ResetStartTime(DdManager self)"""
        return _pycudd.DdManager_ResetStartTime(self)


    def ReadTimeLimit(self) -> "unsigned long":
        """ReadTimeLimit(DdManager self) -> unsigned long"""
        return _pycudd.DdManager_ReadTimeLimit(self)


    def SetTimeLimit(self, tl: 'unsigned long') -> "unsigned long":
        """SetTimeLimit(DdManager self, unsigned long tl) -> unsigned long"""
        return _pycudd.DdManager_SetTimeLimit(self, tl)


    def UpdateTimeLimit(self) -> "void":
        """UpdateTimeLimit(DdManager self)"""
        return _pycudd.DdManager_UpdateTimeLimit(self)


    def IncreaseTimeLimit(self, increase: 'unsigned long') -> "void":
        """IncreaseTimeLimit(DdManager self, unsigned long increase)"""
        return _pycudd.DdManager_IncreaseTimeLimit(self, increase)


    def UnsetTimeLimit(self) -> "void":
        """UnsetTimeLimit(DdManager self)"""
        return _pycudd.DdManager_UnsetTimeLimit(self)


    def TimeLimited(self) -> "int":
        """TimeLimited(DdManager self) -> int"""
        return _pycudd.DdManager_TimeLimited(self)


    def AutodynEnable(self, method: 'int') -> "void":
        """AutodynEnable(DdManager self, int method)"""
        return _pycudd.DdManager_AutodynEnable(self, method)


    def AutodynDisable(self) -> "void":
        """AutodynDisable(DdManager self)"""
        return _pycudd.DdManager_AutodynDisable(self)


    def ReorderingStatus(self) -> "int":
        """ReorderingStatus(DdManager self) -> int"""
        return _pycudd.DdManager_ReorderingStatus(self)


    def AutodynEnableZdd(self, method: 'int') -> "void":
        """AutodynEnableZdd(DdManager self, int method)"""
        return _pycudd.DdManager_AutodynEnableZdd(self, method)


    def AutodynDisableZdd(self) -> "void":
        """AutodynDisableZdd(DdManager self)"""
        return _pycudd.DdManager_AutodynDisableZdd(self)


    def ReorderingStatusZdd(self) -> "int":
        """ReorderingStatusZdd(DdManager self) -> int"""
        return _pycudd.DdManager_ReorderingStatusZdd(self)


    def zddRealignmentEnabled(self) -> "int":
        """zddRealignmentEnabled(DdManager self) -> int"""
        return _pycudd.DdManager_zddRealignmentEnabled(self)


    def zddRealignEnable(self) -> "void":
        """zddRealignEnable(DdManager self)"""
        return _pycudd.DdManager_zddRealignEnable(self)


    def zddRealignDisable(self) -> "void":
        """zddRealignDisable(DdManager self)"""
        return _pycudd.DdManager_zddRealignDisable(self)


    def RealignmentEnabled(self) -> "int":
        """RealignmentEnabled(DdManager self) -> int"""
        return _pycudd.DdManager_RealignmentEnabled(self)


    def RealignEnable(self) -> "void":
        """RealignEnable(DdManager self)"""
        return _pycudd.DdManager_RealignEnable(self)


    def RealignDisable(self) -> "void":
        """RealignDisable(DdManager self)"""
        return _pycudd.DdManager_RealignDisable(self)


    def ReadOne(self) -> "DdNode *":
        """ReadOne(DdManager self) -> DdNode"""
        return _pycudd.DdManager_ReadOne(self)


    def ReadZddOne(self, i: 'int') -> "DdNode *":
        """ReadZddOne(DdManager self, int i) -> DdNode"""
        return _pycudd.DdManager_ReadZddOne(self, i)


    def ReadZero(self) -> "DdNode *":
        """ReadZero(DdManager self) -> DdNode"""
        return _pycudd.DdManager_ReadZero(self)


    def ReadLogicZero(self) -> "DdNode *":
        """ReadLogicZero(DdManager self) -> DdNode"""
        return _pycudd.DdManager_ReadLogicZero(self)


    def ReadPlusInfinity(self) -> "DdNode *":
        """ReadPlusInfinity(DdManager self) -> DdNode"""
        return _pycudd.DdManager_ReadPlusInfinity(self)


    def ReadMinusInfinity(self) -> "DdNode *":
        """ReadMinusInfinity(DdManager self) -> DdNode"""
        return _pycudd.DdManager_ReadMinusInfinity(self)


    def ReadBackground(self) -> "DdNode *":
        """ReadBackground(DdManager self) -> DdNode"""
        return _pycudd.DdManager_ReadBackground(self)


    def ReadCacheSlots(self) -> "unsigned int":
        """ReadCacheSlots(DdManager self) -> unsigned int"""
        return _pycudd.DdManager_ReadCacheSlots(self)


    def ReadCacheUsedSlots(self) -> "double":
        """ReadCacheUsedSlots(DdManager self) -> double"""
        return _pycudd.DdManager_ReadCacheUsedSlots(self)


    def ReadCacheLookUps(self) -> "double":
        """ReadCacheLookUps(DdManager self) -> double"""
        return _pycudd.DdManager_ReadCacheLookUps(self)


    def ReadCacheHits(self) -> "double":
        """ReadCacheHits(DdManager self) -> double"""
        return _pycudd.DdManager_ReadCacheHits(self)


    def ReadRecursiveCalls(self) -> "double":
        """ReadRecursiveCalls(DdManager self) -> double"""
        return _pycudd.DdManager_ReadRecursiveCalls(self)


    def ReadMinHit(self) -> "unsigned int":
        """ReadMinHit(DdManager self) -> unsigned int"""
        return _pycudd.DdManager_ReadMinHit(self)


    def SetMinHit(self, hr: 'unsigned int') -> "void":
        """SetMinHit(DdManager self, unsigned int hr)"""
        return _pycudd.DdManager_SetMinHit(self, hr)


    def ReadLooseUpTo(self) -> "unsigned int":
        """ReadLooseUpTo(DdManager self) -> unsigned int"""
        return _pycudd.DdManager_ReadLooseUpTo(self)


    def SetLooseUpTo(self, lut: 'unsigned int') -> "void":
        """SetLooseUpTo(DdManager self, unsigned int lut)"""
        return _pycudd.DdManager_SetLooseUpTo(self, lut)


    def ReadMaxCache(self) -> "unsigned int":
        """ReadMaxCache(DdManager self) -> unsigned int"""
        return _pycudd.DdManager_ReadMaxCache(self)


    def ReadMaxCacheHard(self) -> "unsigned int":
        """ReadMaxCacheHard(DdManager self) -> unsigned int"""
        return _pycudd.DdManager_ReadMaxCacheHard(self)


    def SetMaxCacheHard(self, mc: 'unsigned int') -> "void":
        """SetMaxCacheHard(DdManager self, unsigned int mc)"""
        return _pycudd.DdManager_SetMaxCacheHard(self, mc)


    def ReadSize(self) -> "int":
        """ReadSize(DdManager self) -> int"""
        return _pycudd.DdManager_ReadSize(self)


    def ReadZddSize(self) -> "int":
        """ReadZddSize(DdManager self) -> int"""
        return _pycudd.DdManager_ReadZddSize(self)


    def ReadSlots(self) -> "unsigned int":
        """ReadSlots(DdManager self) -> unsigned int"""
        return _pycudd.DdManager_ReadSlots(self)


    def ReadUsedSlots(self) -> "double":
        """ReadUsedSlots(DdManager self) -> double"""
        return _pycudd.DdManager_ReadUsedSlots(self)


    def ExpectedUsedSlots(self) -> "double":
        """ExpectedUsedSlots(DdManager self) -> double"""
        return _pycudd.DdManager_ExpectedUsedSlots(self)


    def ReadKeys(self) -> "unsigned int":
        """ReadKeys(DdManager self) -> unsigned int"""
        return _pycudd.DdManager_ReadKeys(self)


    def ReadDead(self) -> "unsigned int":
        """ReadDead(DdManager self) -> unsigned int"""
        return _pycudd.DdManager_ReadDead(self)


    def ReadMinDead(self) -> "unsigned int":
        """ReadMinDead(DdManager self) -> unsigned int"""
        return _pycudd.DdManager_ReadMinDead(self)


    def ReadReorderings(self) -> "int":
        """ReadReorderings(DdManager self) -> int"""
        return _pycudd.DdManager_ReadReorderings(self)


    def ReadReorderingTime(self) -> "long":
        """ReadReorderingTime(DdManager self) -> long"""
        return _pycudd.DdManager_ReadReorderingTime(self)


    def ReadGarbageCollections(self) -> "int":
        """ReadGarbageCollections(DdManager self) -> int"""
        return _pycudd.DdManager_ReadGarbageCollections(self)


    def ReadGarbageCollectionTime(self) -> "long":
        """ReadGarbageCollectionTime(DdManager self) -> long"""
        return _pycudd.DdManager_ReadGarbageCollectionTime(self)


    def GarbageCollect(self, clearCache: 'int') -> "int":
        """GarbageCollect(DdManager self, int clearCache) -> int"""
        return _pycudd.DdManager_GarbageCollect(self, clearCache)


    def ReadNodesFreed(self) -> "double":
        """ReadNodesFreed(DdManager self) -> double"""
        return _pycudd.DdManager_ReadNodesFreed(self)


    def ReadNodesDropped(self) -> "double":
        """ReadNodesDropped(DdManager self) -> double"""
        return _pycudd.DdManager_ReadNodesDropped(self)


    def ReadUniqueLookUps(self) -> "double":
        """ReadUniqueLookUps(DdManager self) -> double"""
        return _pycudd.DdManager_ReadUniqueLookUps(self)


    def ReadUniqueLinks(self) -> "double":
        """ReadUniqueLinks(DdManager self) -> double"""
        return _pycudd.DdManager_ReadUniqueLinks(self)


    def ReadSiftMaxVar(self) -> "int":
        """ReadSiftMaxVar(DdManager self) -> int"""
        return _pycudd.DdManager_ReadSiftMaxVar(self)


    def SetSiftMaxVar(self, smv: 'int') -> "void":
        """SetSiftMaxVar(DdManager self, int smv)"""
        return _pycudd.DdManager_SetSiftMaxVar(self, smv)


    def ReadSiftMaxSwap(self) -> "int":
        """ReadSiftMaxSwap(DdManager self) -> int"""
        return _pycudd.DdManager_ReadSiftMaxSwap(self)


    def SetSiftMaxSwap(self, sms: 'int') -> "void":
        """SetSiftMaxSwap(DdManager self, int sms)"""
        return _pycudd.DdManager_SetSiftMaxSwap(self, sms)


    def ReadMaxGrowth(self) -> "double":
        """ReadMaxGrowth(DdManager self) -> double"""
        return _pycudd.DdManager_ReadMaxGrowth(self)


    def SetMaxGrowth(self, mg: 'double') -> "void":
        """SetMaxGrowth(DdManager self, double mg)"""
        return _pycudd.DdManager_SetMaxGrowth(self, mg)


    def ReadTree(self) -> "MtrNode *":
        """ReadTree(DdManager self) -> MtrNode"""
        return _pycudd.DdManager_ReadTree(self)


    def SetTree(self, tree: 'MtrNode') -> "void":
        """SetTree(DdManager self, MtrNode tree)"""
        return _pycudd.DdManager_SetTree(self, tree)


    def FreeTree(self) -> "void":
        """FreeTree(DdManager self)"""
        return _pycudd.DdManager_FreeTree(self)


    def ReadZddTree(self) -> "MtrNode *":
        """ReadZddTree(DdManager self) -> MtrNode"""
        return _pycudd.DdManager_ReadZddTree(self)


    def SetZddTree(self, tree: 'MtrNode') -> "void":
        """SetZddTree(DdManager self, MtrNode tree)"""
        return _pycudd.DdManager_SetZddTree(self, tree)


    def FreeZddTree(self) -> "void":
        """FreeZddTree(DdManager self)"""
        return _pycudd.DdManager_FreeZddTree(self)


    def ReadPerm(self, i: 'int') -> "int":
        """ReadPerm(DdManager self, int i) -> int"""
        return _pycudd.DdManager_ReadPerm(self, i)


    def ReadPermZdd(self, i: 'int') -> "int":
        """ReadPermZdd(DdManager self, int i) -> int"""
        return _pycudd.DdManager_ReadPermZdd(self, i)


    def ReadInvPerm(self, i: 'int') -> "int":
        """ReadInvPerm(DdManager self, int i) -> int"""
        return _pycudd.DdManager_ReadInvPerm(self, i)


    def ReadInvPermZdd(self, i: 'int') -> "int":
        """ReadInvPermZdd(DdManager self, int i) -> int"""
        return _pycudd.DdManager_ReadInvPermZdd(self, i)


    def ReadVars(self, i: 'int') -> "DdNode *":
        """ReadVars(DdManager self, int i) -> DdNode"""
        return _pycudd.DdManager_ReadVars(self, i)


    def ReadEpsilon(self) -> "CUDD_VALUE_TYPE":
        """ReadEpsilon(DdManager self) -> CUDD_VALUE_TYPE"""
        return _pycudd.DdManager_ReadEpsilon(self)


    def SetEpsilon(self, ep: 'CUDD_VALUE_TYPE') -> "void":
        """SetEpsilon(DdManager self, CUDD_VALUE_TYPE ep)"""
        return _pycudd.DdManager_SetEpsilon(self, ep)


    def ReadGroupcheck(self) -> "Cudd_AggregationType":
        """ReadGroupcheck(DdManager self) -> Cudd_AggregationType"""
        return _pycudd.DdManager_ReadGroupcheck(self)


    def SetGroupcheck(self, gc: 'Cudd_AggregationType') -> "void":
        """SetGroupcheck(DdManager self, Cudd_AggregationType gc)"""
        return _pycudd.DdManager_SetGroupcheck(self, gc)


    def GarbageCollectionEnabled(self) -> "int":
        """GarbageCollectionEnabled(DdManager self) -> int"""
        return _pycudd.DdManager_GarbageCollectionEnabled(self)


    def EnableGarbageCollection(self) -> "void":
        """EnableGarbageCollection(DdManager self)"""
        return _pycudd.DdManager_EnableGarbageCollection(self)


    def DisableGarbageCollection(self) -> "void":
        """DisableGarbageCollection(DdManager self)"""
        return _pycudd.DdManager_DisableGarbageCollection(self)


    def DeadAreCounted(self) -> "int":
        """DeadAreCounted(DdManager self) -> int"""
        return _pycudd.DdManager_DeadAreCounted(self)


    def TurnOnCountDead(self) -> "void":
        """TurnOnCountDead(DdManager self)"""
        return _pycudd.DdManager_TurnOnCountDead(self)


    def TurnOffCountDead(self) -> "void":
        """TurnOffCountDead(DdManager self)"""
        return _pycudd.DdManager_TurnOffCountDead(self)


    def ReadRecomb(self) -> "int":
        """ReadRecomb(DdManager self) -> int"""
        return _pycudd.DdManager_ReadRecomb(self)


    def SetRecomb(self, recomb: 'int') -> "void":
        """SetRecomb(DdManager self, int recomb)"""
        return _pycudd.DdManager_SetRecomb(self, recomb)


    def ReadSymmviolation(self) -> "int":
        """ReadSymmviolation(DdManager self) -> int"""
        return _pycudd.DdManager_ReadSymmviolation(self)


    def SetSymmviolation(self, symmviolation: 'int') -> "void":
        """SetSymmviolation(DdManager self, int symmviolation)"""
        return _pycudd.DdManager_SetSymmviolation(self, symmviolation)


    def ReadArcviolation(self) -> "int":
        """ReadArcviolation(DdManager self) -> int"""
        return _pycudd.DdManager_ReadArcviolation(self)


    def SetArcviolation(self, arcviolation: 'int') -> "void":
        """SetArcviolation(DdManager self, int arcviolation)"""
        return _pycudd.DdManager_SetArcviolation(self, arcviolation)


    def ReadPopulationSize(self) -> "int":
        """ReadPopulationSize(DdManager self) -> int"""
        return _pycudd.DdManager_ReadPopulationSize(self)


    def SetPopulationSize(self, populationSize: 'int') -> "void":
        """SetPopulationSize(DdManager self, int populationSize)"""
        return _pycudd.DdManager_SetPopulationSize(self, populationSize)


    def ReadNumberXovers(self) -> "int":
        """ReadNumberXovers(DdManager self) -> int"""
        return _pycudd.DdManager_ReadNumberXovers(self)


    def SetNumberXovers(self, numberXovers: 'int') -> "void":
        """SetNumberXovers(DdManager self, int numberXovers)"""
        return _pycudd.DdManager_SetNumberXovers(self, numberXovers)


    def ReadMemoryInUse(self) -> "long":
        """ReadMemoryInUse(DdManager self) -> long"""
        return _pycudd.DdManager_ReadMemoryInUse(self)


    def ReadPeakNodeCount(self) -> "long":
        """ReadPeakNodeCount(DdManager self) -> long"""
        return _pycudd.DdManager_ReadPeakNodeCount(self)


    def ReadPeakLiveNodeCount(self) -> "int":
        """ReadPeakLiveNodeCount(DdManager self) -> int"""
        return _pycudd.DdManager_ReadPeakLiveNodeCount(self)


    def ReadNodeCount(self) -> "long":
        """ReadNodeCount(DdManager self) -> long"""
        return _pycudd.DdManager_ReadNodeCount(self)


    def zddReadNodeCount(self) -> "long":
        """zddReadNodeCount(DdManager self) -> long"""
        return _pycudd.DdManager_zddReadNodeCount(self)


    def EnableReorderingReporting(self) -> "int":
        """EnableReorderingReporting(DdManager self) -> int"""
        return _pycudd.DdManager_EnableReorderingReporting(self)


    def DisableReorderingReporting(self) -> "int":
        """DisableReorderingReporting(DdManager self) -> int"""
        return _pycudd.DdManager_DisableReorderingReporting(self)


    def ReorderingReporting(self) -> "int":
        """ReorderingReporting(DdManager self) -> int"""
        return _pycudd.DdManager_ReorderingReporting(self)


    def ReadErrorCode(self) -> "Cudd_ErrorType":
        """ReadErrorCode(DdManager self) -> Cudd_ErrorType"""
        return _pycudd.DdManager_ReadErrorCode(self)


    def ClearErrorCode(self) -> "void":
        """ClearErrorCode(DdManager self)"""
        return _pycudd.DdManager_ClearErrorCode(self)


    def SetStdout(self, fp: 'FILE *') -> "void":
        """SetStdout(DdManager self, FILE * fp)"""
        return _pycudd.DdManager_SetStdout(self, fp)


    def ReadNextReordering(self) -> "unsigned int":
        """ReadNextReordering(DdManager self) -> unsigned int"""
        return _pycudd.DdManager_ReadNextReordering(self)


    def ReadSwapSteps(self) -> "double":
        """ReadSwapSteps(DdManager self) -> double"""
        return _pycudd.DdManager_ReadSwapSteps(self)


    def ReadMaxLive(self) -> "unsigned int":
        """ReadMaxLive(DdManager self) -> unsigned int"""
        return _pycudd.DdManager_ReadMaxLive(self)


    def SetMaxLive(self, maxLive: 'unsigned int') -> "void":
        """SetMaxLive(DdManager self, unsigned int maxLive)"""
        return _pycudd.DdManager_SetMaxLive(self, maxLive)


    def ReadMaxMemory(self) -> "long":
        """ReadMaxMemory(DdManager self) -> long"""
        return _pycudd.DdManager_ReadMaxMemory(self)


    def SetMaxMemory(self, maxMemory: 'long') -> "void":
        """SetMaxMemory(DdManager self, long maxMemory)"""
        return _pycudd.DdManager_SetMaxMemory(self, maxMemory)


    def SetNextReordering(self, next: 'unsigned int') -> "void":
        """SetNextReordering(DdManager self, unsigned int next)"""
        return _pycudd.DdManager_SetNextReordering(self, next)


    def DebugCheck(self) -> "int":
        """DebugCheck(DdManager self) -> int"""
        return _pycudd.DdManager_DebugCheck(self)


    def CheckKeys(self) -> "int":
        """CheckKeys(DdManager self) -> int"""
        return _pycudd.DdManager_CheckKeys(self)


    def MakeTreeNode(self, low: 'unsigned int', size: 'unsigned int', type: 'unsigned int') -> "MtrNode *":
        """MakeTreeNode(DdManager self, unsigned int low, unsigned int size, unsigned int type) -> MtrNode"""
        return _pycudd.DdManager_MakeTreeNode(self, low, size, type)


    def PrintLinear(self) -> "int":
        """PrintLinear(DdManager self) -> int"""
        return _pycudd.DdManager_PrintLinear(self)


    def ReadLinear(self, x: 'int', y: 'int') -> "int":
        """ReadLinear(DdManager self, int x, int y) -> int"""
        return _pycudd.DdManager_ReadLinear(self, x, y)


    def CheckZeroRef(self) -> "int":
        """CheckZeroRef(DdManager self) -> int"""
        return _pycudd.DdManager_CheckZeroRef(self)


    def ReduceHeap(self, heuristic: 'int', minsize: 'int') -> "int":
        """ReduceHeap(DdManager self, int heuristic, int minsize) -> int"""
        return _pycudd.DdManager_ReduceHeap(self, heuristic, minsize)


    def ShuffleHeap(self, permutation: 'IntArray') -> "int":
        """ShuffleHeap(DdManager self, IntArray permutation) -> int"""
        return _pycudd.DdManager_ShuffleHeap(self, permutation)


    def SymmProfile(self, lower: 'int', upper: 'int') -> "void":
        """SymmProfile(DdManager self, int lower, int upper)"""
        return _pycudd.DdManager_SymmProfile(self, lower, upper)


    def IndicesToCube(self, array: 'IntArray', n: 'int') -> "DdNode *":
        """IndicesToCube(DdManager self, IntArray array, int n) -> DdNode"""
        return _pycudd.DdManager_IndicesToCube(self, array, n)


    def AverageDistance(self) -> "double":
        """AverageDistance(DdManager self) -> double"""
        return _pycudd.DdManager_AverageDistance(self)


    def MakeZddTreeNode(self, low: 'unsigned int', size: 'unsigned int', type: 'unsigned int') -> "MtrNode *":
        """MakeZddTreeNode(DdManager self, unsigned int low, unsigned int size, unsigned int type) -> MtrNode"""
        return _pycudd.DdManager_MakeZddTreeNode(self, low, size, type)


    def zddPrintSubtable(self) -> "void":
        """zddPrintSubtable(DdManager self)"""
        return _pycudd.DdManager_zddPrintSubtable(self)


    def zddReduceHeap(self, heuristic: 'int', minsize: 'int') -> "int":
        """zddReduceHeap(DdManager self, int heuristic, int minsize) -> int"""
        return _pycudd.DdManager_zddReduceHeap(self, heuristic, minsize)


    def zddShuffleHeap(self, permutation: 'IntArray') -> "int":
        """zddShuffleHeap(DdManager self, IntArray permutation) -> int"""
        return _pycudd.DdManager_zddShuffleHeap(self, permutation)


    def zddSymmProfile(self, lower: 'int', upper: 'int') -> "void":
        """zddSymmProfile(DdManager self, int lower, int upper)"""
        return _pycudd.DdManager_zddSymmProfile(self, lower, upper)


    def BddToAdd(self, B: 'DdNode') -> "DdNode *":
        """BddToAdd(DdManager self, DdNode B) -> DdNode"""
        return _pycudd.DdManager_BddToAdd(self, B)


    def addBddPattern(self, f: 'DdNode') -> "DdNode *":
        """addBddPattern(DdManager self, DdNode f) -> DdNode"""
        return _pycudd.DdManager_addBddPattern(self, f)


    def addBddThreshold(self, f: 'DdNode', value: 'CUDD_VALUE_TYPE') -> "DdNode *":
        """addBddThreshold(DdManager self, DdNode f, CUDD_VALUE_TYPE value) -> DdNode"""
        return _pycudd.DdManager_addBddThreshold(self, f, value)


    def addBddStrictThreshold(self, f: 'DdNode', value: 'CUDD_VALUE_TYPE') -> "DdNode *":
        """addBddStrictThreshold(DdManager self, DdNode f, CUDD_VALUE_TYPE value) -> DdNode"""
        return _pycudd.DdManager_addBddStrictThreshold(self, f, value)


    def addBddInterval(self, f: 'DdNode', lower: 'CUDD_VALUE_TYPE', upper: 'CUDD_VALUE_TYPE') -> "DdNode *":
        """addBddInterval(DdManager self, DdNode f, CUDD_VALUE_TYPE lower, CUDD_VALUE_TYPE upper) -> DdNode"""
        return _pycudd.DdManager_addBddInterval(self, f, lower, upper)


    def addBddIthBit(self, f: 'DdNode', bit: 'int') -> "DdNode *":
        """addBddIthBit(DdManager self, DdNode f, int bit) -> DdNode"""
        return _pycudd.DdManager_addBddIthBit(self, f, bit)


    def zddPortFromBdd(self, B: 'DdNode') -> "DdNode *":
        """zddPortFromBdd(DdManager self, DdNode B) -> DdNode"""
        return _pycudd.DdManager_zddPortFromBdd(self, B)


    def zddPortToBdd(self, f: 'DdNode') -> "DdNode *":
        """zddPortToBdd(DdManager self, DdNode f) -> DdNode"""
        return _pycudd.DdManager_zddPortToBdd(self, f)


    def MakeBddFromZddCover(self, node: 'DdNode') -> "DdNode *":
        """MakeBddFromZddCover(DdManager self, DdNode node) -> DdNode"""
        return _pycudd.DdManager_MakeBddFromZddCover(self, node)


    def Random(self) -> "long":
        """Random(DdManager self) -> long"""
        return _pycudd.DdManager_Random(self)


    def Srandom(self, seed: 'long') -> "void":
        """Srandom(DdManager self, long seed)"""
        return _pycudd.DdManager_Srandom(self, seed)


    def OutOfMem(self, size: 'long') -> "void":
        """OutOfMem(DdManager self, long size)"""
        return _pycudd.DdManager_OutOfMem(self, size)


    def Transfer(self, ddDestination: 'DdManager', f: 'DdNode') -> "DdNode *":
        """Transfer(DdManager self, DdManager ddDestination, DdNode f) -> DdNode"""
        return _pycudd.DdManager_Transfer(self, ddDestination, f)


    def CubeArrayToBdd(self, y: 'IntArray') -> "DdNode *":
        """CubeArrayToBdd(DdManager self, IntArray y) -> DdNode"""
        return _pycudd.DdManager_CubeArrayToBdd(self, y)


    def SetVarMap(self, x: 'DdArray', y: 'DdArray', n: 'int') -> "int":
        """SetVarMap(DdManager self, DdArray x, DdArray y, int n) -> int"""
        return _pycudd.DdManager_SetVarMap(self, x, y, n)


    def ComputeCube(self, vars: 'DdArray', phase: 'IntArray', n: 'int') -> "DdNode *":
        """ComputeCube(DdManager self, DdArray vars, IntArray phase, int n) -> DdNode"""
        return _pycudd.DdManager_ComputeCube(self, vars, phase, n)


    def zddDumpDot(self, n: 'int', f: 'DdArray', inames: 'char **', onames: 'char **', fp: 'FILE *') -> "int":
        """zddDumpDot(DdManager self, int n, DdArray f, char ** inames, char ** onames, FILE * fp) -> int"""
        return _pycudd.DdManager_zddDumpDot(self, n, f, inames, onames, fp)


    def VectorSupportSize(self, F: 'DdArray', n: 'int') -> "int":
        """VectorSupportSize(DdManager self, DdArray F, int n) -> int"""
        return _pycudd.DdManager_VectorSupportSize(self, F, n)


    def ClassifySupport(self, f: 'DdNode', g: 'DdNode', common: 'DdArray', onlyF: 'DdArray', onlyG: 'DdArray') -> "int":
        """ClassifySupport(DdManager self, DdNode f, DdNode g, DdArray common, DdArray onlyF, DdArray onlyG) -> int"""
        return _pycudd.DdManager_ClassifySupport(self, f, g, common, onlyF, onlyG)


    def Xgty(self, N: 'int', z: 'DdArray', x: 'DdArray', y: 'DdArray') -> "DdNode *":
        """Xgty(DdManager self, int N, DdArray z, DdArray x, DdArray y) -> DdNode"""
        return _pycudd.DdManager_Xgty(self, N, z, x, y)


    def Xeqy(self, N: 'int', x: 'DdArray', y: 'DdArray') -> "DdNode *":
        """Xeqy(DdManager self, int N, DdArray x, DdArray y) -> DdNode"""
        return _pycudd.DdManager_Xeqy(self, N, x, y)


    def Dxygtdxz(self, N: 'int', x: 'DdArray', y: 'DdArray', z: 'DdArray') -> "DdNode *":
        """Dxygtdxz(DdManager self, int N, DdArray x, DdArray y, DdArray z) -> DdNode"""
        return _pycudd.DdManager_Dxygtdxz(self, N, x, y, z)


    def Dxygtdyz(self, N: 'int', x: 'DdArray', y: 'DdArray', z: 'DdArray') -> "DdNode *":
        """Dxygtdyz(DdManager self, int N, DdArray x, DdArray y, DdArray z) -> DdNode"""
        return _pycudd.DdManager_Dxygtdyz(self, N, x, y, z)


    def SharingSize(self, nodeArray: 'DdArray', n: 'int') -> "int":
        """SharingSize(DdManager self, DdArray nodeArray, int n) -> int"""
        return _pycudd.DdManager_SharingSize(self, nodeArray, n)


    def ReadIndex(self, i: 'int') -> "int":
        """ReadIndex(DdManager self, int i) -> int"""
        return _pycudd.DdManager_ReadIndex(self, i)


    def addPlus(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addPlus(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addPlus(self, f, g)


    def addTimes(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addTimes(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addTimes(self, f, g)


    def addThreshold(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addThreshold(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addThreshold(self, f, g)


    def addSetNZ(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addSetNZ(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addSetNZ(self, f, g)


    def addDivide(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addDivide(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addDivide(self, f, g)


    def addMinus(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addMinus(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addMinus(self, f, g)


    def addMinimum(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addMinimum(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addMinimum(self, f, g)


    def addMaximum(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addMaximum(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addMaximum(self, f, g)


    def addOneZeroMaximum(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addOneZeroMaximum(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addOneZeroMaximum(self, f, g)


    def addDiff(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addDiff(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addDiff(self, f, g)


    def addAgreement(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addAgreement(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addAgreement(self, f, g)


    def addOr(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addOr(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addOr(self, f, g)


    def addNand(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addNand(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addNand(self, f, g)


    def addNor(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addNor(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addNor(self, f, g)


    def addXor(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addXor(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addXor(self, f, g)


    def addXnor(self, f: 'DdArray', g: 'DdArray') -> "DdNode *":
        """addXnor(DdManager self, DdArray f, DdArray g) -> DdNode"""
        return _pycudd.DdManager_addXnor(self, f, g)


    def addWalsh(self, x: 'DdArray', y: 'DdArray', n: 'int') -> "DdNode *":
        """addWalsh(DdManager self, DdArray x, DdArray y, int n) -> DdNode"""
        return _pycudd.DdManager_addWalsh(self, x, y, n)


    def addHamming(self, xVars: 'DdArray', yVars: 'DdArray', nVars: 'int') -> "DdNode *":
        """addHamming(DdManager self, DdArray xVars, DdArray yVars, int nVars) -> DdNode"""
        return _pycudd.DdManager_addHamming(self, xVars, yVars, nVars)


    def addComputeCube(self, vars: 'DdArray', phase: 'IntArray', n: 'int') -> "DdNode *":
        """addComputeCube(DdManager self, DdArray vars, IntArray phase, int n) -> DdNode"""
        return _pycudd.DdManager_addComputeCube(self, vars, phase, n)


    def addResidue(self, n: 'int', m: 'int', options: 'int', top: 'int') -> "DdNode *":
        """addResidue(DdManager self, int n, int m, int options, int top) -> DdNode"""
        return _pycudd.DdManager_addResidue(self, n, m, options, top)


    def addXeqy(self, N: 'int', x: 'DdArray', y: 'DdArray') -> "DdNode *":
        """addXeqy(DdManager self, int N, DdArray x, DdArray y) -> DdNode"""
        return _pycudd.DdManager_addXeqy(self, N, x, y)


    def ApaNumberOfDigits(self, binaryDigits: 'int') -> "int":
        """ApaNumberOfDigits(DdManager self, int binaryDigits) -> int"""
        return _pycudd.DdManager_ApaNumberOfDigits(self, binaryDigits)


    def NewApaNumber(self, digits: 'int') -> "DdApaNumber":
        """NewApaNumber(DdManager self, int digits) -> DdApaNumber"""
        return _pycudd.DdManager_NewApaNumber(self, digits)


    def ApaCopy(self, digits: 'int', source: 'DdApaNumber', dest: 'DdApaNumber') -> "void":
        """ApaCopy(DdManager self, int digits, DdApaNumber source, DdApaNumber dest)"""
        return _pycudd.DdManager_ApaCopy(self, digits, source, dest)


    def ApaAdd(self, digits: 'int', a: 'DdApaNumber', b: 'DdApaNumber', sum: 'DdApaNumber') -> "DdApaDigit":
        """ApaAdd(DdManager self, int digits, DdApaNumber a, DdApaNumber b, DdApaNumber sum) -> DdApaDigit"""
        return _pycudd.DdManager_ApaAdd(self, digits, a, b, sum)


    def ApaSubtract(self, digits: 'int', a: 'DdApaNumber', b: 'DdApaNumber', diff: 'DdApaNumber') -> "DdApaDigit":
        """ApaSubtract(DdManager self, int digits, DdApaNumber a, DdApaNumber b, DdApaNumber diff) -> DdApaDigit"""
        return _pycudd.DdManager_ApaSubtract(self, digits, a, b, diff)


    def ApaShortDivision(self, digits: 'int', dividend: 'DdApaNumber', divisor: 'DdApaDigit', quotient: 'DdApaNumber') -> "DdApaDigit":
        """ApaShortDivision(DdManager self, int digits, DdApaNumber dividend, DdApaDigit divisor, DdApaNumber quotient) -> DdApaDigit"""
        return _pycudd.DdManager_ApaShortDivision(self, digits, dividend, divisor, quotient)


    def ApaIntDivision(self, digits: 'int', dividend: 'DdApaNumber', divisor: 'unsigned int', quotient: 'DdApaNumber') -> "unsigned int":
        """ApaIntDivision(DdManager self, int digits, DdApaNumber dividend, unsigned int divisor, DdApaNumber quotient) -> unsigned int"""
        return _pycudd.DdManager_ApaIntDivision(self, digits, dividend, divisor, quotient)


    def ApaShiftRight(self, digits: 'int', arg3: 'DdApaDigit', a: 'DdApaNumber', b: 'DdApaNumber') -> "void":
        """ApaShiftRight(DdManager self, int digits, DdApaDigit arg3, DdApaNumber a, DdApaNumber b)"""
        return _pycudd.DdManager_ApaShiftRight(self, digits, arg3, a, b)


    def ApaSetToLiteral(self, digits: 'int', number: 'DdApaNumber', literal: 'DdApaDigit') -> "void":
        """ApaSetToLiteral(DdManager self, int digits, DdApaNumber number, DdApaDigit literal)"""
        return _pycudd.DdManager_ApaSetToLiteral(self, digits, number, literal)


    def ApaPowerOfTwo(self, digits: 'int', number: 'DdApaNumber', power: 'int') -> "void":
        """ApaPowerOfTwo(DdManager self, int digits, DdApaNumber number, int power)"""
        return _pycudd.DdManager_ApaPowerOfTwo(self, digits, number, power)


    def ApaCompare(self, digitsFirst: 'int', first: 'DdApaNumber', digitsSecond: 'int', second: 'DdApaNumber') -> "int":
        """ApaCompare(DdManager self, int digitsFirst, DdApaNumber first, int digitsSecond, DdApaNumber second) -> int"""
        return _pycudd.DdManager_ApaCompare(self, digitsFirst, first, digitsSecond, second)


    def ApaCompareRatios(self, digitsFirst: 'int', firstNum: 'DdApaNumber', firstDen: 'unsigned int', digitsSecond: 'int', secondNum: 'DdApaNumber', secondDen: 'unsigned int') -> "int":
        """ApaCompareRatios(DdManager self, int digitsFirst, DdApaNumber firstNum, unsigned int firstDen, int digitsSecond, DdApaNumber secondNum, unsigned int secondDen) -> int"""
        return _pycudd.DdManager_ApaCompareRatios(self, digitsFirst, firstNum, firstDen, digitsSecond, secondNum, secondDen)


    def One(self) -> "DdNode *":
        """One(DdManager self) -> DdNode"""
        return _pycudd.DdManager_One(self)


    def Zero(self) -> "DdNode *":
        """Zero(DdManager self) -> DdNode"""
        return _pycudd.DdManager_Zero(self)


    def Sort(self, leftnd: 'DdNode', rightnd: 'DdNode') -> "int":
        """Sort(DdManager self, DdNode leftnd, DdNode rightnd) -> int"""
        return _pycudd.DdManager_Sort(self, leftnd, rightnd)


    def PrintStdOut(self) -> "int":
        """PrintStdOut(DdManager self) -> int"""
        return _pycudd.DdManager_PrintStdOut(self)


    def StateCube(self, cube: 'char *', base: 'int', offset: 'int', scale: 'int') -> "DdNode *":
        """StateCube(DdManager self, char * cube, int base, int offset, int scale) -> DdNode"""
        return _pycudd.DdManager_StateCube(self, cube, base, offset, scale)


    def SetDefault(self) -> "void":
        """SetDefault(DdManager self)"""
        return _pycudd.DdManager_SetDefault(self)

DdManager_swigregister = _pycudd.DdManager_swigregister
DdManager_swigregister(DdManager)

class DdGen(_object):
    """Proxy of C++ DdGen class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr_nondynamic(self, DdGen, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DdGen, name)
    __repr__ = _swig_repr

    __doc__ = "Not expected to be used directly."


    def __init__(self, node1: 'DdNode', method: 'int', node2: 'DdNode'=None):
        """
        __init__(DdGen self, DdNode node1, int method, DdNode node2=None) -> DdGen
        __init__(DdGen self, DdNode node1, int method) -> DdGen
        """
        this = _pycudd.new_DdGen(node1, method, node2)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _pycudd.delete_DdGen
    __del__ = lambda self: None
DdGen_swigregister = _pycudd.DdGen_swigregister
DdGen_swigregister(DdGen)

class DdNode(_object):
    """Proxy of C++ DdNode class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr_nondynamic(self, DdNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DdNode, name)
    __repr__ = _swig_repr

    def __iter__(self):
      global iter_meth, cudd_version
      if iter_meth == 0:
        return ForeachCubeIterator(self)
      elif iter_meth == 1:
        return ForeachNodeIterator(self)
      elif iter_meth == 2:
        if cudd_version < 0x020400:
          print("Cannot iterate over primes with CUDD < 2.4.0")
          raise RuntimeError
        npair = NodePair(self,self)
        return ForeachPrimeIterator(npair)
    def __deepcopy__(self,memo):
      return self
    __doc__ = "This class wraps around the basic DdNode. The methods defined by this class take the default manager as their DdManager option (if needed) and provide themselves as the first DdNode option that those functions require, as indicated by the self argument. These functions may be found in ddnode.i."


    def __init__(self):
        """__init__(DdNode self) -> DdNode"""
        this = _pycudd.new_DdNode()
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _pycudd.delete_DdNode
    __del__ = lambda self: None

    def FirstCube(self, gen: 'DdGen') -> "int":
        """FirstCube(DdNode self, DdGen gen) -> int"""
        return _pycudd.DdNode_FirstCube(self, gen)


    def NextCube(self, gen: 'DdGen') -> "int":
        """NextCube(DdNode self, DdGen gen) -> int"""
        return _pycudd.DdNode_NextCube(self, gen)


    def FirstNode(self, gen: 'DdGen') -> "int":
        """FirstNode(DdNode self, DdGen gen) -> int"""
        return _pycudd.DdNode_FirstNode(self, gen)


    def NextNode(self, gen: 'DdGen') -> "int":
        """NextNode(DdNode self, DdGen gen) -> int"""
        return _pycudd.DdNode_NextNode(self, gen)


    def AndAbstractLimit(self, g: 'DdNode', cube: 'DdNode', limit: 'unsigned int') -> "DdNode *":
        """AndAbstractLimit(DdNode self, DdNode g, DdNode cube, unsigned int limit) -> DdNode"""
        return _pycudd.DdNode_AndAbstractLimit(self, g, cube, limit)


    def AndLimit(self, g: 'DdNode', limit: 'unsigned int') -> "DdNode *":
        """AndLimit(DdNode self, DdNode g, unsigned int limit) -> DdNode"""
        return _pycudd.DdNode_AndLimit(self, g, limit)


    def NPAnd(self, c: 'DdNode') -> "DdNode *":
        """NPAnd(DdNode self, DdNode c) -> DdNode"""
        return _pycudd.DdNode_NPAnd(self, c)


    def FindTwoLiteralClauses(self) -> "DdTlcInfo *":
        """FindTwoLiteralClauses(DdNode self) -> DdTlcInfo"""
        return _pycudd.DdNode_FindTwoLiteralClauses(self)


    def EpdCountMinterm(self, nvars: 'int', epd: 'EpDouble') -> "int":
        """EpdCountMinterm(DdNode self, int nvars, EpDouble epd) -> int"""
        return _pycudd.DdNode_EpdCountMinterm(self, nvars, epd)


    def ApproxConjDecomp(self) -> "int":
        """ApproxConjDecomp(DdNode self) -> int"""
        return _pycudd.DdNode_ApproxConjDecomp(self)


    def ApproxDisjDecomp(self) -> "int":
        """ApproxDisjDecomp(DdNode self) -> int"""
        return _pycudd.DdNode_ApproxDisjDecomp(self)


    def IterConjDecomp(self) -> "int":
        """IterConjDecomp(DdNode self) -> int"""
        return _pycudd.DdNode_IterConjDecomp(self)


    def IterDisjDecomp(self) -> "int":
        """IterDisjDecomp(DdNode self) -> int"""
        return _pycudd.DdNode_IterDisjDecomp(self)


    def GenConjDecomp(self) -> "int":
        """GenConjDecomp(DdNode self) -> int"""
        return _pycudd.DdNode_GenConjDecomp(self)


    def GenDisjDecomp(self) -> "int":
        """GenDisjDecomp(DdNode self) -> int"""
        return _pycudd.DdNode_GenDisjDecomp(self)


    def VarConjDecomp(self) -> "int":
        """VarConjDecomp(DdNode self) -> int"""
        return _pycudd.DdNode_VarConjDecomp(self)


    def VarDisjDecomp(self) -> "int":
        """VarDisjDecomp(DdNode self) -> int"""
        return _pycudd.DdNode_VarDisjDecomp(self)


    def ClosestCube(self, g: 'DdNode') -> "DdNode *":
        """ClosestCube(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_ClosestCube(self, g)


    def LeqUnless(self, g: 'DdNode', D: 'DdNode') -> "int":
        """LeqUnless(DdNode self, DdNode g, DdNode D) -> int"""
        return _pycudd.DdNode_LeqUnless(self, g, D)


    def MakePrime(self, f: 'DdNode') -> "DdNode *":
        """MakePrime(DdNode self, DdNode f) -> DdNode"""
        return _pycudd.DdNode_MakePrime(self, f)


    def CountPathsToNonZero(self) -> "double":
        """CountPathsToNonZero(DdNode self) -> double"""
        return _pycudd.DdNode_CountPathsToNonZero(self)


    def SupportIndex(self) -> "int":
        """SupportIndex(DdNode self) -> int"""
        return _pycudd.DdNode_SupportIndex(self)


    def ExistAbstract(self, cube: 'DdNode') -> "DdNode *":
        """ExistAbstract(DdNode self, DdNode cube) -> DdNode"""
        return _pycudd.DdNode_ExistAbstract(self, cube)


    def XorExistAbstract(self, g: 'DdNode', cube: 'DdNode') -> "DdNode *":
        """XorExistAbstract(DdNode self, DdNode g, DdNode cube) -> DdNode"""
        return _pycudd.DdNode_XorExistAbstract(self, g, cube)


    def UnivAbstract(self, cube: 'DdNode') -> "DdNode *":
        """UnivAbstract(DdNode self, DdNode cube) -> DdNode"""
        return _pycudd.DdNode_UnivAbstract(self, cube)


    def BooleanDiff(self, x: 'int') -> "DdNode *":
        """BooleanDiff(DdNode self, int x) -> DdNode"""
        return _pycudd.DdNode_BooleanDiff(self, x)


    def AndAbstract(self, g: 'DdNode', cube: 'DdNode') -> "DdNode *":
        """AndAbstract(DdNode self, DdNode g, DdNode cube) -> DdNode"""
        return _pycudd.DdNode_AndAbstract(self, g, cube)


    def VarIsDependent(self, var: 'DdNode') -> "int":
        """VarIsDependent(DdNode self, DdNode var) -> int"""
        return _pycudd.DdNode_VarIsDependent(self, var)


    def Correlation(self, g: 'DdNode') -> "double":
        """Correlation(DdNode self, DdNode g) -> double"""
        return _pycudd.DdNode_Correlation(self, g)


    def CorrelationWeights(self, g: 'DdNode', prob: 'DoubleArray') -> "double":
        """CorrelationWeights(DdNode self, DdNode g, DoubleArray prob) -> double"""
        return _pycudd.DdNode_CorrelationWeights(self, g, prob)


    def Ite(self, g: 'DdNode', h: 'DdNode') -> "DdNode *":
        """Ite(DdNode self, DdNode g, DdNode h) -> DdNode"""
        return _pycudd.DdNode_Ite(self, g, h)


    def IteConstant(self, g: 'DdNode', h: 'DdNode') -> "DdNode *":
        """IteConstant(DdNode self, DdNode g, DdNode h) -> DdNode"""
        return _pycudd.DdNode_IteConstant(self, g, h)


    def Intersect(self, g: 'DdNode') -> "DdNode *":
        """Intersect(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_Intersect(self, g)


    def FIntersect(self, g: 'DdNode') -> "int":
        """FIntersect(DdNode self, DdNode g) -> int"""
        return _pycudd.DdNode_FIntersect(self, g)


    def And(self, g: 'DdNode') -> "DdNode *":
        """And(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_And(self, g)


    def Or(self, g: 'DdNode') -> "DdNode *":
        """Or(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_Or(self, g)


    def Nand(self, g: 'DdNode') -> "DdNode *":
        """Nand(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_Nand(self, g)


    def Nor(self, g: 'DdNode') -> "DdNode *":
        """Nor(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_Nor(self, g)


    def Xor(self, g: 'DdNode') -> "DdNode *":
        """Xor(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_Xor(self, g)


    def Xnor(self, g: 'DdNode') -> "DdNode *":
        """Xnor(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_Xnor(self, g)


    def ClippingAnd(self, g: 'DdNode', maxDepth: 'int', direction: 'int') -> "DdNode *":
        """ClippingAnd(DdNode self, DdNode g, int maxDepth, int direction) -> DdNode"""
        return _pycudd.DdNode_ClippingAnd(self, g, maxDepth, direction)


    def ClippingAndAbstract(self, g: 'DdNode', cube: 'DdNode', maxDepth: 'int', direction: 'int') -> "DdNode *":
        """ClippingAndAbstract(DdNode self, DdNode g, DdNode cube, int maxDepth, int direction) -> DdNode"""
        return _pycudd.DdNode_ClippingAndAbstract(self, g, cube, maxDepth, direction)


    def LICompaction(self, c: 'DdNode') -> "DdNode *":
        """LICompaction(DdNode self, DdNode c) -> DdNode"""
        return _pycudd.DdNode_LICompaction(self, c)


    def Squeeze(self, u: 'DdNode') -> "DdNode *":
        """Squeeze(DdNode self, DdNode u) -> DdNode"""
        return _pycudd.DdNode_Squeeze(self, u)


    def Minimize(self, c: 'DdNode') -> "DdNode *":
        """Minimize(DdNode self, DdNode c) -> DdNode"""
        return _pycudd.DdNode_Minimize(self, c)


    def Constrain(self, c: 'DdNode') -> "DdNode *":
        """Constrain(DdNode self, DdNode c) -> DdNode"""
        return _pycudd.DdNode_Constrain(self, c)


    def Restrict(self, c: 'DdNode') -> "DdNode *":
        """Restrict(DdNode self, DdNode c) -> DdNode"""
        return _pycudd.DdNode_Restrict(self, c)


    def PickOneCube(self, string: 'char *') -> "int":
        """PickOneCube(DdNode self, char * string) -> int"""
        return _pycudd.DdNode_PickOneCube(self, string)


    def PickOneMinterm(self, vars: 'DdArray', n: 'int') -> "DdNode *":
        """PickOneMinterm(DdNode self, DdArray vars, int n) -> DdNode"""
        return _pycudd.DdNode_PickOneMinterm(self, vars, n)


    def PickArbitraryMinterms(self, vars: 'DdArray', n: 'int', k: 'int') -> "DdArray *":
        """PickArbitraryMinterms(DdNode self, DdArray vars, int n, int k) -> DdArray"""
        return _pycudd.DdNode_PickArbitraryMinterms(self, vars, n, k)


    def Compose(self, g: 'DdNode', v: 'int') -> "DdNode *":
        """Compose(DdNode self, DdNode g, int v) -> DdNode"""
        return _pycudd.DdNode_Compose(self, g, v)


    def Permute(self, permut: 'IntArray') -> "DdNode *":
        """Permute(DdNode self, IntArray permut) -> DdNode"""
        return _pycudd.DdNode_Permute(self, permut)


    def VarMap(self) -> "DdNode *":
        """VarMap(DdNode self) -> DdNode"""
        return _pycudd.DdNode_VarMap(self)


    def LiteralSetIntersection(self, g: 'DdNode') -> "DdNode *":
        """LiteralSetIntersection(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_LiteralSetIntersection(self, g)


    def IsVarEssential(self, id: 'int', phase: 'int') -> "int":
        """IsVarEssential(DdNode self, int id, int phase) -> int"""
        return _pycudd.DdNode_IsVarEssential(self, id, phase)


    def Leq(self, g: 'DdNode') -> "bool":
        """Leq(DdNode self, DdNode g) -> bool"""
        return _pycudd.DdNode_Leq(self, g)


    def CharToVect(self) -> "DdArray *":
        """CharToVect(DdNode self) -> DdArray"""
        return _pycudd.DdNode_CharToVect(self)


    def ConstrainDecomp(self) -> "DdArray *":
        """ConstrainDecomp(DdNode self) -> DdArray"""
        return _pycudd.DdNode_ConstrainDecomp(self)


    def Isop(self, U: 'DdNode') -> "DdNode *":
        """Isop(DdNode self, DdNode U) -> DdNode"""
        return _pycudd.DdNode_Isop(self, U)


    def SwapVariables(self, x: 'DdArray', y: 'DdArray', n: 'int') -> "DdNode *":
        """SwapVariables(DdNode self, DdArray x, DdArray y, int n) -> DdNode"""
        return _pycudd.DdNode_SwapVariables(self, x, y, n)


    def AdjPermuteX(self, x: 'DdArray', n: 'int') -> "DdNode *":
        """AdjPermuteX(DdNode self, DdArray x, int n) -> DdNode"""
        return _pycudd.DdNode_AdjPermuteX(self, x, n)


    def VectorCompose(self, vector: 'DdArray') -> "DdNode *":
        """VectorCompose(DdNode self, DdArray vector) -> DdNode"""
        return _pycudd.DdNode_VectorCompose(self, vector)


    def SetBackground(self) -> "void":
        """SetBackground(DdNode self)"""
        return _pycudd.DdNode_SetBackground(self)


    def UnderApprox(self, numVars: 'int', threshold: 'int', safe: 'int', quality: 'double') -> "DdNode *":
        """UnderApprox(DdNode self, int numVars, int threshold, int safe, double quality) -> DdNode"""
        return _pycudd.DdNode_UnderApprox(self, numVars, threshold, safe, quality)


    def OverApprox(self, numVars: 'int', threshold: 'int', safe: 'int', quality: 'double') -> "DdNode *":
        """OverApprox(DdNode self, int numVars, int threshold, int safe, double quality) -> DdNode"""
        return _pycudd.DdNode_OverApprox(self, numVars, threshold, safe, quality)


    def RemapUnderApprox(self, numVars: 'int', threshold: 'int', quality: 'double') -> "DdNode *":
        """RemapUnderApprox(DdNode self, int numVars, int threshold, double quality) -> DdNode"""
        return _pycudd.DdNode_RemapUnderApprox(self, numVars, threshold, quality)


    def RemapOverApprox(self, numVars: 'int', threshold: 'int', quality: 'double') -> "DdNode *":
        """RemapOverApprox(DdNode self, int numVars, int threshold, double quality) -> DdNode"""
        return _pycudd.DdNode_RemapOverApprox(self, numVars, threshold, quality)


    def BiasedUnderApprox(self, b: 'DdNode', numVars: 'int', threshold: 'int', quality1: 'double', quality0: 'double') -> "DdNode *":
        """BiasedUnderApprox(DdNode self, DdNode b, int numVars, int threshold, double quality1, double quality0) -> DdNode"""
        return _pycudd.DdNode_BiasedUnderApprox(self, b, numVars, threshold, quality1, quality0)


    def BiasedOverApprox(self, b: 'DdNode', numVars: 'int', threshold: 'int', quality1: 'double', quality0: 'double') -> "DdNode *":
        """BiasedOverApprox(DdNode self, DdNode b, int numVars, int threshold, double quality1, double quality0) -> DdNode"""
        return _pycudd.DdNode_BiasedOverApprox(self, b, numVars, threshold, quality1, quality0)


    def Cofactor(self, g: 'DdNode') -> "DdNode *":
        """Cofactor(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_Cofactor(self, g)


    def FindEssential(self) -> "DdNode *":
        """FindEssential(DdNode self) -> DdNode"""
        return _pycudd.DdNode_FindEssential(self)


    def SubsetCompress(self, nvars: 'int', threshold: 'int') -> "DdNode *":
        """SubsetCompress(DdNode self, int nvars, int threshold) -> DdNode"""
        return _pycudd.DdNode_SubsetCompress(self, nvars, threshold)


    def SupersetCompress(self, nvars: 'int', threshold: 'int') -> "DdNode *":
        """SupersetCompress(DdNode self, int nvars, int threshold) -> DdNode"""
        return _pycudd.DdNode_SupersetCompress(self, nvars, threshold)


    def CProjection(self, Y: 'DdNode') -> "DdNode *":
        """CProjection(DdNode self, DdNode Y) -> DdNode"""
        return _pycudd.DdNode_CProjection(self, Y)


    def MinHammingDist(self, minterm: 'IntArray', upperBound: 'int') -> "int":
        """MinHammingDist(DdNode self, IntArray minterm, int upperBound) -> int"""
        return _pycudd.DdNode_MinHammingDist(self, minterm, upperBound)


    def Eval(self, inputs: 'IntArray') -> "DdNode *":
        """Eval(DdNode self, IntArray inputs) -> DdNode"""
        return _pycudd.DdNode_Eval(self, inputs)


    def ShortestPath(self, weight: 'IntArray', support: 'IntArray', length: 'IntArray') -> "DdNode *":
        """ShortestPath(DdNode self, IntArray weight, IntArray support, IntArray length) -> DdNode"""
        return _pycudd.DdNode_ShortestPath(self, weight, support, length)


    def LargestCube(self, length: 'IntArray') -> "DdNode *":
        """LargestCube(DdNode self, IntArray length) -> DdNode"""
        return _pycudd.DdNode_LargestCube(self, length)


    def ShortestLength(self, weight: 'IntArray') -> "int":
        """ShortestLength(DdNode self, IntArray weight) -> int"""
        return _pycudd.DdNode_ShortestLength(self, weight)


    def Decreasing(self, i: 'int') -> "DdNode *":
        """Decreasing(DdNode self, int i) -> DdNode"""
        return _pycudd.DdNode_Decreasing(self, i)


    def Increasing(self, i: 'int') -> "DdNode *":
        """Increasing(DdNode self, int i) -> DdNode"""
        return _pycudd.DdNode_Increasing(self, i)


    def EquivDC(self, G: 'DdNode', D: 'DdNode') -> "int":
        """EquivDC(DdNode self, DdNode G, DdNode D) -> int"""
        return _pycudd.DdNode_EquivDC(self, G, D)


    def EqualSupNorm(self, g: 'DdNode', tolerance: 'CUDD_VALUE_TYPE', pr: 'int') -> "int":
        """EqualSupNorm(DdNode self, DdNode g, CUDD_VALUE_TYPE tolerance, int pr) -> int"""
        return _pycudd.DdNode_EqualSupNorm(self, g, tolerance, pr)


    def CofMinterm(self) -> "DoubleArray *":
        """CofMinterm(DdNode self) -> DoubleArray"""
        return _pycudd.DdNode_CofMinterm(self)


    def SolveEqn(self, Y: 'DdNode', G: 'DdArray', yIndex: 'int **', n: 'int') -> "DdNode *":
        """SolveEqn(DdNode self, DdNode Y, DdArray G, int ** yIndex, int n) -> DdNode"""
        return _pycudd.DdNode_SolveEqn(self, Y, G, yIndex, n)


    def VerifySol(self, G: 'DdArray', yIndex: 'IntArray', n: 'int') -> "DdNode *":
        """VerifySol(DdNode self, DdArray G, IntArray yIndex, int n) -> DdNode"""
        return _pycudd.DdNode_VerifySol(self, G, yIndex, n)


    def SplitSet(self, xVars: 'DdArray', n: 'int', m: 'double') -> "DdNode *":
        """SplitSet(DdNode self, DdArray xVars, int n, double m) -> DdNode"""
        return _pycudd.DdNode_SplitSet(self, xVars, n, m)


    def SubsetHeavyBranch(self, numVars: 'int', threshold: 'int') -> "DdNode *":
        """SubsetHeavyBranch(DdNode self, int numVars, int threshold) -> DdNode"""
        return _pycudd.DdNode_SubsetHeavyBranch(self, numVars, threshold)


    def SupersetHeavyBranch(self, numVars: 'int', threshold: 'int') -> "DdNode *":
        """SupersetHeavyBranch(DdNode self, int numVars, int threshold) -> DdNode"""
        return _pycudd.DdNode_SupersetHeavyBranch(self, numVars, threshold)


    def SubsetShortPaths(self, numVars: 'int', threshold: 'int', hardlimit: 'int') -> "DdNode *":
        """SubsetShortPaths(DdNode self, int numVars, int threshold, int hardlimit) -> DdNode"""
        return _pycudd.DdNode_SubsetShortPaths(self, numVars, threshold, hardlimit)


    def SupersetShortPaths(self, numVars: 'int', threshold: 'int', hardlimit: 'int') -> "DdNode *":
        """SupersetShortPaths(DdNode self, int numVars, int threshold, int hardlimit) -> DdNode"""
        return _pycudd.DdNode_SupersetShortPaths(self, numVars, threshold, hardlimit)


    def BddToCubeArray(self, y: 'IntArray') -> "int":
        """BddToCubeArray(DdNode self, IntArray y) -> int"""
        return _pycudd.DdNode_BddToCubeArray(self, y)


    def PrintMinterm(self) -> "int":
        """PrintMinterm(DdNode self) -> int"""
        return _pycudd.DdNode_PrintMinterm(self)


    def PrintDebug(self, n: 'int', pr: 'int') -> "int":
        """PrintDebug(DdNode self, int n, int pr) -> int"""
        return _pycudd.DdNode_PrintDebug(self, n, pr)


    def EstimateCofactor(self, i: 'int', phase: 'int') -> "int":
        """EstimateCofactor(DdNode self, int i, int phase) -> int"""
        return _pycudd.DdNode_EstimateCofactor(self, i, phase)


    def CountMinterm(self, nvars: 'int') -> "double":
        """CountMinterm(DdNode self, int nvars) -> double"""
        return _pycudd.DdNode_CountMinterm(self, nvars)


    def Support(self) -> "DdNode *":
        """Support(DdNode self) -> DdNode"""
        return _pycudd.DdNode_Support(self)


    def SupportSize(self) -> "int":
        """SupportSize(DdNode self) -> int"""
        return _pycudd.DdNode_SupportSize(self)


    def Density(self, nvars: 'int') -> "double":
        """Density(DdNode self, int nvars) -> double"""
        return _pycudd.DdNode_Density(self, nvars)


    def NodeReadIndex(self) -> "int":
        """NodeReadIndex(DdNode self) -> int"""
        return _pycudd.DdNode_NodeReadIndex(self)


    def IsNonConstant(self) -> "int":
        """IsNonConstant(DdNode self) -> int"""
        return _pycudd.DdNode_IsNonConstant(self)


    def DagSize(self) -> "int":
        """DagSize(DdNode self) -> int"""
        return _pycudd.DdNode_DagSize(self)


    def EstimateCofactorSimple(self, i: 'int') -> "int":
        """EstimateCofactorSimple(DdNode self, int i) -> int"""
        return _pycudd.DdNode_EstimateCofactorSimple(self, i)


    def CountPath(self) -> "double":
        """CountPath(DdNode self) -> double"""
        return _pycudd.DdNode_CountPath(self)


    def CountLeaves(self) -> "int":
        """CountLeaves(DdNode self) -> int"""
        return _pycudd.DdNode_CountLeaves(self)


    def IsConstant(self) -> "int":
        """IsConstant(DdNode self) -> int"""
        return _pycudd.DdNode_IsConstant(self)


    def Not(self) -> "DdNode *":
        """Not(DdNode self) -> DdNode"""
        return _pycudd.DdNode_Not(self)


    def NotCond(self, c: 'int') -> "DdNode *":
        """NotCond(DdNode self, int c) -> DdNode"""
        return _pycudd.DdNode_NotCond(self, c)


    def Regular(self) -> "DdNode *":
        """Regular(DdNode self) -> DdNode"""
        return _pycudd.DdNode_Regular(self)


    def Complement(self) -> "DdNode *":
        """Complement(DdNode self) -> DdNode"""
        return _pycudd.DdNode_Complement(self)


    def IsComplement(self) -> "int":
        """IsComplement(DdNode self) -> int"""
        return _pycudd.DdNode_IsComplement(self)


    def T(self) -> "DdNode *":
        """T(DdNode self) -> DdNode"""
        return _pycudd.DdNode_T(self)


    def E(self) -> "DdNode *":
        """E(DdNode self) -> DdNode"""
        return _pycudd.DdNode_E(self)


    def V(self) -> "double":
        """V(DdNode self) -> double"""
        return _pycudd.DdNode_V(self)


    def ReadIndex(self, index: 'int') -> "int":
        """ReadIndex(DdNode self, int index) -> int"""
        return _pycudd.DdNode_ReadIndex(self, index)


    def addExistAbstract(self, cube: 'DdNode') -> "DdNode *":
        """addExistAbstract(DdNode self, DdNode cube) -> DdNode"""
        return _pycudd.DdNode_addExistAbstract(self, cube)


    def addUnivAbstract(self, cube: 'DdNode') -> "DdNode *":
        """addUnivAbstract(DdNode self, DdNode cube) -> DdNode"""
        return _pycudd.DdNode_addUnivAbstract(self, cube)


    def addOrAbstract(self, cube: 'DdNode') -> "DdNode *":
        """addOrAbstract(DdNode self, DdNode cube) -> DdNode"""
        return _pycudd.DdNode_addOrAbstract(self, cube)


    def addFindMax(self) -> "DdNode *":
        """addFindMax(DdNode self) -> DdNode"""
        return _pycudd.DdNode_addFindMax(self)


    def addFindMin(self) -> "DdNode *":
        """addFindMin(DdNode self) -> DdNode"""
        return _pycudd.DdNode_addFindMin(self)


    def addIthBit(self, bit: 'int') -> "DdNode *":
        """addIthBit(DdNode self, int bit) -> DdNode"""
        return _pycudd.DdNode_addIthBit(self, bit)


    def addScalarInverse(self, epsilon: 'DdNode') -> "DdNode *":
        """addScalarInverse(DdNode self, DdNode epsilon) -> DdNode"""
        return _pycudd.DdNode_addScalarInverse(self, epsilon)


    def addIte(self, g: 'DdNode', h: 'DdNode') -> "DdNode *":
        """addIte(DdNode self, DdNode g, DdNode h) -> DdNode"""
        return _pycudd.DdNode_addIte(self, g, h)


    def addIteConstant(self, g: 'DdNode', h: 'DdNode') -> "DdNode *":
        """addIteConstant(DdNode self, DdNode g, DdNode h) -> DdNode"""
        return _pycudd.DdNode_addIteConstant(self, g, h)


    def addEvalConst(self, g: 'DdNode') -> "DdNode *":
        """addEvalConst(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_addEvalConst(self, g)


    def addLeq(self, g: 'DdNode') -> "int":
        """addLeq(DdNode self, DdNode g) -> int"""
        return _pycudd.DdNode_addLeq(self, g)


    def addCmpl(self) -> "DdNode *":
        """addCmpl(DdNode self) -> DdNode"""
        return _pycudd.DdNode_addCmpl(self)


    def addNegate(self) -> "DdNode *":
        """addNegate(DdNode self) -> DdNode"""
        return _pycudd.DdNode_addNegate(self)


    def addRoundOff(self, N: 'int') -> "DdNode *":
        """addRoundOff(DdNode self, int N) -> DdNode"""
        return _pycudd.DdNode_addRoundOff(self, N)


    def addCompose(self, g: 'DdNode', v: 'int') -> "DdNode *":
        """addCompose(DdNode self, DdNode g, int v) -> DdNode"""
        return _pycudd.DdNode_addCompose(self, g, v)


    def addPermute(self, permut: 'IntArray') -> "DdNode *":
        """addPermute(DdNode self, IntArray permut) -> DdNode"""
        return _pycudd.DdNode_addPermute(self, permut)


    def addConstrain(self, c: 'DdNode') -> "DdNode *":
        """addConstrain(DdNode self, DdNode c) -> DdNode"""
        return _pycudd.DdNode_addConstrain(self, c)


    def addRestrict(self, c: 'DdNode') -> "DdNode *":
        """addRestrict(DdNode self, DdNode c) -> DdNode"""
        return _pycudd.DdNode_addRestrict(self, c)


    def addMatrixMultiply(self, B: 'DdNode', z: 'DdArray', nz: 'int') -> "DdNode *":
        """addMatrixMultiply(DdNode self, DdNode B, DdArray z, int nz) -> DdNode"""
        return _pycudd.DdNode_addMatrixMultiply(self, B, z, nz)


    def addTimesPlus(self, B: 'DdNode', z: 'DdArray', nz: 'int') -> "DdNode *":
        """addTimesPlus(DdNode self, DdNode B, DdArray z, int nz) -> DdNode"""
        return _pycudd.DdNode_addTimesPlus(self, B, z, nz)


    def addTriangle(self, g: 'DdNode', z: 'DdArray', nz: 'int') -> "DdNode *":
        """addTriangle(DdNode self, DdNode g, DdArray z, int nz) -> DdNode"""
        return _pycudd.DdNode_addTriangle(self, g, z, nz)


    def addVectorCompose(self, vector: 'DdArray') -> "DdNode *":
        """addVectorCompose(DdNode self, DdArray vector) -> DdNode"""
        return _pycudd.DdNode_addVectorCompose(self, vector)


    def addNonSimCompose(self, vector: 'DdArray') -> "DdNode *":
        """addNonSimCompose(DdNode self, DdArray vector) -> DdNode"""
        return _pycudd.DdNode_addNonSimCompose(self, vector)


    def addSwapVariables(self, x: 'DdArray', y: 'DdArray', n: 'int') -> "DdNode *":
        """addSwapVariables(DdNode self, DdArray x, DdArray y, int n) -> DdNode"""
        return _pycudd.DdNode_addSwapVariables(self, x, y, n)


    def zddProduct(self, g: 'DdNode') -> "DdNode *":
        """zddProduct(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_zddProduct(self, g)


    def zddUnateProduct(self, g: 'DdNode') -> "DdNode *":
        """zddUnateProduct(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_zddUnateProduct(self, g)


    def zddWeakDiv(self, g: 'DdNode') -> "DdNode *":
        """zddWeakDiv(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_zddWeakDiv(self, g)


    def zddDivide(self, g: 'DdNode') -> "DdNode *":
        """zddDivide(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_zddDivide(self, g)


    def zddWeakDivF(self, g: 'DdNode') -> "DdNode *":
        """zddWeakDivF(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_zddWeakDivF(self, g)


    def zddDivideF(self, g: 'DdNode') -> "DdNode *":
        """zddDivideF(DdNode self, DdNode g) -> DdNode"""
        return _pycudd.DdNode_zddDivideF(self, g)


    def zddComplement(self) -> "DdNode *":
        """zddComplement(DdNode self) -> DdNode"""
        return _pycudd.DdNode_zddComplement(self)


    def zddIte(self, g: 'DdNode', h: 'DdNode') -> "DdNode *":
        """zddIte(DdNode self, DdNode g, DdNode h) -> DdNode"""
        return _pycudd.DdNode_zddIte(self, g, h)


    def zddUnion(self, Q: 'DdNode') -> "DdNode *":
        """zddUnion(DdNode self, DdNode Q) -> DdNode"""
        return _pycudd.DdNode_zddUnion(self, Q)


    def zddIntersect(self, Q: 'DdNode') -> "DdNode *":
        """zddIntersect(DdNode self, DdNode Q) -> DdNode"""
        return _pycudd.DdNode_zddIntersect(self, Q)


    def zddDiff(self, Q: 'DdNode') -> "DdNode *":
        """zddDiff(DdNode self, DdNode Q) -> DdNode"""
        return _pycudd.DdNode_zddDiff(self, Q)


    def zddDiffConst(self, Q: 'DdNode') -> "DdNode *":
        """zddDiffConst(DdNode self, DdNode Q) -> DdNode"""
        return _pycudd.DdNode_zddDiffConst(self, Q)


    def zddSubset1(self, var: 'int') -> "DdNode *":
        """zddSubset1(DdNode self, int var) -> DdNode"""
        return _pycudd.DdNode_zddSubset1(self, var)


    def zddSubset0(self, var: 'int') -> "DdNode *":
        """zddSubset0(DdNode self, int var) -> DdNode"""
        return _pycudd.DdNode_zddSubset0(self, var)


    def zddChange(self, var: 'int') -> "DdNode *":
        """zddChange(DdNode self, int var) -> DdNode"""
        return _pycudd.DdNode_zddChange(self, var)


    def zddCount(self) -> "int":
        """zddCount(DdNode self) -> int"""
        return _pycudd.DdNode_zddCount(self)


    def zddCountDouble(self) -> "double":
        """zddCountDouble(DdNode self) -> double"""
        return _pycudd.DdNode_zddCountDouble(self)


    def zddPrintMinterm(self) -> "int":
        """zddPrintMinterm(DdNode self) -> int"""
        return _pycudd.DdNode_zddPrintMinterm(self)


    def zddPrintCover(self) -> "int":
        """zddPrintCover(DdNode self) -> int"""
        return _pycudd.DdNode_zddPrintCover(self)


    def zddPrintDebug(self, n: 'int', pr: 'int') -> "int":
        """zddPrintDebug(DdNode self, int n, int pr) -> int"""
        return _pycudd.DdNode_zddPrintDebug(self, n, pr)


    def zddCountMinterm(self, path: 'int') -> "double":
        """zddCountMinterm(DdNode self, int path) -> double"""
        return _pycudd.DdNode_zddCountMinterm(self, path)


    def zddIsop(self, U: 'DdNode', zdd_I: 'DdArray') -> "DdNode *":
        """zddIsop(DdNode self, DdNode U, DdArray zdd_I) -> DdNode"""
        return _pycudd.DdNode_zddIsop(self, U, zdd_I)


    def zddDagSize(self, p_node: 'DdNode') -> "int":
        """zddDagSize(DdNode self, DdNode p_node) -> int"""
        return _pycudd.DdNode_zddDagSize(self, p_node)


    def ApaCountMinterm(self, nvars: 'int', digits: 'IntArray') -> "DdApaNumber":
        """ApaCountMinterm(DdNode self, int nvars, IntArray digits) -> DdApaNumber"""
        return _pycudd.DdNode_ApaCountMinterm(self, nvars, digits)


    def __hash__(self) -> "int":
        """__hash__(DdNode self) -> int"""
        return _pycudd.DdNode___hash__(self)


    def __int__(self) -> "int":
        """__int__(DdNode self) -> int"""
        return _pycudd.DdNode___int__(self)


    def __and__(self, other: 'DdNode') -> "DdNode *":
        """__and__(DdNode self, DdNode other) -> DdNode"""
        return _pycudd.DdNode___and__(self, other)


    def __or__(self, other: 'DdNode') -> "DdNode *":
        """__or__(DdNode self, DdNode other) -> DdNode"""
        return _pycudd.DdNode___or__(self, other)


    def __xor__(self, other: 'DdNode') -> "DdNode *":
        """__xor__(DdNode self, DdNode other) -> DdNode"""
        return _pycudd.DdNode___xor__(self, other)


    def __invert__(self) -> "DdNode *":
        """__invert__(DdNode self) -> DdNode"""
        return _pycudd.DdNode___invert__(self)


    def __rshift__(self, other: 'DdNode') -> "DdNode *":
        """__rshift__(DdNode self, DdNode other) -> DdNode"""
        return _pycudd.DdNode___rshift__(self, other)


    def __cmp__(self, other: 'DdNode') -> "bool":
        """__cmp__(DdNode self, DdNode other) -> bool"""
        return _pycudd.DdNode___cmp__(self, other)


    def __sub__(self, other: 'DdNode') -> "DdNode *":
        """__sub__(DdNode self, DdNode other) -> DdNode"""
        return _pycudd.DdNode___sub__(self, other)


    def __add__(self, other: 'DdNode') -> "DdNode *":
        """__add__(DdNode self, DdNode other) -> DdNode"""
        return _pycudd.DdNode___add__(self, other)


    def __lt__(self, other: 'DdNode') -> "bool":
        """__lt__(DdNode self, DdNode other) -> bool"""
        return _pycudd.DdNode___lt__(self, other)


    def __le__(self, other: 'DdNode') -> "bool":
        """__le__(DdNode self, DdNode other) -> bool"""
        return _pycudd.DdNode___le__(self, other)


    def __eq__(self, other: 'DdNode') -> "bool":
        """__eq__(DdNode self, DdNode other) -> bool"""
        return _pycudd.DdNode___eq__(self, other)


    def __ne__(self, other: 'DdNode') -> "bool":
        """__ne__(DdNode self, DdNode other) -> bool"""
        return _pycudd.DdNode___ne__(self, other)


    def __gt__(self, other: 'DdNode') -> "bool":
        """__gt__(DdNode self, DdNode other) -> bool"""
        return _pycudd.DdNode___gt__(self, other)


    def __ge__(self, other: 'DdNode') -> "bool":
        """__ge__(DdNode self, DdNode other) -> bool"""
        return _pycudd.DdNode___ge__(self, other)


    def __nonzero__(self) -> "bool":
        """__nonzero__(DdNode self) -> bool"""
        return _pycudd.DdNode___nonzero__(self)


    def __len__(self) -> "int":
        """__len__(DdNode self) -> int"""
        return _pycudd.DdNode___len__(self)


    def SizeOf(self) -> "int":
        """SizeOf(DdNode self) -> int"""
        return _pycudd.DdNode_SizeOf(self)


    def Show(self, name: 'char *', op1: 'int', op2: 'int') -> "void":
        """Show(DdNode self, char * name, int op1, int op2)"""
        return _pycudd.DdNode_Show(self, name, op1, op2)


    def Empty(self) -> "bool":
        """Empty(DdNode self) -> bool"""
        return _pycudd.DdNode_Empty(self)


    def DumpDot(self) -> "int":
        """DumpDot(DdNode self) -> int"""
        return _pycudd.DdNode_DumpDot(self)


    def DumpBlif(self) -> "int":
        """DumpBlif(DdNode self) -> int"""
        return _pycudd.DdNode_DumpBlif(self)


    def Vector(self) -> "DdArray *":
        """Vector(DdNode self) -> DdArray"""
        return _pycudd.DdNode_Vector(self)

DdNode_swigregister = _pycudd.DdNode_swigregister
DdNode_swigregister(DdNode)

class NodePair(_object):
    """Proxy of C++ NodePair class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr_nondynamic(self, NodePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NodePair, name)
    __repr__ = _swig_repr

    def __iter__(self):
      global iter_meth
      if iter_meth != 2:
        print("Can only enumerate primes for a NodePair. Setting iter_meth == 2 and proceeding")
        iter_meth == 2
      return ForeachPrimeIterator(self)
    __doc__="This is used to provide the functionality of prime enumeration in CUDD 2.4.0. Create the NodePair by passing the DdNodes for lower and upper to the constructor. Once that is done, you can iterate over the primes of the NodePair using the Python for statement. There is no need to do this if you are interested in the primes of a simple DdNode -- the package automatically creates the NodePair and destroys it in that case."



    def __init__(self, lwr: 'DdNode', upr: 'DdNode'):
        """__init__(NodePair self, DdNode lwr, DdNode upr) -> NodePair"""
        this = _pycudd.new_NodePair(lwr, upr)
        try:
            self.this.append(this)
        except:
            self.this = this
    __swig_destroy__ = _pycudd.delete_NodePair
    __del__ = lambda self: None

    def LOWER(self) -> "DdNode *":
        """LOWER(NodePair self) -> DdNode"""
        return _pycudd.NodePair_LOWER(self)


    def UPPER(self) -> "DdNode *":
        """UPPER(NodePair self) -> DdNode"""
        return _pycudd.NodePair_UPPER(self)


    def FirstPrime(self, gen: 'DdGen') -> "int":
        """FirstPrime(NodePair self, DdGen gen) -> int"""
        return _pycudd.NodePair_FirstPrime(self, gen)


    def NextPrime(self, gen: 'DdGen') -> "int":
        """NextPrime(NodePair self, DdGen gen) -> int"""
        return _pycudd.NodePair_NextPrime(self, gen)

NodePair_swigregister = _pycudd.NodePair_swigregister
NodePair_swigregister(NodePair)


cudd_version = 0x020400


###############################
#
# iter_meth is used to set, surprise, the iteration method for DdNodes
# 0 -- over cubes
# 1 -- over nodes
# 2 -- over primes
# Note that iteration over primes is only available in CUDD >= 2.4.0
#
################################
iter_meth = 0

def set_iter_meth(meth,verbose = False):
  global iter_meth
  methods = ["cubes", "nodes", "primes"]
  if verbose:
      print("Setting iter method to iterate over ",methods[meth])
  iter_meth = meth

class ForeachCubeIterator:
    def __init__(self,Dd):
        self.gen = DdGen(Dd,iter_meth)
        self.node = Dd
        self.done = 0
        self.ret_val = Dd.FirstCube(self.gen)
        if not self.ret_val[0]: self.done = 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.done: raise StopIteration
        to_ret = self.ret_val[1:]
        self.ret_val = self.node.NextCube(self.gen)
        if not self.ret_val[0]:
            self.done = 1
        return to_ret
    next = __next__

class ForeachNodeIterator:
    def __init__(self,Dd):
        self.gen = DdGen(Dd,iter_meth)
        self.node = Dd
        self.done = 0
        self.ret_val = Dd.FirstNode(self.gen)
        if not self.ret_val[0]: self.done = 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.done: raise StopIteration
        to_ret = self.ret_val[1]
        self.ret_val = self.node.NextNode(self.gen)
        if not self.ret_val[0]:
            self.done = 1
        return to_ret
    next = __next__

class ForeachPrimeIterator:
    def __init__(self,npair):
        global cudd_version
        if cudd_version < 0x020400:
            print("CUDD versions < 2.4.0 do not support iteration over primes")
            raise RuntimeError
        self.gen = DdGen(npair.LOWER(), iter_meth, npair.UPPER())
        self.npair = npair
        self.done = 0
        self.ret_val = npair.FirstPrime(self.gen)
        if not self.ret_val[0]: self.done = 1
    def __iter__(self):
        return self

    def __next__(self):
        if self.done: raise StopIteration
        to_ret = self.ret_val[1:]
        self.ret_val = self.npair.NextPrime(self.gen)
        if not self.ret_val[0]:
            self.done = 1
        return to_ret
    next = __next__

def cube_tuple_to_str(cube_tup):
    res = ""
    for char in cube_tup:
        if char == 2: res += '-'
        else: res += str(char)
    return res

# This file is compatible with both classic and new-style classes.


