""" JupyterLab Zenodo : Exporting from JupyterLab to Zenodo """

import json
import logging
import os
import re
import requests

from slugify import slugify
from tornado import gen, web

from .base import ZenodoBaseHandler
from .database import store_record
from .utils import add_query_parameter, get_id, UserMistake, zip_dir
from .zenodo import Deposition

LOG = logging.getLogger(__name__)

ZENODO_MIN_FIELD_LENGTH = 3


class ZenodoUploadHandler(ZenodoBaseHandler):
    """
    A handler that uploads your files to Zenodo
    """
    def upload_file(self, path_to_file, metadata, access_token):
        """Upload the given file at the given path to Zenodo
           Add included metadata

        Parameters
        ----------
        path_to_file : string
            Path to the file to be uploaded (including file name)
        metadata : dictionary
            As generated by assemble_metadata()
        access_token : string
            Zenodo API token

        Returns
        -------
        string
            Doi of successfully uploaded deposition

        Notes
        -----
        - Raises an exception if something goes wrong
        - If it returns, it returns a real DOI
        """
        deposition = Deposition(self.dev, access_token)
        deposition.zenodo_init()
        deposition.set_file(path_to_file)
        deposition.set_metadata(metadata)
        deposition.publish()

        return deposition.doi

    @web.authenticated
    @gen.coroutine
    def post(self, path='', notebook_dir=None):
        """
        Takes in a a file prefix string, and metadata
        Zips notebook_dir to filename.zip, uploads to Zenodo
        Returns dictionary with status (success or failure)
           and doi (if successful)
        """
        self.check_xsrf_cookie()
        request_data = json.loads(self.request.body.decode('utf-8'))

        try:
            upload_data = assemble_upload_data(request_data, self.access_token)
            metadata = assemble_metadata(request_data, self.community)

            directory = os.path.join(self.notebook_dir, upload_data['directory_to_zip'])
            archive = zip_dir(directory)
            doi = self.upload_file(archive, metadata, upload_data['access_token'])
        except UserMistake as e:
            # UserMistake exceptions contain messages for the user
            self.return_error(str(e))
        except Exception:
            # All other exceptions are internal
            LOG.exception("There was an error!")
            self.return_error("Something went wrong")
        else:
            # Record the upload and return success
            store_record(doi, upload_data['directory_to_zip'], self.db_path)
            info = dict(status='success', doi=doi)

            redirect = self.zenodo_config.upload_redirect_url
            if redirect:
                info['redirect'] = add_query_parameter(redirect, info)

            # Return info with a 201 status
            self.set_status(201)
            self.write(info)
            self.finish()


def assemble_upload_data(request_data, tok):
    """Gather and validate directory and access token for upload
    Parameters
    ----------
    request_data : dictionary
        Contains the information sent with the POST request

    Returns
    -------
    dictionary
        With access_token and directory_to_zip, and filename, all non-empty

    Notes
    -----
    - Raises an exception if data is invalid
    """

    # If the user has no access token, use ours
    access_token = request_data.get('zenodo_token')
    if not access_token:
        access_token = tok

    # If they provided no access token and there are no defaults, ask again
    if not access_token:
        raise UserMistake("There are no default Zenodo access tokens in this "
                          "JupyterLab environment, so you must provide your own"
                          ". To create one, go to https://zenodo.org"
                          "/account/settings/applications/tokens/new/")

    directory = request_data.get('directory', '').strip()
    # Strip leading path components
    directory = re.sub(r'^[\.\/]+', '', directory)

    # Assemble into dictionary to return
    return {
        'access_token': access_token,
        'directory_to_zip': directory,
    }


def assemble_metadata(request_data, community):
    """Turn metadata into a dictionary for Zenodo upload
        Parameters
    ----------
    request_data : dictionary
        Contains the information sent with the POST request
    Returns
    -------
    dictionary
        With title, creators, afilliation and description
        Each three or more characters long

    Notes
    -----
    - Raises an exception if data is invalid
    """
    # Get basic metadata from form response
    title = request_data.get('title', '')
    authors = request_data.get('author', '')
    affiliations = request_data.get('affiliation', '')
    description = request_data.get('description', '')

    # Zenodo requires each field to be at least 4 characters long
    if any(map(lambda x: len(x) < ZENODO_MIN_FIELD_LENGTH,
           [title, authors, description, affiliations])):
        msg = ("Title, author, afilliation, and description fields must all"
               " be filled in and at least three characters long")
        raise UserMistake(msg)

    # Turn lists of author and affiliation strings
    # into a list of author dictionaries
    author_list = [a.strip() for a in authors.split(',')]
    affiliation_list = [a.strip() for a in affiliations.split(',')]
    if len(author_list) != len(affiliation_list):
        raise UserMistake("Please list an affiliation for each author separated"
                          " by commas, even if there are repeats")
    creator_list = [{'name':name, 'affiliation':place} for
                    (name, place) in zip(author_list, affiliation_list)]

    # Put data into dictionary to return
    metadata = {}
    metadata['title'] = title
    metadata['upload_type'] = 'publication'
    metadata['publication_type'] = 'workingpaper'
    if community:
        metadata['communities'] = [{'identifier': community}]
    metadata['description'] = description
    metadata['creators'] = creator_list
    return metadata
